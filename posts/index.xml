<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on CayChance の Blog</title>
		<link>https://caychance.github.io/posts/</link>
		<description>Recent content in Posts on CayChance の Blog</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Thu, 18 Mar 2021 23:15:24 +0800</lastBuildDate>
		<atom:link href="https://caychance.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>前端面试-真题汇总1</title>
			<link>https://caychance.github.io/posts/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-%E7%9C%9F%E9%A2%98%E6%B1%87%E6%80%BB1/</link>
			<pubDate>Thu, 18 Mar 2021 23:15:24 +0800</pubDate>
			
			<guid>https://caychance.github.io/posts/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-%E7%9C%9F%E9%A2%98%E6%B1%87%E6%80%BB1/</guid>
			<description>写在前面的话 由于疫情的影响，公司整体的运营情况不太理想，加之领导的一些“莫名其妙”的行为，就有了离职的想法了。
一些心得和总结 1、由于疫情影响，基本都是视频面试了。百分之95都不用去现场，通几轮技术面到HR面都是网上进行的。使用的软件也是五花八门，瞩目，牛客网，微信视频，腾讯会议，或者各公司自己研发的视频软件。（伴鱼当时就邀请去现场面试，后来一想，路上太远，来回2小时，有这时间都能面两个了，所以就拒了；然后京东1、2面过了以后3，4面邀请去的现场，除此以外就没有让去现场面试的了）
2、面试真的很随机，完全看整个部门，尤其是面试官本身
3、大厂好多都会问算法题，不过一般就是leetcode的简单题目
4、手写题也很常见，比如bind，promise，promise all，防抖节流，深拷贝，发布订阅-EventEmitter，快排等（手写题可参考项目utils.js文件）
5、每一轮面试都要好好准备，三四面也可能会被刷掉
美团： 1、this作用域 var scope = 123; var obj = { scope: 456, getScope: function () { var scope = 789; console.log(scope); console.log(this.scope); var f = function() { console.log(scope); console.log(this.scope); } f(); }, }; obj.getScope(); // 1、说一下打印结果 // 2、getScope改成箭头函数的打印结果  2、原型和原型链 function A() {} var a = new A() A.prototype A.__proto__ a.__proto__ a.prototype  3、实现一个myReduce方法，使得与reduce方法作用一致 4、拓展题 请实现 reverseObject(obj, startIndex, endIndex) 方法。 扩展题：如何做到算法复杂度最小 示例：reverseObject(obj, 2, 5) const obj = { value: 12, next: { value: 13, next: { value: 14, next: { value: 15, next: { value: 16 } } } } } 变成： { value: 12, next: { value: 16, next: { value: 15, next: { value: 14, next: { value: 13 } } } } }  快手： 一面 1、this 作用域 var name = &amp;#39;x&amp;#39; var people = { name: &amp;#39;y&amp;#39;, setName: function(name) { this.</description>
			<content type="html"><![CDATA[

<h3 id="写在前面的话">写在前面的话</h3>

<p>由于疫情的影响，公司整体的运营情况不太理想，加之领导的一些“莫名其妙”的行为，就有了离职的想法了。</p>

<h3 id="一些心得和总结">一些心得和总结</h3>

<p>1、由于疫情影响，基本都是视频面试了。百分之95都不用去现场，通几轮技术面到HR面都是网上进行的。使用的软件也是五花八门，瞩目，牛客网，微信视频，腾讯会议，或者各公司自己研发的视频软件。（伴鱼当时就邀请去现场面试，后来一想，路上太远，来回2小时，有这时间都能面两个了，所以就拒了；然后京东1、2面过了以后3，4面邀请去的现场，除此以外就没有让去现场面试的了）</p>

<p>2、面试真的很随机，完全看整个部门，尤其是面试官本身</p>

<p>3、大厂好多都会问算法题，不过一般就是leetcode的简单题目</p>

<p>4、手写题也很常见，比如bind，promise，promise all，防抖节流，深拷贝，发布订阅-EventEmitter，快排等（手写题可参考项目utils.js文件）</p>

<p>5、每一轮面试都要好好准备，三四面也可能会被刷掉</p>

<h3 id="美团">美团：</h3>

<h4 id="1-this作用域">1、this作用域</h4>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">scope</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">scope</span><span class="o">:</span> <span class="mi">456</span><span class="p">,</span>
  <span class="nx">getScope</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">scope</span> <span class="o">=</span> <span class="mi">789</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">scope</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">scope</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">scope</span><span class="p">);</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">scope</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">f</span><span class="p">();</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">getScope</span><span class="p">();</span>
<span class="c1">// 1、说一下打印结果
</span><span class="c1">// 2、getScope改成箭头函数的打印结果
</span></code></pre></div>
<h4 id="2-原型和原型链">2、原型和原型链</h4>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">A</span><span class="p">()</span> <span class="p">{}</span>

<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">()</span>

<span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span>
<span class="nx">A</span><span class="p">.</span><span class="nx">__proto__</span>

<span class="nx">a</span><span class="p">.</span><span class="nx">__proto__</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">prototype</span>
</code></pre></div>
<h4 id="3-实现一个myreduce方法-使得与reduce方法作用一致">3、实现一个myReduce方法，使得与reduce方法作用一致</h4>

<h4 id="4-拓展题">4、拓展题</h4>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">请实现</span> <span class="nx">reverseObject</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">startIndex</span><span class="p">,</span> <span class="nx">endIndex</span><span class="p">)</span> <span class="nx">方法</span><span class="err">。</span>
<span class="nx">扩展题</span><span class="err">：</span><span class="nx">如何做到算法复杂度最小</span>

<span class="nx">示例</span><span class="err">：</span><span class="nx">reverseObject</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

<span class="k">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">value</span><span class="o">:</span> <span class="mi">12</span><span class="p">,</span>
  <span class="nx">next</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">value</span><span class="o">:</span> <span class="mi">13</span><span class="p">,</span>
    <span class="nx">next</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">value</span><span class="o">:</span> <span class="mi">14</span><span class="p">,</span>
      <span class="nx">next</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">value</span><span class="o">:</span> <span class="mi">15</span><span class="p">,</span>
        <span class="nx">next</span><span class="o">:</span> <span class="p">{</span> 
          <span class="nx">value</span><span class="o">:</span> <span class="mi">16</span> 
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="nx">变成</span><span class="err">：</span>
<span class="p">{</span>
  <span class="nx">value</span><span class="o">:</span> <span class="mi">12</span><span class="p">,</span>
  <span class="nx">next</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">value</span><span class="o">:</span> <span class="mi">16</span><span class="p">,</span>
    <span class="nx">next</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">value</span><span class="o">:</span> <span class="mi">15</span><span class="p">,</span>
      <span class="nx">next</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">value</span><span class="o">:</span> <span class="mi">14</span><span class="p">,</span>
        <span class="nx">next</span><span class="o">:</span> <span class="p">{</span> 
          <span class="nx">value</span><span class="o">:</span> <span class="mi">13</span> 
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="快手">快手：</h3>

<h3 id="一面">一面</h3>

<h4 id="1-this-作用域">1、this 作用域</h4>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="s1">&#39;x&#39;</span>
<span class="kd">var</span> <span class="nx">people</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span>
  <span class="nx">setName</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span>
    <span class="k">return</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">getName</span> <span class="o">=</span> <span class="nx">people</span><span class="p">.</span><span class="nx">setName</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">people</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">getName</span><span class="p">())</span>
<span class="c1">// 1、打印结果
</span><span class="c1">// 2、setName改成箭头函数打印结果
</span></code></pre></div>
<h4 id="2-事件循环">2、事件循环</h4>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;start&#39;</span><span class="p">)</span>
<span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;timer1&#39;</span><span class="p">)</span>
  <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;promise1&#39;</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">},</span> <span class="mi">0</span><span class="p">)</span>
<span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;timer2&#39;</span><span class="p">)</span>
  <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;promise2&#39;</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">},</span> <span class="mi">0</span><span class="p">)</span>
<span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;promise3&#39;</span><span class="p">)</span>
<span class="p">})</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;end&#39;</span><span class="p">)</span>
</code></pre></div>
<h4 id="3-论述题">3、论述题</h4>

<ol>
<li>ES2016-2020新特性。async/await，import(&lsquo;./module&rsquo;)，obj?.prop，BigInt</li>
<li>为什么JS中<code>0.1+0.2 !== 0.3</code>？如何解决？</li>
<li>vue的scoped css是如何实现样式隔离的？css modules呢？</li>
<li>移动端css布局单位了解哪些？rem对比vw？1px边框问题？</li>
<li>了解哪些跨域方式？</li>
<li>前端性能优化做过哪些工作？</li>
</ol>

<h4 id="4-手写防抖函数">4、手写防抖函数</h4>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">debounce</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">time</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></div>
<h4 id="5-算法题">5、算法题</h4>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">给定一个只包括</span> <span class="s1">&#39;(&#39;</span><span class="err">，</span><span class="s1">&#39;)&#39;</span><span class="err">，</span><span class="s1">&#39;{&#39;</span><span class="err">，</span><span class="s1">&#39;}&#39;</span> <span class="nx">的字符串</span><span class="err">，</span><span class="nx">判断字符串是否有效</span><span class="err">。</span>
<span class="nx">有效字符串需满足</span><span class="err">：</span>
<span class="nx">左括号必须用相同类型的右括号闭合</span><span class="err">。</span>
<span class="nx">左括号必须以正确的顺序闭合</span><span class="err">。</span> 
<span class="cm">/**
</span><span class="cm"> * @param {String} str
</span><span class="cm"> * @returns {Boolean}
</span><span class="cm"> */</span>
<span class="kd">function</span> <span class="nx">isValid</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">({)}</span> <span class="kc">false</span>
<span class="p">({})</span> <span class="p">(){}</span> <span class="kc">true</span>
</code></pre></div>
<h3 id="二面">二面</h3>

<h4 id="1-原型链">1、原型链</h4>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">arr</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">B</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){}</span>
<span class="nx">B</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">()</span>

<span class="kd">var</span> <span class="nx">a1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">B</span><span class="p">()</span>
<span class="kd">var</span> <span class="nx">a2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">B</span><span class="p">()</span>

<span class="nx">a1</span><span class="p">.</span><span class="nx">arr</span><span class="o">=</span><span class="mi">2</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a2</span><span class="p">.</span><span class="nx">arr</span><span class="p">)</span>
<span class="k">new</span> <span class="nx">A</span><span class="p">()</span>
</code></pre></div>
<h4 id="2-css相关">2、css相关</h4>

<p>2.1、权重问题
2.2、左右，上下margin
2.3、BFC
2.4、</p>
<div class="highlight"><pre class="chroma"><code class="language-css" data-lang="css"><span class="nt">body</span> <span class="p">{</span>
  <span class="k">font-size</span><span class="p">:</span> <span class="mi">12</span><span class="kt">px</span><span class="p">;</span>
  <span class="k">text-indent</span><span class="p">:</span> <span class="mi">3</span><span class="kt">em</span><span class="p">;</span> 
<span class="p">}</span>

<span class="nt">h1</span> <span class="p">{</span> <span class="k">font-size</span><span class="p">:</span> <span class="mi">15</span><span class="kt">px</span> <span class="p">}</span></code></pre></div>
<h4 id="3-手写promise-all">3、手写promise All</h4>

<h4 id="4-算法题">4、算法题</h4>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">用两个栈实现一个队列</span>

<span class="kd">function</span> <span class="nx">Stack</span><span class="p">(){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">arr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">pop</span> <span class="o">=</span><span class="kd">function</span><span class="p">(){</span>
        <span class="k">return</span>  <span class="k">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">push</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">item</span><span class="p">){</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">isEmpty</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
         <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="o">&lt;=</span><span class="mi">0</span>    
    <span class="p">}</span> 
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">stack1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Stack</span><span class="p">()</span>
<span class="kd">var</span> <span class="nx">stack2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Stack</span><span class="p">()</span>
</code></pre></div>
<h3 id="其他-promise相关的题目">其他（promise相关的题目）</h3>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// 1、axios请求失败的时候再重试一遍
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">axiosAutoTry</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">axios</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
      <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">data</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">resolve</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
      <span class="p">})</span>
      <span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">error</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="c1">// 有重试次数
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">data</span><span class="p">.</span><span class="nx">__try_count</span> <span class="o">==</span> <span class="s2">&#34;number&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">data</span><span class="p">.</span><span class="nx">__try_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="s2">&#34;重试请求&#34;</span><span class="p">,</span> <span class="nx">error</span><span class="p">.</span><span class="nx">message</span><span class="p">,</span> <span class="nx">data</span><span class="p">);</span>
          <span class="nx">data</span><span class="p">.</span><span class="nx">__try_count</span><span class="o">--</span><span class="p">;</span>
          <span class="k">return</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">axiosAutoTry</span><span class="p">(</span><span class="nx">data</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="nx">reject</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
      <span class="p">});</span>
  <span class="p">});</span>
<span class="p">}</span>

<span class="c1">// 2、实现一个红绿灯
</span><span class="c1">// 要求实现：红灯亮(打印)3s后，绿灯亮(打印)2s后，黄灯亮(打印)1s后循环
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">log</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">map</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;&#34;</span><span class="p">,</span> <span class="s2">&#34;yellow&#34;</span><span class="p">,</span> <span class="s2">&#34;green&#34;</span><span class="p">,</span> <span class="s2">&#34;red&#34;</span><span class="p">];</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">map</span><span class="p">[</span><span class="nx">num</span><span class="p">],</span> <span class="nx">num</span><span class="p">);</span>
    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">num</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="nx">num</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
      <span class="nx">resolve</span><span class="p">(</span><span class="nx">num</span><span class="p">);</span>
    <span class="p">},</span> <span class="nx">num</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">light</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">num</span><span class="o">--</span><span class="p">;</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">(</span><span class="nx">num</span><span class="p">).</span><span class="nx">then</span><span class="p">((</span><span class="nx">data</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="nx">light</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">});</span>
<span class="p">}</span>
<span class="nx">light</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>


<span class="c1">// 3、已知fetch 是新的请求接口方法. 如: 获取user我们可以像下面这样调用:
</span><span class="c1"></span><span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;/user&#39;</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">user</span> <span class="p">=&gt;</span> <span class="p">{})</span>
<span class="c1">// 请将fetch封装为一个函数xFetch, 让fetch 支持超时后返回,超时异常。调用方法如下所示
</span><span class="c1"></span><span class="nx">xFetch</span><span class="p">(</span><span class="s1">&#39;/user&#39;</span><span class="p">,</span> <span class="p">{</span><span class="nx">timeout</span><span class="o">:</span> <span class="mi">3000</span><span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="nx">err</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">code</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;请求超时&#39;</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="kd">function</span> <span class="nx">xFetch</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">params</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)=&gt;{</span>
    <span class="nx">fetch</span><span class="p">(</span><span class="nx">path</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">data</span><span class="p">=&gt;{</span>
      <span class="nx">setTimeout</span><span class="p">(()=&gt;{</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">resolve</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
          <span class="nx">reject</span><span class="p">({</span><span class="nx">code</span><span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">})</span>
        <span class="p">}</span>
      <span class="p">},</span> <span class="nx">params</span><span class="p">.</span><span class="nx">timeout</span><span class="p">)</span>
    <span class="p">})</span>
  <span class="p">})</span>
<span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>前端面试-面试题总结2</title>
			<link>https://caychance.github.io/posts/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%932/</link>
			<pubDate>Thu, 18 Mar 2021 23:12:01 +0800</pubDate>
			
			<guid>https://caychance.github.io/posts/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%932/</guid>
			<description>面试题部分 组件设计的原则  标准性 组件库要有统一设计原则，提供统一的api支持 独立性 组件要遵循单一职责原则，保持组件的纯粹性，除了统一的api对外提供，尽量不要和业务耦合 复用和易用 差异在内部消化，输入输出友好、易用 避免操作dom和使用ref 组件理论上只处理逻辑并不完成dom更新 良好统一的接口设计 合理的依赖关系，避免过度依赖和耦合过于严重 避免冗余状态 合理设置state，常亮和变量设置要合理  前端架构如何设计  一般分成项目层面的、标准化方面的、自动集成层面的 项目层面，用脚手架构建基本的开发目录，也就是src下，你还要重新划分这么几个目录：pages、components、store、utils、services、assets、styles。 标准化方面，可以从eslint、stylelint、git hooks、编辑器支持、等等方面着手，让代码更规范，甚至引入code review等等。 自动集成层面利用gitlab等工具，做自动化集成，部署等等。gitlab作为仓库，Jenkins作为发布平台。直接做那种自动push代码，自动发布功能。  前端提效  自动化部署平台 高效脚手架工具研发 组件库建设 自动化测试工具研发  webpack构建速度优化有哪些方式  分析打包速度和体积，合理进行优化  使用SMP(speed-measure-webpack-plugin) 速度分析 webpack-bundle-analyzer 体积分析  打包速度：
 多进程，多实例构建 thread-loader(将模块以及依赖分配给worker线程中) happypack(不建议对loader使用) parallel-webpack(可并行运行多个Webpack构建) 缩小打包作用域 exclude/include (确定 loader 规则范围，babel-loader不去解析node_modules) resolve.modules 指明第三方模块的绝对路径 (减少不必要的查找) resolve.extensions 尽可能减少后缀尝试的可能性 noParse 忽略不需要解析的库 Jquery, loadsh 利用缓存提升速率 babel-loader开启缓存 使用cache-loader等 开启DLL 分包。使用DllPlugin进行分包，能把第三方库代码分离开，每次文件更改的时候，它只会打包该项目自身的代码。合理使用manifest.json文件 减少对不频繁更新的库的编译。使用 DllPlugin 将不频繁更新的库进行编译以后，当这些依赖的版本没有变化时，就不需要重新编译  打包体积优化</description>
			<content type="html"><![CDATA[

<h2 id="面试题部分">面试题部分</h2>

<h3 id="组件设计的原则">组件设计的原则</h3>

<ul>
<li>标准性
组件库要有统一设计原则，提供统一的api支持</li>
<li>独立性
组件要遵循单一职责原则，保持组件的纯粹性，除了统一的api对外提供，尽量不要和业务耦合</li>
<li>复用和易用
差异在内部消化，输入输出友好、易用</li>
<li>避免操作dom和使用ref
组件理论上只处理逻辑并不完成dom更新</li>
<li>良好统一的接口设计
合理的依赖关系，避免过度依赖和耦合过于严重</li>
<li>避免冗余状态
合理设置state，常亮和变量设置要合理</li>
</ul>

<h3 id="前端架构如何设计">前端架构如何设计</h3>

<ul>
<li>一般分成项目层面的、标准化方面的、自动集成层面的</li>
<li>项目层面，用脚手架构建基本的开发目录，也就是src下，你还要重新划分这么几个目录：pages、components、store、utils、services、assets、styles。</li>
<li>标准化方面，可以从eslint、stylelint、git hooks、编辑器支持、等等方面着手，让代码更规范，甚至引入code review等等。</li>
<li>自动集成层面利用gitlab等工具，做自动化集成，部署等等。gitlab作为仓库，Jenkins作为发布平台。直接做那种自动push代码，自动发布功能。</li>
</ul>

<h3 id="前端提效">前端提效</h3>

<ul>
<li>自动化部署平台</li>
<li>高效脚手架工具研发</li>
<li>组件库建设</li>
<li>自动化测试工具研发</li>
</ul>

<h3 id="webpack构建速度优化有哪些方式">webpack构建速度优化有哪些方式</h3>

<ul>
<li>分析打包速度和体积，合理进行优化

<ol>
<li>使用SMP(speed-measure-webpack-plugin) 速度分析</li>
<li>webpack-bundle-analyzer 体积分析</li>
</ol></li>

<li><p>打包速度：</p>

<ul>
<li>多进程，多实例构建</li>
<li>thread-loader(将模块以及依赖分配给worker线程中)</li>
<li>happypack(不建议对loader使用)</li>
<li>parallel-webpack(可并行运行多个Webpack构建)</li>
<li>缩小打包作用域</li>
<li>exclude/include (确定 loader 规则范围，babel-loader不去解析node_modules)</li>
<li>resolve.modules 指明第三方模块的绝对路径 (减少不必要的查找)</li>
<li>resolve.extensions 尽可能减少后缀尝试的可能性</li>
<li>noParse 忽略不需要解析的库 Jquery, loadsh</li>
<li>利用缓存提升速率</li>
<li>babel-loader开启缓存</li>
<li>使用cache-loader等</li>
<li>开启DLL</li>
<li>分包。使用DllPlugin进行分包，能把第三方库代码分离开，每次文件更改的时候，它只会打包该项目自身的代码。合理使用manifest.json文件</li>
<li>减少对不频繁更新的库的编译。使用 DllPlugin 将不频繁更新的库进行编译以后，当这些依赖的版本没有变化时，就不需要重新编译</li>
</ul></li>

<li><p>打包体积优化</p>

<ul>
<li>压缩代码</li>
<li>Gzip压缩</li>
<li>压缩</li>
<li>webpack-parallel-uglify-plugin</li>
<li>uglify-webpack-plugin</li>
<li>terser-webpack-plugin</li>
<li>图片压缩</li>
<li>image-webpack-loader</li>
<li>Tree shaking 抖动树，尽可能的避免打入无用代码，可在package中配置告诉webpack安全的删除未用到的export</li>
<li>实际情况中，虽然依赖了某个模块，但其实只使用其中的某些功能。通过 tree-shaking，将没有使用的模块摇掉，这样来达到删除无用代码的目的。</li>
<li>提取公共资源</li>
<li>CommonsChunkPlugin  字段name和minChunks</li>
</ul></li>
</ul>

<h3 id="性能优化方案">性能优化方案</h3>

<h5 id="合理设置api-减少请求数">合理设置api，减少请求数</h5>

<h5 id="使用http2-0">使用http2.0</h5>

<ul>
<li><p><strong>新的二进制格式</strong>（Binary Format），HTTP1.x的解析是基于文本。
基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</p></li>

<li><p><strong>多路复用</strong>（MultiPlexing）
即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</p></li>

<li><p><strong>header压缩</strong>
如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</p></li>

<li><p><strong>服务端推送</strong>（server push）
同SPDY一样，HTTP2.0也具有server push功能。</p></li>
</ul>

<h5 id="服务端渲染和静态化">服务端渲染和静态化</h5>

<ul>
<li>如果对于首屏要求较高并要求seo则服务端渲染为做好的选择，由服务端返回html客户端直接渲染。</li>
<li>静态化类似其实是一种特定的服务端渲染，比如我们一些静态的文章页不太变化的可以直接由服务端渲染完成，甚至读取一部分服务端缓存来完成。</li>
</ul>

<h5 id="静态资源一定上cdn">静态资源一定上cdn</h5>

<h5 id="css放在head中-js放在body最后">css放在head中，js放在body最后</h5>

<p>css和js其实都会阻塞渲染，但是如果css放在底部会存在首屏样式错乱的问题，js如果必须放到头部，最好加上defer标签，异步下载，延迟执行。</p>

<h5 id="用字体图标代替图片图标">用字体图标代替图片图标</h5>

<p>我们开发中也会遇到这样的问题，如果使用图片可能回存在闪屏的问题，字体图标则不会，而且我们可以对字体文件进行压缩。</p>

<h5 id="灵活使用缓存技术">灵活使用缓存技术</h5>

<ol>
<li>http缓存根据情况来选择强制缓存或者协商缓存</li>
<li>对一些实时性不高的数据可做本地缓存</li>
</ol>

<h5 id="压缩文件">压缩文件</h5>

<h5 id="图片懒加载">图片懒加载</h5>

<p>当图片即将展示在视口内时再加载图片，统一图片默认图；尽量使用webp图片；利用css3代替图片效果，压缩图片，降低质量，其实web对于图片质量的要求并不高，尤其是pc端，但是移动端慎重。</p>

<h5 id="路由懒加载">路由懒加载</h5>

<p>原理是利用webapck将单文件组件的页面全部打包为单一的js文件，然后在appjs中维护路由模块关系，比如路由切换到/about时，加载about页面对应的js 文件，完成渲染，避免首次就要加载所有js文件。</p>

<h5 id="慎重选择第三方库">慎重选择第三方库</h5>

<ul>
<li>比如同样是处理时间的需求，如果dayjs能满足的需求为什么要用momentjs呢？同样的功能会增加很多代码量。</li>
<li>利用webpack提取第三方代码，设置webpack4的 splitChunk 插件 cacheGroups 选项</li>
</ul>

<h5 id="减少重排重绘">减少重排重绘</h5>

<blockquote>
<p>重排是当元素大小位置改变时产生</p>

<p>重绘是当元素字体大小、颜色等改变产生的</p>
</blockquote>

<p><strong>重绘不一定重排，重排一定会重绘</strong></p>

<ol>
<li>用 JavaScript 修改样式时，最好不要直接写样式，而是替换 class 来改变样式。</li>
<li>如果要对 DOM 元素执行一系列操作，可以将 DOM 元素脱离文档流，修改完成后，再将它带回文档。推荐使用隐藏元素（display:none）或文档碎片（<strong>DocumentFragement</strong>），都能很好的实现这个方案。</li>
</ol>

<h5 id="保证最少60fps的刷新率">保证最少60fps的刷新率</h5>

<h5 id="使用requestanimationframe代替定时器完成动画">使用requestAnimationFrame代替定时器完成动画</h5>

<p>定时器是按照时间来完成，但是requestAnimationFrame是根据帧来完成动画的，也就是保证了刷新率，不会存在卡顿的情况。</p>

<h5 id="使用webworker来完成复杂计算">使用webWorker来完成复杂计算</h5>

<p>虽然worker中不能处理dom，但是可以将计算结果返回给我们，然后完成渲染。</p>

<hr />

<h3 id="js的垃圾回收机制">js的垃圾回收机制</h3>

<ul>
<li>引用计数垃圾收集
概念：语言引擎有一张&rdquo;引用表&rdquo;，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放；
缺点：该算法有一个限制——循环引用。</li>
<li>标记-清除垃圾回收算法

<ol>
<li>垃圾收集器找到所有的根，并“标记”（记住）它们。</li>
<li>然后它遍历并“标记”来自它们的所有引用。</li>
<li>然后它遍历标记的对象并标记 它们的 引用。所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象。</li>
<li>……如此操作，直到所有可达的（从根部）引用都被访问到。</li>
<li>没有被标记的对象都会被删除。</li>
<li>2012年起，所有现代浏览器都是用了该算法
****</li>
</ol></li>
</ul>

<h3 id="模块化">模块化</h3>

<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">CommonJS</th>
<th align="center">AMD</th>
<th align="center">CMD</th>
<th align="center">ES6</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">API</td>
<td align="center">module.exports+require</td>
<td align="center">define+require</td>
<td align="center">define+require</td>
<td align="center">export+import</td>
</tr>

<tr>
<td align="center">执行环境</td>
<td align="center">服务端</td>
<td align="center">客户端</td>
<td align="center">客户端</td>
<td align="center">服务端+客户端</td>
</tr>

<tr>
<td align="center">执行方式</td>
<td align="center">运行时加载</td>
<td align="center">运行时加载</td>
<td align="center">运行时加载</td>
<td align="center">编译时加载</td>
</tr>

<tr>
<td align="center">同步/异步</td>
<td align="center">同步</td>
<td align="center">异步</td>
<td align="center">需要时加载</td>
<td align="center"></td>
</tr>
</tbody>
</table>

<h3 id="es6模块和commonjs模块的区别">ES6模块和CommonJs模块的区别</h3>

<ul>
<li>commonJs是运行时加载，es6是编译时加载</li>
<li>commonJs输出的是值的浅拷贝，es6输出的是值的引用</li>
<li>commentJs具有缓存。在第一次被加载时，会完整运行整个文件并输出一个对象，拷贝（浅拷贝）在内存中。下次加载文件时，直接从内存中取值</li>
<li>循环引用

<ol>
<li>CommonJS的做法是，一旦出现某个模块被&rdquo;循环加载&rdquo;，就只输出已经执行的部分，还未执行的部分不会输出。</li>
<li>ES6根本不会关心是否发生了&rdquo;循环加载&rdquo;，只是生成一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。</li>
</ol></li>
<li>Node的默认模块格式是CommonJS，要通过Babel这样的转码器，在Node里面使用ES6模块</li>
<li>参考链接
<a href="https://juejin.im/post/5ae04fba6fb9a07acb3c8ac5">传送门-掘金-CommonJs 和 ESModule 的 区别整理</a>
<a href="http://www.ruanyifeng.com/blog/2015/11/circular-dependency.html">传送门-JavaScript 模块的循环加载</a>
****</li>
</ul>

<h3 id="var-let-const-区别">var/let/const 区别</h3>

<table>
<thead>
<tr>
<th align="center">声明方式</th>
<th align="center">变量提升</th>
<th align="center">重复声明</th>
<th align="center">暂时性死区</th>
<th align="center">初始值</th>
<th align="center">作用域</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">var</td>
<td align="center">允许</td>
<td align="center">允许</td>
<td align="center">不存在</td>
<td align="center">不需要</td>
<td align="center">除块级</td>
</tr>

<tr>
<td align="center">let</td>
<td align="center">不允许</td>
<td align="center">不允许</td>
<td align="center">存在</td>
<td align="center">需要</td>
<td align="center">块级</td>
</tr>

<tr>
<td align="center">const</td>
<td align="center">不允许</td>
<td align="center">不允许</td>
<td align="center">存在</td>
<td align="center">需要</td>
<td align="center">块级</td>
</tr>
</tbody>
</table>

<p>const实际上保证的，并<strong>不是变量的值不得改动</strong>，而是<strong>变量指向的那个内存地址所保存的数据不得改动</strong>。</p>

<hr />

<h3 id="箭头函数和普通函数的区别">箭头函数和普通函数的区别</h3>

<ul>
<li>箭头函数声明时绑定this</li>
<li>普通函数执行时绑定this</li>
<li>箭头函数不能用于<strong>构造函数</strong>，不能使用<strong>new</strong>，不能<strong>call,apply,bind</strong>，不能当作<strong>generator函数</strong>，不能使用<strong>yield</strong>，没有<strong>arguments</strong>，没有<strong>prototype</strong>。
****</li>
</ul>

<h3 id="for-in-for-of-for-遍历对象">for in/for of/for 遍历对象</h3>

<blockquote>
<p>for&hellip;in语句以任意顺序遍历一个对象自有的、继承的、可枚举的、非Symbol的属性。对于每个不同的属性，语句都会被执行。</p>

<p>for&hellip;of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句</p>
</blockquote>

<ul>
<li><p>for in</p>

<ol>
<li>可以遍历数组和对象。可以获取key和value。</li>
<li>适用于普通对象，并且做了对应的优化。但是不适用于数组，因此速度要慢 10-100 倍。（适用，适合的意思，而不是不能使用的意思。）</li>
<li>循环会遍历 所有属性，不仅仅是这些数字属性。</li>
</ol></li>

<li><p>for of</p>

<ol>
<li>可以遍历数组，<strong>不可遍历对象</strong>。只能获取value</li>
<li>性能更好</li>
<li>遍历具有迭代器属性的对象。因此如果某个对象有迭代器属性，也是可以遍历的。</li>
</ol></li>

<li><p>for循环就是遍历数组的方法。</p>

<hr />

<h3 id="event-loop">Event Loop</h3>

<p>Event Loop分为<strong>浏览器中的Event Loop</strong>和<strong>Node中的Event Loop</strong></p></li>
</ul>

<p><a href="https://caychance.github.io/posts/js-event-loop/">传送门-JS Event Loop</a></p>

<h3 id="浏览器中的event-loop">浏览器中的Event Loop</h3>

<blockquote>
<p>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</p>

<p>（2）主线程之外，还存在一个&rdquo;任务队列&rdquo;（task queue）。只要异步任务有了运行结果，就在&rdquo;任务队列&rdquo;之中放置一个事件。</p>

<p>（3）一旦&rdquo;执行栈&rdquo;中的所有同步任务执行完毕，系统就会读取&rdquo;任务队列&rdquo;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</p>

<p>（4）主线程不断重复上面的第三步。</p>
</blockquote>

<h3 id="node中的event-loop">Node中的Event Loop</h3>

<blockquote>
<p>（1）V8引擎解析JavaScript脚本。</p>

<p>（2）解析后的代码，调用Node API。</p>

<p>（3）libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），任务的执行结果会以异步的方式返回给V8引擎。</p>

<p>（4）V8引擎再将结果返回给用户。</p>
</blockquote>

<h3 id="宏任务和微任务的执行顺序">宏任务和微任务的执行顺序</h3>

<blockquote>
<p>（1）先执行宏任务，执行完后，查看是否有微任务队列</p>

<p>（2）如果有微任务队列，则执行微任务</p>

<p>（3）如果没有，则读取宏任务中排在最前列的任务</p>

<p>（4）执行宏任务的过程中遇到微任务，则加入微任务队列</p>

<p>（5）执行完宏任务后，查看是否有微任务队列</p>
</blockquote>

<h3 id="常见的宏任务和微任务">常见的宏任务和微任务</h3>

<ul>
<li>宏任务</li>
</ul>

<p>script、setTimeout、setInterval、setImmediate、requestAnimationFrame、I/O、UI Rendering</p>

<ul>
<li>微任务</li>
</ul>

<p>new Promise().then(回调)、Process.nextTick、MutationObserver</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="kr">async</span> <span class="kd">function</span> <span class="nx">async1</span><span class="p">(){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="kr">await</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="p">},</span><span class="mi">0</span><span class="p">)</span>
<span class="nx">async1</span><span class="p">();</span>
<span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
  <span class="nx">resolve</span><span class="p">();</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
<span class="c1">// 1 2 3 6 9 8 4 7 5
</span></code></pre></div>
<h3 id="node的执行顺序">Node的执行顺序</h3>

<p>数据输入 =&gt; poll轮询 =&gt; check检查 =&gt; close callbacks关闭事件回调 =&gt; timers定时器 =&gt; I/O callbacks I/O事件回调 =&gt; idle prepare 闲置 =&gt; 轮询</p>

<h2 id="vue部分">Vue部分</h2>

<h3 id="vue提倡的是单向数据流-但是v-model是双向数据流-为什么">Vue提倡的是单向数据流，但是v-model是双向数据流，为什么?</h3>

<ul>
<li>v-model只是一个语法糖，本质还是单向数据流</li>
<li>v-bind:value和v-on:input</li>
</ul>

<h3 id="vue双向绑定实现原理-数据响应系统原理">Vue双向绑定实现原理/数据响应系统原理</h3>

<p><a href="https://caychance.github.io/posts/vue%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0/">vue原理。</a></p>

<ul>
<li><p>响应式对象，核心就是利用 Object.defineProperty 给数据添加了 getter 和 setter，目的就是为了在我们访问数据以及写数据的时候能自动执行一些逻辑：getter 做的事情是依赖收集，setter 做的事情是派发更新</p></li>

<li><p>收集依赖的目的是为了当这些响应式数据发生变化，触发它们的 setter 的时候，能知道应该通知哪些订阅者去做相应的逻辑处理</p></li>

<li><p>当数据发生变化的时候，触发 setter 逻辑，把在依赖过程中订阅的的所有观察者，也就是 watcher，都触发它们的 update 过程</p></li>

<li><p>当 render function 被渲染的时候，因为会读取所需对象的值，所以会触发 getter 函数进行「依赖收集」，「依赖收集」的目的是将观察者 Watcher 对象存放到当前闭包中的订阅者 Dep 的 subs 中。</p></li>

<li><p>在修改对象的值的时候，会触发对应的 setter， setter 通知之前「依赖收集」得到的 Dep 中的每一个 Watcher，告诉它们自己的值改变了，需要重新渲染视图。这时候这些 Watcher 就会开始调用 update 来更新视图。</p></li>
</ul>

<p><img src="https://blog-pics.pek3b.qingstor.com/006tNc79ly1g2v2c39ruvj311e0rudpq.jpg" alt="" /></p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">//响应式
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">defineReactive</span> <span class="p">(</span><span class="nx">obj</span><span class="p">,</span><span class="nx">key</span><span class="p">,</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">dep</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Dep</span><span class="p">();</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">get</span><span class="p">(){</span>
      <span class="c1">// 依赖收集
</span><span class="c1"></span>      <span class="nx">dep</span><span class="p">.</span><span class="nx">depend</span><span class="p">();</span>
      <span class="k">return</span> <span class="nx">val</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="nx">set</span><span class="p">(</span><span class="nx">newVal</span><span class="p">){</span>
      <span class="nx">val</span> <span class="o">=</span> <span class="nx">newVal</span><span class="p">;</span>
      <span class="c1">// 派发更新；数据变化通知所有订阅者
</span><span class="c1"></span>      <span class="nx">dep</span><span class="p">.</span><span class="nx">notify</span><span class="p">()</span>
    <span class="p">}</span>
  <span class="p">})</span>
<span class="p">}</span>
<span class="c1">// Dep是整个getter依赖收集的核心
</span><span class="c1"></span><span class="k">class</span> <span class="nx">Dep</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">(){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">subs</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="p">},</span>
  <span class="c1">//增加订阅者
</span><span class="c1"></span>  <span class="nx">addSub</span><span class="p">(</span><span class="nx">sub</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">subs</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">sub</span><span class="p">);</span>
  <span class="p">},</span>
  <span class="c1">//判断是否增加订阅者
</span><span class="c1"></span>  <span class="nx">depend</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">Dep</span><span class="p">.</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">addSub</span><span class="p">(</span><span class="nx">Dep</span><span class="p">.</span><span class="nx">target</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">},</span>

  <span class="c1">//通知订阅者更新
</span><span class="c1"></span>  <span class="nx">notify</span><span class="p">(){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">subs</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">sub</span><span class="p">)</span> <span class="p">=&gt;{</span>
      <span class="nx">sub</span><span class="p">.</span><span class="nx">update</span><span class="p">()</span>
    <span class="p">})</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="nx">Dep</span><span class="p">.</span><span class="nx">target</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</code></pre></div>
<h3 id="vue中-数组的操作是如何实现数据响应的-push等原型函数以及为什么用-set">Vue中，数组的操作是如何实现数据响应的(push等原型函数以及为什么用$set)</h3>

<ul>
<li>Object.defineProperty无法监测到数组API的改动，因此Vue底层针对数组常用的7个方法做了重写</li>
</ul>

<h3 id="vue-router">Vue Router</h3>

<ul>
<li>主要有两种模式 <strong>hash模式</strong> <strong>history模式</strong></li>
<li><strong>本质</strong>就是监听url的变化，然后匹配路由规则，显示相应的页面，并且无需刷新</li>
<li>hash模式    点击跳转通过hashchange事件来监听到url的变化    手动刷新通过load事件</li>
<li>history模式     点击跳转通过pushState 浏览器动作 回退等 popState      刷新或者输入url 会向服务器发送请求 <strong>需要后端配合重定向</strong></li>
</ul>

<h3 id="vuex数据周期-如何使用-有什么好处">Vuex数据周期 如何使用 有什么好处</h3>

<p>state &ndash; dispatch &ndash;&gt; actions &ndash; commit &ndash;&gt; mutations</p>

<h3 id="vue-nexttick的原理-如何找到dom-依赖收集过程">vue.nextTick的原理 如何找到dom 依赖收集过程</h3>

<ul>
<li>nextTick是Vue的一个全局函数，用于处理dom更新操作。Vue里面有一个watcher，用于观察数据的变化，然后更新dom。Vue里面并不是每次数据变化都会触发更新dom，而是将这些操作都缓存在一个队列，在一个事件循环结束之后，刷新队列，统一执行dom操作。</li>
<li>watch的实现，当某个响应式数据发生变化的时候，它的setter函数会通知闭包中的Dep，Dep则会调用它管理的所有Watch对象。触发Watch对象的update实现。<strong>Watch对象并不是立即更新视图，而是被push进了一个队列queue，此时状态处于waiting的状态，这时候继续会有Watch对象被push进这个队列queue，等待下一个tick时，这些Watch对象才会被遍历取出，更新视图。</strong>同时，id重复的Watcher不会被多次加入到queue中去，因为在最终渲染时，我们只需要关心数据的最终结果。</li>
<li>Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。</li>
<li>Vue是异步执行dom更新的</li>
<li>Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。</li>
<li>源码中

<ul>
<li>2.5版本使用宏任务和微任务组合</li>
<li>源码中依次判断的逻辑：先看是否可以使用Promise，MutationObserver，setImmediate，setTimeout</li>
</ul></li>
</ul>

<h3 id="virtual-dom-diff算法具体实现过程">virtual-dom diff算法具体实现过程</h3>

<ul>
<li>diff算法源于snabbdom，复杂度为O(n)</li>
<li>只会在同层级比较，不会跨层级比较</li>
<li>重点是patch方法</li>
</ul>

<h3 id="patch方法详解">patch方法详解</h3>

<p>注释：vnode：新的虚拟节点 oldVnode：旧的虚拟节点</p>

<blockquote>
<ul>
<li>vnode不存在但是oldVnode存在，需要销毁oldVnode</li>
<li>oldVnode不存在但是vnode存在，创建新节点</li>
<li>oldVnode和vnode都存在

<ul>
<li>oldVnode和vnode是同一个节点 执行patchVnode方法</li>
<li>vnode创建真实dom并替换oldVnode.elm</li>
</ul></li>
</ul>
</blockquote>

<h3 id="patchvnode方法详解">patchVnode方法详解</h3>

<blockquote>
<ul>
<li>oldVnode和vnode完全一致，则不需要做任何事情</li>
<li>oldVnode和vnode都是静态节点，且具有相同的key，当vnode是克隆节点或是v-once指令控制的节点时，只需要把oldVnode.elm和oldVnode.child都复制到vnode上即可</li>
<li>vnode不是文本节点或注释节点

<ul>
<li>如果oldVnode和vnode都有子节点，且2方的子节点不完全一致，就执行updateChildren方法</li>
<li>只有oldVnode有子节点，那就把这些节点都删除</li>
<li>如果只有vnode有子节点，那就创建这些子节点</li>
<li>如果oldVnode和vnode都没有子节点，但是oldVnode是文本节点或注释节点，就把vnode.elm的文本设置为空字符串</li>
</ul></li>
<li>vnode是文本节点或注释节点，但是vnode.text != oldVnode.text时，只需要更新vnode.elm的文本内容就可以</li>
</ul>
</blockquote>

<h3 id="updatechildren方法详解">updateChildren方法详解</h3>

<blockquote>
<ul>
<li>oldStartIdx&gt;oldEndIdx
oldCh已经遍历完了，但是newCh还没有，把newStartIdx-newEndIdx之间的vnode都是新增的，把这些vnode添加到oldCh末尾</li>
<li>newStartIdx&gt;newEndIdx
newCh已经遍历完了，但是oldCh还没有，把oldCh中oldStartIdx-oldEndIdx之间的vnode删除</li>
<li>oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx

<ul>
<li>oldVnode第一个child不存在，oldStart索引右移</li>
<li>oldVnode最后一个child不存在，oldEnd索引左移</li>
<li>oldStartVnode和newStartVnode是同一个节点，patchVnode两个节点，索引右移</li>
<li>oldEndVnode和newEndVnode是同一个节点，patchVnode两个节点，索引左移</li>
<li>oldStartVnode和newEndVnode是同一个节点，移动oldStartVnode到oldEndVnode节点后面</li>
<li>oldEndVnode和newStartVnode是同一个节点，移动oldEndVnode到oldStartVnode前面</li>
<li>oldChildren中寻找跟newStartVnode具有相同key的节点，如果找不到相同key的节点，说明newStartVnode是一个新节点，就创建一个，然后把newStartVnode设置为下一个节点</li>
<li>如果找到了相同key的节点，比较两个节点是否属于同一个节点，如果属于同一节点，就patchVnode，否则新创建节点</li>
</ul></li>
</ul>
</blockquote>

<h3 id="为什么要使用key">为什么要使用key？</h3>

<p>不设key，newCh和oldCh只会进行头尾两端的相互比较，设key后，除了头尾两端的比较外，还会从用key生成的对象oldKeyToIdx中查找匹配的节点，所以为节点设置key可以更高效的利用dom。</p>

<h3 id="vue3-0相比较vue2-x有哪些改动">Vue3.0相比较Vue2.x有哪些改动</h3>

<ul>
<li>响应式从Object.defineProperty改为Proxy（为什么，可作适当解释）</li>
</ul>

<h2 id="wepack以及项目优化">Wepack以及项目优化</h2>

<h3 id="webpack原理和手写实现">webpack原理和手写实现</h3>

<p>主要分为以下三步：
1. 转换代码，生成依赖
  - 这部分比较简单就是babel转ast然后babel遍历ast保存所有依赖，然后生成对应的文件。
2. 生成依赖图谱
  - 依赖图谱就是一个json文件标明了单前文件依赖了哪些文件，code是啥类似下面数据：</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json">  <span class="p">{</span>
    <span class="err">&#39;./index.js&#39;:</span> <span class="err">{</span>
      <span class="err">dependencies:</span> <span class="err">{</span> <span class="err">&#39;./message.js&#39;:</span> <span class="err">&#39;./message.js&#39;</span> <span class="p">}</span><span class="err">,</span>
      <span class="err">code:</span> <span class="err">&#39;</span><span class="s2">&#34;use strict&#34;</span><span class="err">;\n\nvar</span> <span class="err">_message</span> <span class="err">=</span> <span class="err">_interopRequireDefault(require(</span><span class="s2">&#34;./message.js&#34;</span><span class="err">));\n\nfunction</span> <span class="err">_interopRequireDefault(obj)</span> <span class="p">{</span> <span class="err">return</span> <span class="err">obj</span> <span class="err">&amp;&amp;</span> <span class="err">obj.__esModule</span> <span class="err">?</span> <span class="err">obj</span> <span class="err">:</span> <span class="err">{</span> <span class="nt">&#34;default&#34;</span><span class="p">:</span> <span class="err">obj</span> <span class="p">}</span><span class="err">;</span> <span class="err">}\n\n//</span> <span class="err">index.js\nconsole.log(_message</span><span class="p">[</span><span class="s2">&#34;default&#34;</span><span class="p">]</span><span class="err">);&#39;</span>
    <span class="err">},</span>
    <span class="err">&#39;./message.js&#39;:</span> <span class="p">{</span>
      <span class="err">dependencies:</span> <span class="err">{</span> <span class="err">&#39;./word.js&#39;:</span> <span class="err">&#39;./word.js&#39;</span> <span class="p">}</span><span class="err">,</span>
      <span class="err">code:</span>
        <span class="err">&#39;</span><span class="s2">&#34;use strict&#34;</span><span class="err">;\n\nObject.defineProperty(exports,</span> <span class="s2">&#34;__esModule&#34;</span><span class="err">,</span> <span class="p">{</span><span class="err">\n</span>  <span class="err">value:</span> <span class="err">true\n</span><span class="p">}</span><span class="err">);\nexports</span><span class="p">[</span><span class="s2">&#34;default&#34;</span><span class="p">]</span> <span class="err">=</span> <span class="err">void</span> <span class="mi">0</span><span class="err">;\n\nvar</span> <span class="err">_word</span> <span class="err">=</span> <span class="err">require(</span><span class="s2">&#34;./word.js&#34;</span><span class="err">);\n\n//</span> <span class="err">message.js\nvar</span> <span class="err">message</span> <span class="err">=</span> <span class="s2">&#34;say &#34;</span><span class="err">.concat(_word.word);\nvar</span> <span class="err">_default</span> <span class="err">=</span> <span class="err">message;\nexports</span><span class="p">[</span><span class="s2">&#34;default&#34;</span><span class="p">]</span> <span class="err">=</span> <span class="err">_default;&#39;</span>
    <span class="err">},</span>
    <span class="err">&#39;./word.js&#39;:</span> <span class="p">{</span>
      <span class="err">dependencies:</span> <span class="err">{</span><span class="p">}</span><span class="err">,</span>
      <span class="err">code:</span>
        <span class="err">&#39;</span><span class="s2">&#34;use strict&#34;</span><span class="err">;\n\nObject.defineProperty(exports,</span> <span class="s2">&#34;__esModule&#34;</span><span class="err">,</span> <span class="p">{</span><span class="err">\n</span>  <span class="err">value:</span> <span class="err">true\n</span><span class="p">}</span><span class="err">);\nexports.word</span> <span class="err">=</span> <span class="err">void</span> <span class="mi">0</span><span class="err">;\n//</span> <span class="err">word.js\nvar</span> <span class="err">word</span> <span class="err">=</span> <span class="s2">&#34;hello&#34;</span><span class="err">;\nexports.word</span> <span class="err">=</span> <span class="err">word;&#39;</span> 
      <span class="err">}</span>
    <span class="err">}</span></code></pre></div>
<ol>
<li>生成代码字符串

<ul>
<li>根据上一步生成的依赖图谱将所有代码串联起来生成代码字符串然后输出文件</li>
</ul></li>
</ol>

<h3 id="loader和plugin的区别">loader和plugin的区别</h3>

<ul>
<li>loader
loaders是在打包构建过程中用来处理源文件的(JSX,Scss,Less)，一次处理一个；</li>
<li>plugin
plugins并不直接操作单个文件，它直接对整个构建过程起作用。</li>
</ul>

<h2 id="浏览器及安全">浏览器及安全</h2>

<h3 id="阻止冒泡">阻止冒泡</h3>

<ul>
<li>stopPropagation<br /></li>
<li>cancelBubble</li>
</ul>

<h3 id="事件委托">事件委托</h3>

<ul>
<li>解释概念，使用场景，原理（利用了事件冒泡）</li>
</ul>

<h3 id="常见的浏览器安全问题">常见的浏览器安全问题</h3>

<ul>
<li>XSS 跨站脚本攻击</li>
</ul>

<blockquote>
<p>XSS 的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。</p>
</blockquote>

<ul>
<li>CSRF 跨站请求伪造攻击</li>
</ul>

<blockquote>
<p>1.浏览器登录信任网站A</p>

<p>2.通过验证，在浏览器中产生cookie</p>

<p>3.用户在没有登出A的情况下，访问危险网站B</p>

<p>4.B要求访问A网站，并发一个请求</p>

<p>5.根据B的要求，浏览器待着cookie访问A</p>
</blockquote>

<ul>
<li>SQL注入</li>
<li>命令行注入</li>
<li>DDos攻击</li>
</ul>

<blockquote>
<p>原理就是利用大量的请求造成资源过载，导致服务不可用</p>
</blockquote>

<ul>
<li>流量劫持

<ul>
<li>DNS劫持
<br /></li>
</ul></li>
</ul>

<blockquote>
<p>&ldquo;你打了一辆车想去商场吃饭，结果你打的车是小作坊派来的，直接给你拉到小作坊去了&rdquo;</p>
</blockquote>

<ul>
<li>HTTP劫持
<br /></li>
</ul>

<blockquote>
<p>&ldquo;你打了一辆车想去商场吃饭，结果司机跟你一路给你递小作坊的广告&rdquo;</p>
</blockquote>

<h3 id="chrome跨标签通信">chrome跨标签通信</h3>

<ul>
<li>获取句柄 postMessage</li>
<li>localStorage</li>
<li>cookie</li>
<li>SharedWorker</li>
</ul>

<h3 id="跨域">跨域</h3>

<ul>
<li>jsonp</li>
<li>CORS</li>
<li>WebSocket</li>
<li>Nginx代理</li>
<li>Node中间件代理 <code>http-proxy-middleware</code> <code>proxy-middleware</code></li>
</ul>

<h3 id="输入网址回车之后浏览器做了什么">输入网址回车之后浏览器做了什么</h3>

<p>以chrome为例：</p>

<ul>
<li>输入地址
会从历史记录，书签等地方智能提示补全url。查找缓存。</li>
<li>NDS解析</li>
<li>TCP请求</li>
<li>浏览器向服务器发送一个 HTTP 请求</li>
<li>服务器的永久重定向相应(如果有的话)</li>
<li>浏览器跟踪重定向地址</li>
<li>服务器处理请求</li>
<li>服务器返回一个 HTTP 响应</li>
<li>浏览器显示HTML</li>
<li>浏览器发送请求获取嵌入在 HTML 中的资源(图片，CSS，JS，音频，视频)</li>
</ul>

<p><a href="https://xianyulaodi.github.io/2017/03/22/%E8%80%81%E7%94%9F%E5%B8%B8%E8%B0%88-%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/">传送门-老生常谈-从输入url到页面展示到底发生了什么</a></p>

<h3 id="浏览器缓存机制">浏览器缓存机制</h3>

<ol>
<li>先判断是否命中强缓存。如果命中，则不请求服务器，直接从缓存中返回数据；</li>
<li>如果未命中，则向服务器发送一个请求，再判断是否命中协商缓存。发送的请求包含etag等协商缓存的信息，由服务器判断是否命中，返回内容（未命中）或者304（命中）。

<ul>
<li>如果命中，更新缓存，然后缓存中返回数据；</li>
<li>如果未命中，则更新缓存标识，服务器返回数据。
强缓存字段：Expires和Cache-Control
协商缓存字段：Last-Modified/If-Modified-Since和Etag/If-None-Match。后者优先级更高</li>
</ul></li>
</ol>

<h2 id="网络相关">网络相关</h2>

<h3 id="http状态码">Http状态码</h3>

<ul>
<li>1**   信息类</li>
<li>2**   成功</li>
<li>3**   重定向类    301永久重定向 302临时重定向</li>
<li>4**   客户端出错</li>
<li>5**   服务器出错</li>
<li>200成功/204无内容</li>
<li>301永久重定向/302临时重定向/304未修改</li>
<li>401未授权/403禁止访问/404未找到/405请求方式不对</li>
<li>500服务器内部错误/502错误网关/503服务不可用/504服务器超时</li>
</ul>

<h3 id="http-header中都有哪些信息">Http header中都有哪些信息</h3>

<p><code>Accept</code>，<code>Connection</code>，<code>Content-Type</code>，<code>Expires</code>，<code>Server</code>，<code>Etag</code>，<code>Last-Modified</code>，<code>Server</code>，<code>Date</code>，<code>Cache-Control</code>，<code>User-Agent</code>等。</p>

<h3 id="http和https的区别">Http和Https的区别</h3>

<p>Http主要有三点不足。</p>

<ul>
<li>通信使用明文，未加密。导致内容可能会被窃听。</li>
<li>不验证通讯方的身份。有可能遭遇伪装。</li>
<li>无法证明报文的完整性。有可能已遭篡改。</li>
</ul>

<p>Https的出现也是为了解决上述问题。因此：
Http+加密+认证+完整新保护 = Https。
Https是身披SSL外壳的Http。SSL协议在Http和Tcp协议之间。</p>

<h3 id="tcp三次握手过程">TCP三次握手过程</h3>

<p><img src="https://blog-pics.pek3b.qingstor.com/006tNc79ly1g2w0tmm5q9j30rs0a8gpa.jpg" alt="" /></p>

<ul>
<li>第一次握手。client发送一个<strong>SYN(J)</strong>包给server，等待server的ACK回复，进入<code>SYN-SENT</code>状态。</li>
<li>第二次握手。server接收到SYN(seq=J)包后就返回一个<strong>ACK(J+1)</strong>包以及一个自己的<strong>SYN(K)</strong>包，然后等待client的ACK回复，server进入<code>SYN-RECIVED</code>状态。</li>
<li>第三次握手。client接收到server发回的ACK(J+1)包后，进入<code>ESTABLISHED</code>状态。然后根据server发来的SYN(K)包，返回给等待中的server一个<strong>ACK(K+1)</strong>包。等待中的server收到ACK回复，也把自己的状态设置为<code>ESTABLISHED</code>。</li>
</ul>

<h3 id="tcp四次挥手">TCP四次挥手</h3>

<p><img src="https://blog-pics.pek3b.qingstor.com/006tNc79ly1g2w0vh8dq6j30rs0cwq6e.jpg" alt="" /></p>

<ul>
<li>第一次挥手。client发送一个<strong>FIN(M)</strong>包，此时client进入<code>FIN-WAIT-1</code>状态，这表明client已经没有数据要发送了。</li>
<li>第二次挥手。server收到了client发来的FIN(M)包后，向client发回一个<strong>ACK(M+1)</strong>包，此时server进入<code>CLOSE-WAIT</code>状态，client进入<code>FIN-WAIT-2</code>状态。</li>
<li>第三次挥手。server向client发送<strong>FIN(N)</strong>包，请求关闭连接，同时server进入<code>LAST-ACK</code>状态。</li>
<li>第四次挥手。client收到server发送的FIN(N)包，进入<code>TIME-WAIT</code>状态。向server发送<strong>ACK(N+1)</strong>包，server收到client的ACK(N+1)包以后，进入<code>CLOSE</code>状态；client等待一段时间还没有得到回复后判断server已正式关闭，进入<code>CLOSE</code>状态。</li>
</ul>

<h3 id="为什么tcp建立连接是三次而关闭连接要多一次">为什么TCP建立连接是三次而关闭连接要多一次</h3>

<p>因为server的ACK和FIN是分开发送了，因此关闭多了一次。
client发送一个FIN包，表示client已经没有数据要发送了。但是此时server可能还会有未发送的数据，因此server也要发送一个FIN包。</p>

<h3 id="https认证过程">Https认证过程</h3>

<ul>
<li>浏览器发送一个连接请求给安全服务器。</li>
<li>服务器将自己的证书，以及同证书相关的信息发送给客户浏览器。</li>
<li>客户浏览器检查服务器送过来的证书是否是由自己信赖的 CA 中心所签发的。如果是，就继续执行协议；如果不是，客户浏览器就给客户一个警告消息：警告客户这个证书不是可以信赖的，询问客户是否需要继续。</li>
<li>接着客户浏览器比较证书里的消息，例如域名和公钥，与服务器刚刚发送的相关消息是否一致，如果是一致的，客户浏览器认可这个服务器的合法身份。</li>
<li>服务器要求客户发送客户自己的证书。收到后，服务器验证客户的证书，如果没有通过验证，拒绝连接；如果通过验证，服务器获得用户的公钥。</li>
<li>客户浏览器告诉服务器自己所能够支持的通讯对称密码方案。</li>
<li>服务器从客户发送过来的密码方案中，选择一种加密程度最高的密码方案，用客户的公钥加过密后通知浏览器。</li>
<li>浏览器针对这个密码方案，选择一个通话密钥，接着用服务器的公钥加过密后发送给服务器。</li>
<li>服务器接收到浏览器送过来的消息，用自己的私钥解密，获得通话密钥。</li>
<li>服务器、浏览器接下来的通讯都是用对称密码方案，对称密钥是加过密的。</li>
</ul>

<h3 id="http2相比http1多了什么">HTTP2相比HTTP1多了什么</h3>

<ul>
<li><p><strong>新的二进制格式</strong>（Binary Format），HTTP1.x的解析是基于文本。
基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</p></li>

<li><p><strong>多路复用</strong>（MultiPlexing）
即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</p></li>

<li><p><strong>header压缩</strong>
如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</p></li>

<li><p><strong>服务端推送</strong>（server push）
同SPDY一样，HTTP2.0也具有server push功能。</p></li>
</ul>

<h3 id="http2的多路复用和http-1-1的keep-alive有什么区别">HTTP2的多路复用和HTTP 1.1的keep-alive有什么区别</h3>

<ul>
<li><p>HTTP/1.0 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；</p></li>

<li><p>HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；</p></li>

<li><p>HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行。</p></li>
</ul>

<h3 id="cookie">cookie</h3>

<ul>
<li>expires   过期时间</li>
<li>domain    域名</li>
<li>path  路径</li>
<li>security  安全情况下才传输给服务器 https</li>
<li>httponly  js是否可以操作</li>
<li>如何防止js访问cookie，如何限制只能在https中才能访问cookie(set-cookie相关字段)</li>
</ul>

<h2 id="其他">其他</h2>

<h3 id="大文件上传">大文件上传</h3>

<ul>
<li>文件切片

<ul>
<li>通过Blob对象的slice方法将目标大文件切割成小片，存放在数组中</li>
</ul></li>
<li>上传切片

<ul>
<li>正常formdata上传即可，将所有切片拿出依次上传，还原的时候需要个唯一标识来区分分片的位置，可以用filename + length的形式，当然根据file做一些处理生成唯一标识也可以</li>
</ul></li>
<li>断点续传

<ul>
<li>断点续传的逻辑主要在记录已上传的切片，然后再上传前检索保存记录，如果已经上传过了则break，这样在断点续传的时候就可以完成未上传切片继续上传。</li>
</ul></li>
<li>上传进度

<ul>
<li>使用xhr对象中的progress来实现</li>
</ul></li>
</ul>

<h3 id="设计模式">设计模式</h3>

<h4 id="1-工厂与抽象工厂模式">1. 工厂与抽象工厂模式</h4>

<blockquote>
<p>工厂模式主要用于创建类或者对像，目的就是建造一个可以批量生产某些具有相同功能的类。</p>

<h5 id="1-1-简单工厂模式">1.1 简单工厂模式</h5>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">PopFactory</span> <span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="s1">&#39;alert&#39;</span><span class="o">:</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nx">MyAlert</span><span class="p">();</span>
        <span class="k">case</span> <span class="s1">&#39;confirm&#39;</span> <span class="o">:</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nx">MyConfire</span><span class="p">();</span>
        <span class="k">case</span> <span class="s1">&#39;someOther&#39;</span><span class="o">:</span> 
            <span class="k">return</span> <span class="k">new</span> <span class="nx">someOther</span><span class="p">();</span>
        <span class="k">default</span><span class="o">:</span> 
            <span class="k">return</span> <span class="p">....</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<blockquote>
<p>简单工厂模式用于集中建造各个类</p>
</blockquote>

<h5 id="1-2-用对像代替交叉较多的类">1.2 用对像代替交叉较多的类</h5>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">CreatePop</span> <span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">content</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">();</span>
    <span class="nx">obj</span><span class="p">.</span><span class="nx">content</span> <span class="o">=</span> <span class="nx">content</span><span class="p">;</span>
    <span class="nx">obj</span><span class="p">.</span><span class="nx">show</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>    <span class="c1">// some code  };
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">type</span> <span class="o">==</span> <span class="s2">&#34;alert&#34;</span><span class="p">)</span> <span class="p">{</span>
        
    <span class="p">}</span> 
    <span class="k">if</span> <span class="p">(</span><span class="nx">type</span> <span class="o">==</span> <span class="s1">&#39;confirm&#39;</span><span class="p">)</span> <span class="p">{</span>
        
    <span class="p">}</span>
    <span class="p">....</span>
    <span class="k">return</span> <span class="nx">obj</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<blockquote>
<p>这样用一个对像承接该有的方法和属性并返回会比声明一个个类强很多，但是和1.1的区别在于这是批量的产生“类似”的对像，1.1是产生类，如果这些类继承了父类的一些方法，1.2是无法继承的，所以可以根据场景按需使用。</p>
</blockquote>

<h5 id="1-3-安全工场">1.3 安全工场</h5>

<blockquote>
<p>安全工厂类似安全的构造函数，在创建对像时校验当前对像是否是是指向当前工厂的，如果是则根据已知参数创建当前对像，否则返回新的工厂。</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">Factory</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">content</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="k">instanceof</span> <span class="nx">Factory</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="k">new</span> <span class="k">this</span><span class="p">[</span><span class="nx">type</span><span class="p">](</span><span class="nx">content</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">s</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">Factory</span><span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">content</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">Factory</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1">// 枚举每个需要创建的构造函数类型
</span><span class="c1"></span>    <span class="nx">Java</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">content</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// somecode
</span><span class="c1"></span>    <span class="p">},</span>
    <span class="nx">Javascript</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">content</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// somecode
</span><span class="c1"></span>    <span class="p">},</span>
    <span class="p">..........</span>
<span class="p">}</span>
</code></pre></div>
<h5 id="1-4-抽象工厂模式">1.4 抽象工厂模式</h5>

<blockquote>
<p>工厂模式只能对某些特定的情况有作用，比如对一类事物的枚举，他们都差不多，但是假如需要让工厂适用的场景更加广泛，对类簇都起作用呢？那么就是将其核心抽象出来，不在针对某一类产品创建对像。抽象工厂是一种声明但是不能使用的类，当你使用时会报错。</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">Car</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{};</span>
<span class="nx">Car</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">getPrice</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;抽象方法不支持调用&#39;</span><span class="p">);</span>
    <span class="p">},</span>
    <span class="nx">getSpeed</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;抽象方法不支持调用&#39;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<blockquote>
<p>上边定义了一个类和两个共有方法，但是每个方法在调用时都会报错，乍一看这特么就是有病，自己给自己报错玩？当然不是。这里这个Car类主要作为基类被子类继承，子类会去重写基类的一些方法，当然这些方法如果在子类中得不到重写就会报错，那么这样写的目的就显而易见了，这些东西用于继承！</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">// 抽象工厂
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">VehicleFactory</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">subType</span><span class="p">,</span> <span class="nx">superType</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 判断抽象工厂中是否包含当前抽象类
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">VehicleFactory</span><span class="p">[</span><span class="nx">superType</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 缓存类,过度类
</span><span class="c1"></span>        <span class="kd">function</span> <span class="nx">F</span> <span class="p">()</span> <span class="p">{};</span>
        <span class="c1">// 继承父类的属性和方法
</span><span class="c1"></span>        <span class="nx">F</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">VehicleProtype</span><span class="p">[</span><span class="nx">superType</span><span class="p">]();</span>
        <span class="c1">// 子类constructor指向子类
</span><span class="c1"></span>        <span class="nx">subTyoe</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">=</span> <span class="nx">subType</span><span class="p">;</span>
        <span class="c1">// 子类原型继承父类
</span><span class="c1"></span>        <span class="nx">subType</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">F</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;抽象类不存在，请创建&#39;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 小汽车抽象类
</span><span class="c1"></span><span class="nx">VehicleFactory</span><span class="p">.</span><span class="nx">Car</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">type</span> <span class="o">=</span> <span class="s1">&#39;car&#39;</span><span class="p">;</span>
<span class="p">};</span>
<span class="nx">VehicleFactory</span><span class="p">.</span><span class="nx">Car</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">getPrice</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;抽象方法不支持调用&#39;</span><span class="p">);</span>
    <span class="p">},</span>
    <span class="nx">getSpeed</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;抽象方法不支持调用&#39;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 公交车抽象类
</span><span class="c1"></span><span class="nx">somecode</span>
<span class="c1">// 卡车抽象类
</span><span class="c1"></span><span class="nx">somecode</span>

<span class="c1">// 创架小汽车父类的子类宝马汽车类
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">BMW</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">price</span><span class="p">,</span> <span class="nx">speed</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">price</span> <span class="o">=</span> <span class="nx">price</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">speed</span> <span class="o">=</span> <span class="nx">speed</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 利用抽象工厂实现BMW对Car类的继承
</span><span class="c1"></span><span class="nx">VehicleFactory</span><span class="p">(</span><span class="s1">&#39;BMW&#39;</span><span class="p">,</span> <span class="s1">&#39;Car&#39;</span><span class="p">);</span>
<span class="c1">// 子类原型方法重写
</span><span class="c1"></span><span class="nx">BMW</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getPrice</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">price</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<blockquote>
<p>抽象工厂也是工厂，其目的也很简单，就是为了创建一类对像，通过子类重写父类的一些方法实现各自的不同需求，这里有一个独特的地方是抽象类不允许调用要搞清楚，因为抽象类不具有实际意义，它只会按照一定规则批量生产对像，但不关注对像要干什么。</p>
</blockquote>

<h4 id="2-建造者模式">2. 建造者模式</h4>

<blockquote>
<p>建造者模式注重对像创建的过程，关注点在于当前对像创建时会创建哪些属性和方法。以人为例：人会包括姓名、兴趣爱好、工作、专业技能、职位等等，这样就可以将这个人拆开来处理，分别处理这个人的姓名，爱好和工作相关，最后在将之组合为一个人。</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">// 人的构造函数
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">Human</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">param</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">skill</span> <span class="o">=</span> <span class="nx">param</span> <span class="o">&amp;&amp;</span> <span class="nx">param</span><span class="p">.</span><span class="nx">skill</span> <span class="o">||</span> <span class="s1">&#39;保密&#39;</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">hobby</span> <span class="o">=</span> <span class="nx">param</span> <span class="o">&amp;&amp;</span> <span class="nx">param</span><span class="p">.</span><span class="nx">hobby</span> <span class="o">||</span> <span class="s1">&#39;保密&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 人的原型方法
</span><span class="c1"></span><span class="nx">Human</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">getSkill</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">skill</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="nx">getHobby</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">hobby</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 实例化姓名类
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">Named</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">that</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">that</span><span class="p">.</span><span class="nx">wholeName</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">name</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">that</span><span class="p">.</span><span class="nx">FirstName</span> <span class="o">=</span> <span class="nx">name</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">name</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">));</span>
            <span class="nx">that</span><span class="p">.</span><span class="nx">secondName</span> <span class="o">=</span> <span class="nx">name</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">name</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">name</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)));</span>
        <span class="p">}</span>
    <span class="p">})(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">that</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 职位类
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">Work</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">work</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">work</span><span class="p">,</span> <span class="nx">that</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="nx">work</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="s1">&#39;code&#39;</span><span class="o">:</span>
                <span class="nx">that</span><span class="p">.</span><span class="nx">work</span> <span class="o">=</span> <span class="s1">&#39;工程师&#39;</span><span class="p">;</span>
                <span class="nx">that</span><span class="p">.</span><span class="nx">workDes</span> <span class="o">=</span> <span class="s1">&#39;每天沉醉于编程&#39;</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">default</span><span class="o">:</span>
                <span class="nx">that</span><span class="p">.</span><span class="nx">work</span> <span class="o">=</span> <span class="nx">work</span><span class="p">;</span>
                <span class="nx">that</span><span class="p">.</span><span class="nx">workDes</span> <span class="o">=</span> <span class="s1">&#39;尚不明确&#39;</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">})(</span><span class="nx">work</span><span class="p">,</span> <span class="nx">that</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 组装这个人
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">Person</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">work</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 创建应聘者缓存对像
</span><span class="c1"></span>    <span class="kd">var</span> <span class="nx">_person</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Human</span><span class="p">();</span>
    <span class="c1">// 创建应聘者姓名解析对像
</span><span class="c1"></span>    <span class="nx">_person</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Named</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
    <span class="c1">// 创建应聘者期望职位
</span><span class="c1"></span>    <span class="nx">_person</span><span class="p">.</span><span class="nx">work</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Work</span><span class="p">(</span><span class="nx">work</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">_person</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 实例化这个人
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="s1">&#39;xiao ming&#39;</span><span class="p">,</span> <span class="s1">&#39;code&#39;</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">skill</span><span class="p">);</span>      <span class="c1">// 保密
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">name</span><span class="p">.</span><span class="nx">FirstName</span><span class="p">);</span>        <span class="c1">// xiao
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">work</span><span class="p">.</span><span class="nx">work</span><span class="p">);</span>              <span class="c1">// 工程师
</span></code></pre></div>
<h4 id="3-原型模式">3. 原型模式</h4>

<blockquote>
<p>原型模式有点类似原型链继承，其主要原理也是利用原型链实现子类对基类的继承，实现共有的在基类上，各自的在各自的子类上，分工明确，减少内存消耗。</p>
</blockquote>

<p>创建焦点图实例：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="cm">/* 创建一个焦点图的类 */</span>
<span class="kd">var</span> <span class="nx">LoopImage</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">imgArr</span><span class="p">,</span> <span class="nx">container</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">imageArr</span> <span class="o">=</span> <span class="nx">imageArr</span><span class="p">;</span>               <span class="c1">// 存放图片的数组
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">container</span> <span class="o">=</span> <span class="nx">container</span><span class="p">;</span>             <span class="c1">// 焦点图容器
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">createImage</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{};</span>      <span class="c1">// 创建一张焦点图
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">changeImage</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{};</span>      <span class="c1">// 切换下一张焦点图
</span><span class="c1"></span><span class="p">}</span>

<span class="cm">/* 上下滑切换类 */</span>
<span class="kd">var</span> <span class="nx">slideLoopImg</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">imageArr</span><span class="p">,</span><span class="nx">container</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 类式继承基类的方法和属性
</span><span class="c1"></span>    <span class="nx">LoopImage</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">imageArr</span><span class="p">,</span> <span class="nx">container</span><span class="p">);</span>
    <span class="c1">// 重写基类的切换下一张的方法，实现上下滑效果
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">changeImage</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 实现焦点图滑动切换some code
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* 渐隐切换类 */</span>
<span class="kd">var</span> <span class="nx">fadeLoopImg</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">imageArr</span><span class="p">,</span> <span class="nx">container</span><span class="p">,</span> <span class="nx">arrow</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 类式继承基类的方法
</span><span class="c1"></span>    <span class="nx">LoopImage</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">imageArr</span><span class="p">,</span> <span class="nx">container</span><span class="p">);</span>
    <span class="c1">// 私有变量arrow
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">arrow</span> <span class="o">=</span> <span class="nx">arrow</span><span class="p">;</span>
    <span class="c1">// 重写基类的切换下一张方法，实现渐隐效果
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">changeImage</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 实现焦点图渐隐切换some code
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* 实例化一个焦点图 */</span>
<span class="kd">var</span> <span class="nx">loopImg</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">fadeLoopImg</span><span class="p">([],</span><span class="s1">&#39;slider&#39;</span><span class="p">,[]);</span>
</code></pre></div>
<blockquote>
<p>通过基类实现焦点图的所有需求属性和方法，然后通过子类继承与基类获取所有属性和方法，同时再在子类中扩展或者重写其属性和方法，实现各种各样不同的轮播效果。</p>
</blockquote>

<p>上边的方式存在一个很严重的问题，就是不管子类有没有用基类的属性和方法都继承过来了，而且所有的属性和方法定义在基类上，假如有基类有某种耗时操作就会影响整个子类的使用，所以再好一点：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="cm">/* 创建一个焦点图的类 */</span>
<span class="kd">var</span> <span class="nx">LoopImage</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">imgArr</span><span class="p">,</span> <span class="nx">container</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">imageArr</span> <span class="o">=</span> <span class="nx">imageArr</span><span class="p">;</span>               <span class="c1">// 存放图片的数组
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">container</span> <span class="o">=</span> <span class="nx">container</span><span class="p">;</span>             <span class="c1">// 焦点图容器
</span><span class="c1"></span><span class="p">}</span>

<span class="cm">/* 将一些耗时操作或者复杂操作定义在基类原型上 */</span>
<span class="nx">LoopImage</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">createImage</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="cm">/* some code */</span>
    <span class="p">},</span>
    <span class="nx">changeImage</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="cm">/* some code */</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* 上下滑切换类 */</span>
<span class="kd">var</span> <span class="nx">slideLoopImg</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">imageArr</span><span class="p">,</span><span class="nx">container</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 类式继承基类的方法和属性
</span><span class="c1"></span>    <span class="nx">LoopImage</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">imageArr</span><span class="p">,</span> <span class="nx">container</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 子类原型指向基类实例实现继承，共享基类原型上的方法
</span><span class="c1"></span><span class="nx">slideLoopImg</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">LoopImage</span><span class="p">();</span>
<span class="c1">// 重写子类的changeImage方法
</span><span class="c1"></span><span class="nx">slideLoopImg</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">changeImage</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 实现焦点图滑动切换some code
</span><span class="c1"></span><span class="p">}</span>

<span class="cm">/* 渐隐切换类 */</span>
<span class="kd">var</span> <span class="nx">fadeLoopImg</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">imageArr</span><span class="p">,</span> <span class="nx">container</span><span class="p">,</span> <span class="nx">arrow</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 类式继承基类的方法
</span><span class="c1"></span>    <span class="nx">LoopImage</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">imageArr</span><span class="p">,</span> <span class="nx">container</span><span class="p">);</span>
    <span class="c1">// 私有变量arrow
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">arrow</span> <span class="o">=</span> <span class="nx">arrow</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 子类原型指向基类实例实现继承，共享基类原型上的方法
</span><span class="c1"></span><span class="nx">fadeLoopImg</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">LoopImage</span><span class="p">();</span>
<span class="c1">// 重写子类的changeImage方法
</span><span class="c1"></span><span class="nx">fadeLoopImg</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">changeImage</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 实现焦点图滑动切换some code
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>
<blockquote>
<p>当然这里原型对象其实是共享的，无论是在子类还是父类上修改原型对像都会生效，所以这里带来便利的同时也存在风险，修改公用属性或者方法时需要注意对其他子类的影响。</p>
</blockquote>

<p>利用原型链的特点实现对像的深浅复制</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="cm">/**** 浅拷贝基于引用类型，不会重新开辟内存；深拷贝需要递归转化成基本类型进行拷贝 ****/</span>
<span class="kd">function</span> <span class="nx">prototypeExtend</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">F</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{},</span>
        <span class="nx">args</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">,</span>
        <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nx">len</span> <span class="o">=</span> <span class="nx">args</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 遍历传进来的每个对像组成的参数伪数组
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">len</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="c1">// 遍历每个对像的属性进行复制
</span><span class="c1"></span>            <span class="nx">F</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">len</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">key</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 返回新的实例，此时F原型上实现对所有对像的属性方法的引用
</span><span class="c1"></span>    <span class="k">return</span> <span class="k">new</span> <span class="nx">F</span> <span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="4-单例模式">4. 单例模式</h4>

<blockquote>
<p>单例模式是指只允许实例化一次的对像类，使用自调用函数。更多的是规划一个命名空间。</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">// 声明Carlos命名空间，将一些方法挂载在其下边
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">Carlos</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">Unit</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">unitMethod1</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{},</span>
        <span class="nx">unitMethod2</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{}</span>
    <span class="p">},</span>
    <span class="nx">dom</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">domOperation1</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{},</span>
        <span class="nx">domOperation2</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{}</span>
    <span class="p">},</span>
    <span class="p">.....</span>
<span class="p">}</span>
</code></pre></div>
<blockquote>
<p>惰性单例，只有在使用时才会创建，否则不创建，这样就会提高性能，（有点像懒加载？？）</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">lazySingle</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 单例实例引用
</span><span class="c1"></span>    <span class="kd">var</span> <span class="nx">instance</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="c1">// 单例
</span><span class="c1"></span>    <span class="kd">function</span> <span class="nx">single</span> <span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 私有属性和方法
</span><span class="c1"></span>        <span class="k">return</span> <span class="p">{</span>
            <span class="nx">method</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{},</span>
            <span class="nx">prototype</span><span class="o">:</span> <span class="s1">&#39;1111&#39;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 获取单例对像
</span><span class="c1"></span>    <span class="k">return</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 如果单例还未创建则创建单例
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">instance</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">instance</span> <span class="o">=</span> <span class="nx">single</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">instance</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">})()</span>
<span class="c1">// 调用单例方法
</span><span class="c1"></span><span class="nx">lazySingle</span><span class="p">().</span><span class="nx">method</span><span class="p">()</span>
</code></pre></div>
<blockquote>
<p>很明显，lazySingle中返回的实例只有在调用的时候才会声明。</p>
</blockquote>

<h4 id="5-适配器模式">5. 适配器模式</h4>

<blockquote>
<p>适配器模式有以下几种用法：
1. 当前框架适配其他框架
2. 参数适配器
3. 数据适配</p>
</blockquote>

<h3 id="flex-align-item-align-content的区别">flex  align-item align-content的区别</h3>

<ul>
<li>容器属性

<ul>
<li>flex-direction      主轴的方向</li>
<li>flex-wrap       主轴一行展示不下，如何换行</li>
<li>justify-content 项目在主轴上的对齐方式</li>
<li>align-items     项目在交叉轴上的对齐方式</li>
<li>align-content       多根轴线如何对齐</li>
</ul></li>
<li>项目属性

<ul>
<li>order           项目的排列顺序 越小越靠前 默认0</li>
<li>flex-grow       项目的放大比例
默认为0 等于0不会放大。大于0，如果有剩余空间的情况下，项目1为x1，项目2为x2，则项目1占剩余空间的x1/(x1+x2)</li>
<li>flex-shrink     项目的缩小比例
默认为1 等于0不参与缩小。ul width 100px。两个li宽100px，默认每个li都会被缩小1/(1+1)=1/2。第一个li 2，第二个li 3，则第一个li被缩小2/(2+3)=2/5，被缩小的实际宽度为2/5*100=40，剩余宽度为60。第一个li 为0，如果第二个li为0，那么两者都不缩小，第二个li 大于0，那么li实际宽度，第一个li不缩小。</li>
<li>flex-basis      项目的占据主轴的空间 默认auto</li>
<li>flex-self           该项目单独的对齐方式
****</li>
</ul></li>
</ul>

<h3 id="基本类型和引用类型在内存中是如何存储的">基本类型和引用类型在内存中是如何存储的</h3>

<ul>
<li>基本类型存储在栈内存</li>
<li>引用类型存储在堆内存 栈内存中存的是引用类型在堆内存中的地址 或者说存的是引用类型的引用
****</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>前端面试-常见手写题总结3</title>
			<link>https://caychance.github.io/posts/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-%E5%B8%B8%E8%A7%81%E6%89%8B%E5%86%99%E9%A2%98%E6%80%BB%E7%BB%933/</link>
			<pubDate>Thu, 18 Mar 2021 23:02:37 +0800</pubDate>
			
			<guid>https://caychance.github.io/posts/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-%E5%B8%B8%E8%A7%81%E6%89%8B%E5%86%99%E9%A2%98%E6%80%BB%E7%BB%933/</guid>
			<description>手写题部分 理解每个手写题的思路很重要，不需要死记硬背。
// es5手写call Function.prototype.call = function (context) { var context = context || window; context.fn = this; var args = []; for (var i = 1, len = arguments.length; i &amp;lt; len; i++) { args.push(&amp;#34;arguments[&amp;#34; + i + &amp;#34;]&amp;#34;); } var result = eval(&amp;#34;context.fn(&amp;#34; + args + &amp;#34;)&amp;#34;); delete context.fn; return result; }; // es5手写apply Function.prototype.apply = function (context, arr) { var context = context || window; context.fn = this; var result; if (!</description>
			<content type="html"><![CDATA[

<h3 id="手写题部分">手写题部分</h3>

<p>理解每个手写题的思路很重要，不需要死记硬背。</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// es5手写call
</span><span class="c1"></span><span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">call</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">context</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">context</span> <span class="o">=</span> <span class="nx">context</span> <span class="o">||</span> <span class="nb">window</span><span class="p">;</span>
  <span class="nx">context</span><span class="p">.</span><span class="nx">fn</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">args</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&#34;arguments[&#34;</span> <span class="o">+</span> <span class="nx">i</span> <span class="o">+</span> <span class="s2">&#34;]&#34;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s2">&#34;context.fn(&#34;</span> <span class="o">+</span> <span class="nx">args</span> <span class="o">+</span> <span class="s2">&#34;)&#34;</span><span class="p">);</span>
  <span class="k">delete</span> <span class="nx">context</span><span class="p">.</span><span class="nx">fn</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// es5手写apply
</span><span class="c1"></span><span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">apply</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">context</span><span class="p">,</span> <span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">context</span> <span class="o">=</span> <span class="nx">context</span> <span class="o">||</span> <span class="nb">window</span><span class="p">;</span>
  <span class="nx">context</span><span class="p">.</span><span class="nx">fn</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">result</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">result</span> <span class="o">=</span> <span class="nx">context</span><span class="p">.</span><span class="nx">fn</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">args</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&#34;arr[&#34;</span> <span class="o">+</span> <span class="nx">i</span> <span class="o">+</span> <span class="s2">&#34;]&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">result</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s2">&#34;context.fn(&#34;</span> <span class="o">+</span> <span class="nx">args</span> <span class="o">+</span> <span class="s2">&#34;)&#34;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">delete</span> <span class="nx">context</span><span class="p">.</span><span class="nx">fn</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">};</span>

<span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">myCall</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">context</span> <span class="o">=</span> <span class="nb">window</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">context</span><span class="p">.</span><span class="nx">fn</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">args</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">arguments</span><span class="p">].</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">context</span><span class="p">.</span><span class="nx">fn</span><span class="p">(...</span><span class="nx">args</span><span class="p">);</span>
  <span class="k">delete</span> <span class="nx">context</span><span class="p">.</span><span class="nx">fn</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">};</span>
<span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">myApply</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">context</span> <span class="o">=</span> <span class="nb">window</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">context</span><span class="p">.</span><span class="nx">fn</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">result</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">arguments</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
    <span class="nx">result</span> <span class="o">=</span> <span class="nx">context</span><span class="p">.</span><span class="nx">fn</span><span class="p">(...</span><span class="nx">arguments</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">result</span> <span class="o">=</span> <span class="nx">context</span><span class="p">.</span><span class="nx">fn</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">delete</span> <span class="nx">context</span><span class="p">.</span><span class="nx">fn</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">};</span>

<span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">bind</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">context</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 1、返回一个函数
</span><span class="c1"></span>  <span class="c1">// 2、里外两个函数均可拼接参数
</span><span class="c1"></span>  <span class="c1">// 3、bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效。
</span><span class="c1"></span>  <span class="c1">// 4、判断传入参数类型
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="k">this</span> <span class="o">!==</span> <span class="s2">&#34;function&#34;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span>
      <span class="s2">&#34;Function.prototype.bind - what is trying to be bound is not callable&#34;</span>
    <span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">fNOP</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{};</span>
  <span class="kd">var</span> <span class="nx">fBound</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">bindArgs</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span>
      <span class="k">this</span> <span class="k">instanceof</span> <span class="nx">fNOP</span> <span class="o">?</span> <span class="k">this</span> <span class="o">:</span> <span class="nx">context</span><span class="p">,</span>
      <span class="nx">args</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">bindArgs</span><span class="p">)</span>
    <span class="p">);</span>
  <span class="p">};</span>
  <span class="nx">fNOP</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
  <span class="nx">fBound</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">fNOP</span><span class="p">();</span>
  <span class="k">return</span> <span class="nx">fBound</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 手写promise
</span><span class="c1"></span><span class="k">const</span> <span class="nx">PENDING</span> <span class="o">=</span> <span class="s2">&#34;PENDING&#34;</span><span class="p">;</span>
<span class="k">const</span> <span class="nx">FULFILLED</span> <span class="o">=</span> <span class="s2">&#34;FULFILLED&#34;</span><span class="p">;</span>
<span class="k">const</span> <span class="nx">REJECTED</span> <span class="o">=</span> <span class="s2">&#34;REJECTED&#34;</span><span class="p">;</span>
<span class="k">class</span> <span class="nb">Promise</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">(</span><span class="nx">executor</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">=</span> <span class="nx">PENDING</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">reason</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
    <span class="c1">// 存放成功的回调
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">onResolvedCallback</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="c1">// 存放失败的回调
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">onRejectedCallback</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="kd">let</span> <span class="nx">resolve</span> <span class="o">=</span> <span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="nx">PENDING</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">=</span> <span class="nx">FULFILLED</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
        <span class="c1">// 依次将对应的函数执行
</span><span class="c1"></span>        <span class="k">this</span><span class="p">.</span><span class="nx">onResolvedCallback</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">fn</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">fn</span><span class="p">());</span>
      <span class="p">}</span>
    <span class="p">};</span>
    <span class="kd">let</span> <span class="nx">reject</span> <span class="o">=</span> <span class="p">(</span><span class="nx">reason</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="nx">PENDING</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">=</span> <span class="nx">REJECTED</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">reason</span> <span class="o">=</span> <span class="nx">reason</span><span class="p">;</span>
        <span class="c1">// 依次将对应的函数执行
</span><span class="c1"></span>        <span class="k">this</span><span class="p">.</span><span class="nx">onRejectedCallback</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">fn</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">fn</span><span class="p">());</span>
      <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">try</span> <span class="p">{</span>
      <span class="nx">executor</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">reject</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">then</span><span class="p">(</span><span class="nx">onFulfilled</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="nx">FULFILLED</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">onFulfilled</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="nx">REJECTED</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">onRejected</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">reason</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="nx">PENDING</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行
</span><span class="c1"></span>      <span class="k">this</span><span class="p">.</span><span class="nx">onResolvedCallback</span><span class="p">.</span><span class="nx">push</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">onFulfilled</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
      <span class="p">});</span>

      <span class="c1">// 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行
</span><span class="c1"></span>      <span class="k">this</span><span class="p">.</span><span class="nx">onRejectedCallback</span><span class="p">.</span><span class="nx">push</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">onRejected</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">reason</span><span class="p">);</span>
      <span class="p">});</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">all</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 1、返回的是个promise对象
</span><span class="c1"></span>  <span class="c1">// 2、把传入的promise数组全部执行，并将结果存起来
</span><span class="c1"></span>  <span class="c1">// 3、等全部执行完以后，返回结果
</span><span class="c1"></span>  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
      <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
        <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">data</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
          <span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
        <span class="p">})</span>
        <span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">e</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
          <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
        <span class="p">});</span>
    <span class="p">}</span>
  <span class="p">});</span>
<span class="p">};</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">race</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
      <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
        <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">data</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
          <span class="nx">resolve</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
        <span class="p">})</span>
        <span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">e</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
          <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
        <span class="p">});</span>
    <span class="p">}</span>
  <span class="p">});</span>
<span class="p">};</span>

<span class="c1">// 调用
</span><span class="c1"></span><span class="k">const</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">resolve</span><span class="p">(</span><span class="s2">&#34;成功&#34;</span><span class="p">);</span>
  <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span>
  <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;success&#34;</span><span class="p">,</span> <span class="nx">data</span><span class="p">);</span>
  <span class="p">},</span>
  <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;faild&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">);</span>

<span class="c1">// 柯里化
</span><span class="c1">// 函数科里化， 对函数的一种转换，例如：fn(a, b, c)可转化为fn(a)(b)(c)调用，本质上上一种函数转换
</span><span class="c1">// 简单柯里化
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">adds</span> <span class="o">=</span> <span class="nx">curry</span><span class="p">(</span><span class="nx">add</span><span class="p">);</span>
<span class="nx">adds</span><span class="p">(</span><span class="mi">3</span><span class="p">)(</span><span class="mi">4</span><span class="p">);</span>

<span class="k">const</span> <span class="nx">easyCurry</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">fn</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span>
    <span class="p">};</span>
  <span class="p">};</span>
<span class="p">};</span>

<span class="c1">// 复杂柯里化
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span> <span class="o">+</span> <span class="nx">c</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">curriedSum</span> <span class="o">=</span> <span class="nx">curry</span><span class="p">(</span><span class="nx">sum</span><span class="p">);</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">curriedSum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span> <span class="c1">// 6，仍然可以被正常调用
</span><span class="c1"></span><span class="nx">alert</span><span class="p">(</span><span class="nx">curriedSum</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span> <span class="c1">// 6，对第一个参数的柯里化
</span><span class="c1"></span><span class="nx">alert</span><span class="p">(</span><span class="nx">curriedSum</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="mi">2</span><span class="p">)(</span><span class="mi">3</span><span class="p">));</span> <span class="c1">// 6，全柯里化
</span><span class="c1"></span>
<span class="k">const</span> <span class="nx">curry</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="nx">curried</span><span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 如果传入参数数大于函数可接受的参数数
</span><span class="c1"></span>    <span class="c1">// 原封不动输出
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;=</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 最终还是返回fn 参数动态拼在一起
</span><span class="c1"></span>      <span class="k">return</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 否则
</span><span class="c1"></span>    <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// 把之前的参数拼在一起去调用curried
</span><span class="c1"></span>      <span class="k">return</span> <span class="kd">function</span> <span class="p">(...</span><span class="nx">args2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">curried</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">args</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">args2</span><span class="p">));</span>
      <span class="p">};</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">};</span>

<span class="c1">// 二叉树前序遍历 last
</span><span class="c1"></span><span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
<span class="kd">function</span> <span class="nx">loopTree</span><span class="p">(</span><span class="nx">tree</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">tree</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">tree</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span> <span class="c1">//前中后序遍历只需调整此行代码即可
</span><span class="c1"></span>    <span class="nx">loopTree</span><span class="p">(</span><span class="nx">tree</span><span class="p">.</span><span class="nx">left</span><span class="p">);</span>
    <span class="nx">loopTree</span><span class="p">(</span><span class="nx">tree</span><span class="p">.</span><span class="nx">right</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 防抖
</span><span class="c1">// 定义：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。
</span><span class="c1">// 应用：输入框实时搜索，按钮防重复点击
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">debounce</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">delay</span><span class="p">,</span> <span class="nx">immediate</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">timer</span><span class="p">;</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">timer</span><span class="p">)</span> <span class="nx">clearTimeout</span><span class="p">(</span><span class="nx">timer</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">immediate</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">timer</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
      <span class="p">},</span> <span class="nx">delay</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="c1">// 节流
</span><span class="c1">// 定义：规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。
</span><span class="c1">// 摁一下，发射一个子弹。最快每秒1发，如果1秒内触发了3次，还是只会发射一发。
</span><span class="c1">// 监控浏览器resize
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">throttle</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">delay</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">prev</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">();</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">now</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">now</span> <span class="o">-</span> <span class="nx">prev</span> <span class="o">&gt;</span> <span class="nx">delay</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
      <span class="nx">prev</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="c1">// 深拷贝
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">isObject</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">target</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="k">typeof</span> <span class="nx">target</span> <span class="o">===</span> <span class="s2">&#34;object&#34;</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 简易版深拷贝
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">deepClone</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 不是对象直接返回
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isObject</span><span class="p">(</span><span class="nx">target</span><span class="p">))</span> <span class="k">return</span> <span class="nx">target</span><span class="p">;</span>
  <span class="c1">// 判断数组
</span><span class="c1"></span>  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="o">?</span> <span class="p">[]</span> <span class="o">:</span> <span class="p">{};</span><span class="c1">//如果需要解决相同引用和循环引用，在此处前后使用map去存储和获取
</span><span class="c1"></span>  <span class="kd">let</span> <span class="nx">keys</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">target</span><span class="p">);</span>
  <span class="c1">// 迭代目标对象的key来递归完成复制
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">keys</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">result</span><span class="p">[</span><span class="nx">keys</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">=</span> <span class="nx">deepClone</span><span class="p">(</span><span class="nx">target</span><span class="p">[</span><span class="nx">keys</span><span class="p">[</span><span class="nx">i</span><span class="p">]]);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**
</span><span class="cm"> * @description: 解决相同引用和循环引用的深拷贝版本
</span><span class="cm"> */</span>
<span class="kd">function</span> <span class="nx">deepClone</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">visitedMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">();</span>
  <span class="kd">function</span> <span class="nx">baseClone</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isObject</span><span class="p">(</span><span class="nx">target</span><span class="p">))</span> <span class="k">return</span> <span class="nx">target</span><span class="p">;</span>
    <span class="c1">// 先获取map中是否存在当前target，如果存在则直接返回
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">visitedMap</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">target</span><span class="p">))</span> <span class="k">return</span> <span class="nx">visitedMap</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">target</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="o">?</span> <span class="p">[]</span> <span class="o">:</span> <span class="p">{};</span>
    <span class="nx">visitedMap</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">result</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">keys</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">target</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">keys</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">result</span><span class="p">[</span><span class="nx">keys</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">=</span> <span class="nx">baseClone</span><span class="p">(</span><span class="nx">target</span><span class="p">[</span><span class="nx">keys</span><span class="p">[</span><span class="nx">i</span><span class="p">]]);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">baseClone</span><span class="p">(</span><span class="nx">target</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nx">EventEmitter</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 维护事件及监听者
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">listeners</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="p">}</span>
  <span class="cm">/**
</span><span class="cm">   * 注册事件监听者
</span><span class="cm">   * @param {String} key 事件类型
</span><span class="cm">   * @param {Function} fn 回调函数
</span><span class="cm">   */</span>
  <span class="nx">on</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">listeners</span><span class="p">[</span><span class="nx">key</span><span class="p">])</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">listeners</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="p">}</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">listeners</span><span class="p">[</span><span class="nx">key</span><span class="p">].</span><span class="nx">push</span><span class="p">(</span><span class="nx">fn</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="cm">/**
</span><span class="cm">   * 发布事件
</span><span class="cm">   * @param {String} key 事件类型
</span><span class="cm">   * @param  {...any} arg 参数列表，把emit传递的参数赋给回调函数
</span><span class="cm">   */</span>
  <span class="nx">emit</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="p">...</span><span class="nx">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">listeners</span><span class="p">[</span><span class="nx">key</span><span class="p">])</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">listeners</span><span class="p">[</span><span class="nx">key</span><span class="p">].</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">fn</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">fn</span><span class="p">(...</span><span class="nx">arg</span><span class="p">);</span>
      <span class="p">});</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="cm">/**
</span><span class="cm">   * 移除某个事件的一个监听者
</span><span class="cm">   * @param {String} key 事件类型
</span><span class="cm">   * @param {Function} fn 回调函数
</span><span class="cm">   */</span>
  <span class="nx">off</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">listeners</span><span class="p">[</span><span class="nx">key</span><span class="p">])</span> <span class="p">{</span>
      <span class="k">const</span> <span class="nx">targetIndex</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">listeners</span><span class="p">[</span><span class="nx">key</span><span class="p">].</span><span class="nx">findIndex</span><span class="p">((</span><span class="nx">item</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">item</span> <span class="o">===</span> <span class="nx">fn</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">targetIndex</span> <span class="o">!==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">listeners</span><span class="p">[</span><span class="nx">key</span><span class="p">].</span><span class="nx">splice</span><span class="p">(</span><span class="nx">targetIndex</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">listeners</span><span class="p">[</span><span class="nx">key</span><span class="p">].</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">delete</span> <span class="k">this</span><span class="p">.</span><span class="nx">listeners</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="cm">/**
</span><span class="cm">   * 移除某个事件的所有监听者
</span><span class="cm">   * @param {String} key 事件类型
</span><span class="cm">   */</span>
  <span class="nx">offAll</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">listeners</span><span class="p">[</span><span class="nx">key</span><span class="p">])</span> <span class="p">{</span>
      <span class="k">delete</span> <span class="k">this</span><span class="p">.</span><span class="nx">listeners</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 创建事件管理器实例
</span><span class="c1"></span><span class="k">const</span> <span class="nx">eve</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">EventEmitter</span><span class="p">();</span>
<span class="c1">// 注册一个chifan事件监听者
</span><span class="c1"></span><span class="nx">eve</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&#34;eat&#34;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;吃饭了，我们走！&#34;</span><span class="p">);</span>
<span class="p">});</span>
<span class="c1">// 发布事件chifan
</span><span class="c1"></span><span class="nx">eve</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="s2">&#34;eat&#34;</span><span class="p">);</span>
<span class="c1">// 也可以emit传递参数
</span><span class="c1"></span><span class="nx">eve</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&#34;eat&#34;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">address</span><span class="p">,</span> <span class="nx">food</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`吃饭了，我们去</span><span class="si">${</span><span class="nx">address</span><span class="si">}</span><span class="sb">吃</span><span class="si">${</span><span class="nx">food</span><span class="si">}</span><span class="sb">！`</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">eve</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="s2">&#34;eat&#34;</span><span class="p">,</span> <span class="s2">&#34;三食堂&#34;</span><span class="p">,</span> <span class="s2">&#34;铁板饭&#34;</span><span class="p">);</span> <span class="c1">// 此时会打印两条信息，因为前面注册了两个chifan事件的监听者
</span><span class="c1">// 测试移除事件监听
</span><span class="c1"></span><span class="k">const</span> <span class="nx">toBeRemovedListener</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;我是一个可以被移除的监听者&#34;</span><span class="p">);</span>
<span class="p">};</span>
<span class="nx">eve</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&#34;testoff&#34;</span><span class="p">,</span> <span class="nx">toBeRemovedListener</span><span class="p">);</span>
<span class="nx">eve</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="s2">&#34;testoff&#34;</span><span class="p">);</span>
<span class="nx">eve</span><span class="p">.</span><span class="nx">off</span><span class="p">(</span><span class="s2">&#34;testoff&#34;</span><span class="p">,</span> <span class="nx">toBeRemovedListener</span><span class="p">);</span>
<span class="nx">eve</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="s2">&#34;testoff&#34;</span><span class="p">);</span> <span class="c1">// 此时事件监听已经被移除，不会再有console.log打印出来了
</span><span class="c1">// 测试移除chifan的所有事件监听
</span><span class="c1"></span><span class="nx">eve</span><span class="p">.</span><span class="nx">offAll</span><span class="p">(</span><span class="s2">&#34;eat&#34;</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">eve</span><span class="p">);</span> <span class="c1">// 此时可以看到eve.listeners已经变成空对象了，再emit发送chifan事件也不会有反应了
</span><span class="c1"></span>
<span class="c1">// 斐波那契数列
</span><span class="c1">// 输入正整数n，输出0，1，1，2，3，5，8，13...
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">fibonacci</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nx">n</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">fibonacci</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nx">fibonacci</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 动态规划
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">dynFib</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nx">n</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nx">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="nx">result</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">result</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nx">result</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">[</span><span class="nx">n</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">// 冒泡排序
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">bubbleSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">len</span> <span class="o">-</span> <span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
        <span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]];</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">];</span>
<span class="nx">bubbleSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span>

<span class="c1">// 插入排序
</span><span class="c1">// 快速排序
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">quickSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">){</span>
  <span class="c1">// 1、从数组arr中拿出中间项mid
</span><span class="c1"></span>  <span class="c1">// 2、声明左右两个数组，循环arr，比mid小push到左数组，否则push到右数组
</span><span class="c1"></span>  <span class="c1">// 3、对左右两个数组进行递归处理，把左数组，中间值，右数组拼在一起
</span><span class="c1"></span>  <span class="c1">// 4、如果数组里面只有一项或者没有，那么原封不动返回数组
</span><span class="c1"></span>  <span class="k">if</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nx">arr</span>
  <span class="kd">let</span> <span class="nx">middleIndex</span> <span class="o">=</span> <span class="nb">parseInt</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
  <span class="kd">let</span> <span class="nx">middleValue</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">middleIndex</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
  <span class="kd">let</span> <span class="nx">arrLeft</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="kd">let</span> <span class="nx">arrRight</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">item</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="nx">item</span><span class="o">&lt;</span><span class="nx">middleValue</span> <span class="o">?</span> <span class="nx">arrLeft</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="o">:</span> <span class="nx">arrRight</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">quickSort</span><span class="p">(</span><span class="nx">arrLeft</span><span class="p">).</span><span class="nx">concat</span><span class="p">(</span><span class="nx">middleValue</span><span class="p">,</span> <span class="nx">quickSort</span><span class="p">(</span><span class="nx">arrRight</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>url中带两个点会发生什么</title>
			<link>https://caychance.github.io/posts/url%E4%B8%AD%E5%B8%A6%E4%B8%A4%E4%B8%AA%E7%82%B9%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/</link>
			<pubDate>Mon, 14 Dec 2020 22:21:50 +0800</pubDate>
			
			<guid>https://caychance.github.io/posts/url%E4%B8%AD%E5%B8%A6%E4%B8%A4%E4%B8%AA%E7%82%B9%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/</guid>
			<description>很久没有更新了~
背景： 最近在做一个B端的内部应用系统，查找通讯录。遇到一个问题，觉得很有意思，在此记录一下。后端提供了几个接口来查询通讯录。接口地址大概是这样子的：
url = `http://aa.bbb.com/user/search/${page}/${size}/${val}`  解释： get请求，要查询的数据就是val。前几天前端做了限制，不让用户输入一些特殊字符，今天产品说这块不做限制了。因此遇到了一个问题。
现象： 测试过程中当输入两个点的时候，接口请求404。
分析： 正常请求地址：http://aa.bbb.com/user/search/1/6/..
浏览器中的实际访问地址：http://aa.bbb.com/user/search/1 因此导致接口返回404
可亲自尝试一下： 在浏览器中访问： https://www.zhihu.com/question/422032638/answer/1522362574
可以访问，虽然提示内容已删除。
在浏览器中访问： https://www.zhihu.com/question/422032638/answer/../1522362574
但是实际的访问地址变成： https://www.zhihu.com/question/422032638/1522362574
解释： url中的点.有什么含义
规范</description>
			<content type="html"><![CDATA[

<hr />

<p>很久没有更新了~</p>

<h4 id="背景">背景：</h4>

<p>最近在做一个B端的内部应用系统，查找通讯录。遇到一个问题，觉得很有意思，在此记录一下。后端提供了几个接口来查询通讯录。接口地址大概是这样子的：</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">url</span> <span class="o">=</span> <span class="sb">`http://aa.bbb.com/user/search/</span><span class="si">${</span><span class="nx">page</span><span class="si">}</span><span class="sb">/</span><span class="si">${</span><span class="nx">size</span><span class="si">}</span><span class="sb">/</span><span class="si">${</span><span class="nx">val</span><span class="si">}</span><span class="sb">`</span>
</code></pre></div>
<h4 id="解释">解释：</h4>

<p>get请求，要查询的数据就是val。前几天前端做了限制，不让用户输入一些特殊字符，今天产品说这块不做限制了。因此遇到了一个问题。</p>

<h4 id="现象">现象：</h4>

<p>测试过程中当输入两个点的时候，接口请求404。</p>

<h4 id="分析">分析：</h4>

<p>正常请求地址：<a href="http://aa.bbb.com/user/search/1/6/.">http://aa.bbb.com/user/search/1/6/.</a>.</p>

<p>浏览器中的实际访问地址：<a href="http://aa.bbb.com/user/search/1">http://aa.bbb.com/user/search/1</a>  因此导致接口返回404</p>

<h4 id="可亲自尝试一下">可亲自尝试一下：</h4>

<p>在浏览器中访问： <a href="https://www.zhihu.com/question/422032638/answer/1522362574">https://www.zhihu.com/question/422032638/answer/1522362574</a></p>

<p>可以访问，虽然提示内容已删除。</p>

<p>在浏览器中访问： <a href="https://www.zhihu.com/question/422032638/answer/../1522362574">https://www.zhihu.com/question/422032638/answer/../1522362574</a></p>

<p>但是实际的访问地址变成：  <a href="https://www.zhihu.com/question/422032638/1522362574">https://www.zhihu.com/question/422032638/1522362574</a></p>

<h4 id="解释-1">解释：</h4>

<p><a href="https://stackoverflow.com/questions/6008829/what-does-a-dot-mean-in-a-url-path?lq=1">url中的点.有什么含义</a></p>

<p><a href="https://tools.ietf.org/html/rfc3986#section-5.2.4">规范</a></p>
]]></content>
		</item>
		
		<item>
			<title>Express项目中使用Mongoose</title>
			<link>https://caychance.github.io/posts/express%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8mongoose/</link>
			<pubDate>Tue, 27 Oct 2020 10:52:28 +0800</pubDate>
			
			<guid>https://caychance.github.io/posts/express%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8mongoose/</guid>
			<description>安装MongoDB 安装以及启动mongodb遇到好几个问题。
首先，不能使用brew安装了，因为MongoDB不再开源了。
后来就按照菜鸟教程上的安装方法进行安装：
# 进入 /usr/local cd /usr/local # 下载 sudo curl -O https://fastdl.mongodb.org/osx/mongodb-osx-ssl-x86_64-4.0.9.tgz # 解压 sudo tar -zxvf mongodb-osx-ssl-x86_64-4.0.9.tgz # 重命名为 mongodb 目录 sudo mv mongodb-osx-x86_64-4.0.9/ mongodb  菜鸟教程
启动MongoDB 为MongoDB新建默认目录的时候执行命令如下
sudo mkdir -p /data/db  结果报错，后来网上查了一下发现最新版的Mac系统：不允许更改根目录
后来就在mac上新建了一个非根目录的目录当做MongoDB的默认目录。当然需要确保~/data/db目录存在。
mongod --dbpath ~/data/db  参考地址
生成express应用 可以express-generator来快速生成express应用，当然首先需要安装好express-generator。
express mongooseDemo  暖风博客园</description>
			<content type="html"><![CDATA[

<h3 id="安装mongodb">安装MongoDB</h3>

<p>安装以及启动mongodb遇到好几个问题。</p>

<p>首先，不能使用brew安装了，因为MongoDB不再开源了。</p>

<p>后来就按照菜鸟教程上的安装方法进行安装：</p>

<pre><code># 进入 /usr/local
cd /usr/local

# 下载
sudo curl -O https://fastdl.mongodb.org/osx/mongodb-osx-ssl-x86_64-4.0.9.tgz

# 解压
sudo tar -zxvf mongodb-osx-ssl-x86_64-4.0.9.tgz

# 重命名为 mongodb 目录

sudo mv mongodb-osx-x86_64-4.0.9/ mongodb
</code></pre>

<p><a href="https://www.runoob.com/mongodb/mongodb-osx-install.html">菜鸟教程</a></p>

<h3 id="启动mongodb">启动MongoDB</h3>

<p>为MongoDB新建默认目录的时候执行命令如下</p>

<pre><code>sudo mkdir -p /data/db
</code></pre>

<p>结果报错，后来网上查了一下发现<b>最新版的Mac系统：不允许更改根目录</b></p>

<p>后来就在mac上新建了一个非根目录的目录当做MongoDB的默认目录。当然需要确保<code>~/data/db</code>目录存在。</p>

<pre><code>mongod --dbpath ~/data/db
</code></pre>

<p><a href="https://www.cnblogs.com/nayek/p/12221379.html">参考地址</a></p>

<h3 id="生成express应用">生成express应用</h3>

<p>可以express-generator来快速生成express应用，当然首先需要安装好express-generator。</p>

<pre><code>express mongooseDemo
</code></pre>

<p><a href="https://www.cnblogs.com/woodk/p/6155955.html">暖风博客园</a></p>
]]></content>
		</item>
		
		<item>
			<title>春节期间项目总结</title>
			<link>https://caychance.github.io/posts/%E6%98%A5%E8%8A%82%E6%9C%9F%E9%97%B4%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</link>
			<pubDate>Thu, 13 Feb 2020 13:58:52 +0800</pubDate>
			
			<guid>https://caychance.github.io/posts/%E6%98%A5%E8%8A%82%E6%9C%9F%E9%97%B4%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</guid>
			<description>今年春节赶上了疫情，因此就在疫情期间，我们团队在家做了好几个项目。遇到一些问题，记录一下。
主要做了四个项目，如下：  问卷调查项目 地址 疫情地图项目 地址 戴口罩项目 地址 找口罩项目 地址  问题总结收获如下：  苹果手机滚动不流畅问题
解决方法：-webkit-overflow-scrolling: touch;
 上下滚动的轮播图 现象：疫情地图项目首页，有一个展示疫情资讯的轮播图。使用了vant的swipe轮播组件，遇到一个问题，随着滚动次数的增多，就会出现越来越大的偏移。
  问题定位：通过定位问题发现，轮播图每次往上滚动的距离是 36.421875px，实际我们使用的是rem，rem的换算导致出现到小数点的距离，所以每次滚动都会出现偏移量，随着次数的增多，越来越明显。
问题解决：更换了两次swipe组件后终于好了。 vue-awesome-swiper 传送门 点个赞~~~
 dom没有渲染 现象：疫情项目首页，疫情地图tab，有一个本地疫情的卡片，前端获取到当前城市后，数据变了，但是页面没有改变。(PS:此处逻辑是前端调用后端接口获取定位，如果获取到定位，就展示当前定位城市的疫情，否则不展示。)  问题定位：vue中的数据变了，但是页面中没有更新。
问题解决：强制重新渲染 this.$forceUpdate()
 两个span标签 同一行显示问题 现象：疫情项目，同行程查询页面。 其他及其后面的文字，都是用的是span标签。在设置了display: inline-block;后，其他及其后面的文字在后面的文字超出一行的时候，就不会同一行显示了。  问题解决：设置 display: inline-block; 为 display: inline; 或者说不设置就不会有这个问题。(PS:当时是另一个同事写的)
PS: css也不简单
 vue中监听对象的某个属性  computed: { urlHead(){ return this.projectInfo.urlHead } }, watch: { urlHead(newVal, oldVal){ this.servicePrefixListLabel=this.projectInfo.urlHead.split(&amp;#39;://{host}:&amp;#39;)[0], this.host=this.projectInfo.urlHead.split(&amp;#39;://{host}:&amp;#39;)[1] }, }   vue移动端项目粘贴功能  问题描述：刚开始使用的是 clipboard这个包，但是遇到了一些问题。按钮的点击事件根据情况，可以复制，也可以跳转页面。</description>
			<content type="html"><![CDATA[

<hr />

<p>今年春节赶上了疫情，因此就在疫情期间，我们团队在家做了好几个项目。遇到一些问题，记录一下。</p>

<h4 id="主要做了四个项目-如下">主要做了四个项目，如下：</h4>

<ol>
<li>问卷调查项目 <a href="https://promotion.elong.com/questionnaire/index.html#/">地址</a></li>
<li>疫情地图项目 <a href="https://promotion.elong.com/epidemic/index.html#/index">地址</a></li>
<li>戴口罩项目 <a href="https://promotion.elong.com/mask/index.html#/index">地址</a></li>
<li>找口罩项目 <a href="https://promotion.elong.com/lookformask/index.html#/index">地址</a></li>
</ol>

<h4 id="问题总结收获如下">问题总结收获如下：</h4>

<ol>
<li><p>苹果手机滚动不流畅问题<br />
解决方法：<code>-webkit-overflow-scrolling: touch;</code></p></li>

<li><p>上下滚动的轮播图
现象：疫情地图项目首页，有一个展示疫情资讯的轮播图。使用了vant的swipe轮播组件，遇到一个问题，随着滚动次数的增多，就会出现越来越大的偏移。</p></li>
</ol>

<p>问题定位：通过定位问题发现，轮播图每次往上滚动的距离是 36.421875px，实际我们使用的是rem，rem的换算导致出现到小数点的距离，所以每次滚动都会出现偏移量，随着次数的增多，越来越明显。</p>

<p>问题解决：更换了两次swipe组件后终于好了。  <code>vue-awesome-swiper</code>  <a href="https://github.com/surmon-china/vue-awesome-swiper">传送门</a> 点个赞~~~</p>

<ol>
<li>dom没有渲染
现象：疫情项目首页，疫情地图tab，有一个本地疫情的卡片，前端获取到当前城市后，数据变了，但是页面没有改变。(PS:此处逻辑是前端调用后端接口获取定位，如果获取到定位，就展示当前定位城市的疫情，否则不展示。)</li>
</ol>

<p>问题定位：vue中的数据变了，但是页面中没有更新。</p>

<p>问题解决：强制重新渲染 <code>this.$forceUpdate()</code></p>

<ol>
<li>两个span标签 同一行显示问题
现象：疫情项目，同行程查询页面。  其他及其后面的文字，都是用的是span标签。在设置了<code>display: inline-block;</code>后，其他及其后面的文字在后面的文字超出一行的时候，就不会同一行显示了。</li>
</ol>

<p>问题解决：设置 <code>display: inline-block;</code> 为 <code>display: inline;</code> 或者说不设置就不会有这个问题。(PS:当时是另一个同事写的)</p>

<p>PS: css也不简单</p>

<ol>
<li>vue中监听对象的某个属性</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">computed</span><span class="o">:</span> <span class="p">{</span>
  <span class="nx">urlHead</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">projectInfo</span><span class="p">.</span><span class="nx">urlHead</span>
  <span class="p">}</span>
<span class="p">},</span>
<span class="nx">watch</span><span class="o">:</span> <span class="p">{</span>
  <span class="nx">urlHead</span><span class="p">(</span><span class="nx">newVal</span><span class="p">,</span> <span class="nx">oldVal</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">servicePrefixListLabel</span><span class="o">=</span><span class="k">this</span><span class="p">.</span><span class="nx">projectInfo</span><span class="p">.</span><span class="nx">urlHead</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s1">&#39;://{host}:&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">host</span><span class="o">=</span><span class="k">this</span><span class="p">.</span><span class="nx">projectInfo</span><span class="p">.</span><span class="nx">urlHead</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s1">&#39;://{host}:&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
  <span class="p">},</span>
<span class="p">}</span>
</code></pre></div>
<ol>
<li>vue移动端项目粘贴功能</li>
</ol>

<p>问题描述：刚开始使用的是 <code>clipboard</code>这个包，但是遇到了一些问题。按钮的点击事件根据情况，可以复制，也可以跳转页面。</p>

<p>问题处理：换了使用<code>vue-clipboard2</code>这个包。</p>
]]></content>
		</item>
		
		<item>
			<title>小结</title>
			<link>https://caychance.github.io/posts/%E5%B0%8F%E7%BB%93/</link>
			<pubDate>Tue, 26 Nov 2019 19:16:39 +0800</pubDate>
			
			<guid>https://caychance.github.io/posts/%E5%B0%8F%E7%BB%93/</guid>
			<description>最近开发的过程中遇到一些之前没有遇到过的写法，记录一下。
 使用 install 方法写一个插件，全局使用。  import table from &amp;#39;./src/table&amp;#39;; /* istanbul ignore next */ table.install = function(Vue) { Vue.component(table.name, table); }; export default table;  main.js 中引入一次
import Vue from &amp;#39;vue&amp;#39; import defaultTable from &amp;#39;@/components/table&amp;#39; Vue.use(defaultTable)   main.js中new Vue的写法  ... new Vue({ el: &amp;#39;#app&amp;#39;, store, data: { busEvent: new Vue() //用于组件通信  }, router, components: { App }, template: &amp;#39;&amp;lt;App/&amp;gt;&amp;#39;, created() { this.getLoginInfo() }, methods: { getLoginInfo(){ this.</description>
			<content type="html"><![CDATA[<hr />

<p>最近开发的过程中遇到一些之前没有遇到过的写法，记录一下。</p>

<ol>
<li>使用 install 方法写一个插件，全局使用。</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="k">import</span> <span class="nx">table</span> <span class="nx">from</span> <span class="s1">&#39;./src/table&#39;</span><span class="p">;</span>

<span class="cm">/* istanbul ignore next */</span>
<span class="nx">table</span><span class="p">.</span><span class="nx">install</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">Vue</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">Vue</span><span class="p">.</span><span class="nx">component</span><span class="p">(</span><span class="nx">table</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span> <span class="nx">table</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">table</span><span class="p">;</span>
</code></pre></div>
<p>main.js 中引入一次</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="k">import</span> <span class="nx">Vue</span> <span class="nx">from</span> <span class="s1">&#39;vue&#39;</span>
<span class="k">import</span> <span class="nx">defaultTable</span> <span class="nx">from</span> <span class="s1">&#39;@/components/table&#39;</span>

<span class="nx">Vue</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">defaultTable</span><span class="p">)</span>
</code></pre></div>
<ol>
<li>main.js中new Vue的写法</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="p">...</span>

<span class="k">new</span> <span class="nx">Vue</span><span class="p">({</span>
  <span class="nx">el</span><span class="o">:</span> <span class="s1">&#39;#app&#39;</span><span class="p">,</span>
  <span class="nx">store</span><span class="p">,</span>
  <span class="nx">data</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">busEvent</span><span class="o">:</span> <span class="k">new</span> <span class="nx">Vue</span><span class="p">()</span> <span class="c1">//用于组件通信
</span><span class="c1"></span>  <span class="p">},</span>
  <span class="nx">router</span><span class="p">,</span>
  <span class="nx">components</span><span class="o">:</span> <span class="p">{</span> <span class="nx">App</span> <span class="p">},</span>
  <span class="nx">template</span><span class="o">:</span> <span class="s1">&#39;&lt;App/&gt;&#39;</span><span class="p">,</span>
  <span class="nx">created</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">getLoginInfo</span><span class="p">()</span>
  <span class="p">},</span>
  <span class="nx">methods</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">getLoginInfo</span><span class="p">(){</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">$get</span><span class="p">(</span><span class="s1">&#39;./admin/getUserInfo&#39;</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">res</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">$store</span><span class="p">.</span><span class="nx">commit</span><span class="p">(</span><span class="s1">&#39;setStateCommon&#39;</span><span class="p">,</span> <span class="p">{</span><span class="nx">key</span><span class="o">:</span> <span class="s1">&#39;user&#39;</span><span class="p">,</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">res</span><span class="p">})</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">$store</span><span class="p">.</span><span class="nx">dispatch</span><span class="p">(</span><span class="s1">&#39;updateMenulist&#39;</span><span class="p">,</span> <span class="p">{</span><span class="nx">userName</span><span class="o">:</span> <span class="nx">res</span><span class="p">.</span><span class="nx">userName</span><span class="p">,</span> <span class="nx">userId</span><span class="o">:</span> <span class="nx">res</span><span class="p">.</span><span class="nx">userId</span><span class="p">})</span>
      <span class="p">})</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">})</span>
</code></pre></div>
<ol>
<li>添加Vue方法实例
``` js
import echarts from &lsquo;echarts&rsquo;</li>
</ol>

<p>Vue.prototype.$echarts = echarts</p>

<p>// 其他页面调用
this.$echarts.xxx
```</p>
]]></content>
		</item>
		
		<item>
			<title>滚动穿透处理方案</title>
			<link>https://caychance.github.io/posts/%E6%BB%9A%E5%8A%A8%E7%A9%BF%E9%80%8F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/</link>
			<pubDate>Mon, 11 Nov 2019 20:55:09 +0800</pubDate>
			
			<guid>https://caychance.github.io/posts/%E6%BB%9A%E5%8A%A8%E7%A9%BF%E9%80%8F%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/</guid>
			<description>之前看到过一些关于滚动穿透和点击穿透的文章，一般滚动穿透会比较常见，但是点击穿透却不怎么常见。之前的产品也没有要求过处理滚动穿透，所以也就没怎么处理过。
先说下业务场景：当前浏览的页面很长，是可以滚动的。页面上会出现弹框，弹框还可以滚动，这个时候就会有滚动穿透的问题了。
网上找到了一个思路特别简单的方法：弹窗打开的时候，给body设置 position: fixed;width: 100%;top: 0px;，让body脱离文档流，这个时候页面就不能滚动，按时弹窗还是可以滚动的。等弹窗关闭的时候，再把body设置恢复就行了。
贴上一个demo：如下。由于页面中遇到了3，4个遮罩层。所以就没有给每个click去添加，而且监测遮罩层的打开关闭——即变量layerShow。layerShow等于true即遮罩被打开的时候，获取dom的scrollTop，然后设置body的样式为position: fixed;width: 100%;top: ${-this.sctop}px;。当layerShow等于false即遮罩被关闭的时候，设置body样式恢复原状，然后让页面滚动到原来的位置window.scrollTo(0, this.sctop)
&amp;lt;template&amp;gt; &amp;lt;div id=&amp;#34;blackbox&amp;#34; v-show=&amp;#34;layerShow&amp;#34; class=&amp;#34;layer&amp;#34;&amp;gt; &amp;lt;div @click=&amp;#34;closeLayer&amp;#34; class=&amp;#34;layer-bg&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;slot-wrapper&amp;#34;&amp;gt; &amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; export default { data() { return { sctop: 0 }; }, props: { layerShow: { type: Boolean, default: false } }, watch: { layerShowValue(newValue, oldValue) { if(newValue) { this.sctop = document.body.scrollTop || document.documentElement.scrollTop document.body.style.cssText = `position: fixed;width: 100%;top: ${-this .sctop}px;`; } else { document.</description>
			<content type="html"><![CDATA[<hr />

<p>之前看到过一些关于滚动穿透和点击穿透的文章，一般滚动穿透会比较常见，但是点击穿透却不怎么常见。之前的产品也没有要求过处理滚动穿透，所以也就没怎么处理过。</p>

<p>先说下业务场景：当前浏览的页面很长，是可以滚动的。页面上会出现弹框，弹框还可以滚动，这个时候就会有滚动穿透的问题了。</p>

<p>网上找到了一个思路特别简单的方法：弹窗打开的时候，给body设置 <code>position: fixed;width: 100%;top: 0px;</code>，让body脱离文档流，这个时候页面就不能滚动，按时弹窗还是可以滚动的。等弹窗关闭的时候，再把body设置恢复就行了。</p>

<p>贴上一个demo：如下。由于页面中遇到了3，4个遮罩层。所以就没有给每个click去添加，而且监测遮罩层的打开关闭——即变量layerShow。layerShow等于true即遮罩被打开的时候，获取dom的scrollTop，然后设置body的样式为<code>position: fixed;width: 100%;top: ${-this.sctop}px;</code>。当layerShow等于false即遮罩被关闭的时候，设置body样式恢复原状，然后让页面滚动到原来的位置<code>window.scrollTo(0, this.sctop)</code></p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">template</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">&#34;blackbox&#34;</span> <span class="na">v-show</span><span class="o">=</span><span class="s">&#34;layerShow&#34;</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;layer&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">div</span> <span class="err">@</span><span class="na">click</span><span class="o">=</span><span class="s">&#34;closeLayer&#34;</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;layer-bg&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;slot-wrapper&#34;</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">slot</span><span class="p">&gt;&lt;/</span><span class="nt">slot</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">template</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="k">export</span> <span class="k">default</span> <span class="p">{</span>
  <span class="nx">data</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="nx">sctop</span><span class="o">:</span> <span class="mi">0</span>
    <span class="p">};</span>
  <span class="p">},</span>
  <span class="nx">props</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">layerShow</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">type</span><span class="o">:</span> <span class="nb">Boolean</span><span class="p">,</span>
      <span class="k">default</span><span class="o">:</span> <span class="kc">false</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="nx">watch</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">layerShowValue</span><span class="p">(</span><span class="nx">newValue</span><span class="p">,</span> <span class="nx">oldValue</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">newValue</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">sctop</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">scrollTop</span> <span class="o">||</span> <span class="nb">document</span><span class="p">.</span><span class="nx">documentElement</span><span class="p">.</span><span class="nx">scrollTop</span>
        <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">cssText</span> <span class="o">=</span> <span class="sb">`position: fixed;width: 100%;top: </span><span class="si">${</span><span class="o">-</span><span class="k">this</span>
          <span class="p">.</span><span class="nx">sctop</span><span class="si">}</span><span class="sb">px;`</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">cssText</span> <span class="o">=</span> <span class="s2">&#34;&#34;</span><span class="p">;</span>
        <span class="nb">window</span><span class="p">.</span><span class="nx">scrollTo</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">sctop</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="nx">computed</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">layerShowValue</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">layerShow</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="nx">methods</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">closeLayer</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">$emit</span><span class="p">(</span><span class="s2">&#34;closeLayer&#34;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="nt">style</span> <span class="na">lang</span><span class="o">=</span><span class="s">&#39;scss&#39;</span> <span class="na">scoped</span><span class="p">&gt;</span>
<span class="p">.</span><span class="nc">layer</span> <span class="p">{</span>
  <span class="k">position</span><span class="p">:</span> <span class="kc">fixed</span><span class="p">;</span>
  <span class="k">top</span><span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">left</span><span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">width</span><span class="p">:</span> <span class="mi">750</span><span class="kt">px</span><span class="p">;</span>
  <span class="k">height</span><span class="p">:</span> <span class="mi">100</span><span class="kt">vh</span><span class="p">;</span>
  <span class="err">.layer-bg</span> <span class="err">{</span>
    <span class="k">background</span><span class="p">:</span> <span class="mh">#000</span><span class="p">;</span>
    <span class="k">opacity</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">;</span>
    <span class="k">width</span><span class="p">:</span> <span class="mi">100</span><span class="kt">%</span><span class="p">;</span>
    <span class="k">height</span><span class="p">:</span> <span class="mi">100</span><span class="kt">%</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="p">.</span><span class="nc">slot-wrapper</span> <span class="p">{</span>
    <span class="k">position</span><span class="p">:</span> <span class="kc">absolute</span><span class="p">;</span>
    <span class="k">top</span><span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">left</span><span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
<span class="err">}</span>
<span class="p">&lt;/</span><span class="nt">style</span><span class="p">&gt;</span></code></pre></div>]]></content>
		</item>
		
		<item>
			<title>IView使用中遇到的一些坑</title>
			<link>https://caychance.github.io/posts/iview%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</link>
			<pubDate>Thu, 31 Oct 2019 11:53:35 +0800</pubDate>
			
			<guid>https://caychance.github.io/posts/iview%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</guid>
			<description>最近开发中使用iView遇到了一个问题，困扰了很久。使用了iView的Modal组件和Form组件。
问题总结 iView的Modal组件中暴露两个事件——点击确定和取消的回调。@on-ok和@on-cancel。如果Modal中嵌入表单并且表单需要校验的话，不可以使用Modal提供的on-ok方法。需要自己加一个Button单独添加事件来处理。
&amp;lt;Modal title=&amp;#34;修改名称&amp;#34; v-model=&amp;#34;setAliasModal&amp;#34; :mask-closable=&amp;#34;false&amp;#34; @on-cancel=&amp;#34;resetSetAlias&amp;#34;&amp;gt; &amp;lt;Form ref=&amp;#34;setalias&amp;#34; :model=&amp;#34;setAliasData&amp;#34; :label-width=&amp;#34;80&amp;#34; :rules=&amp;#34;aliasrules&amp;#34;&amp;gt; &amp;lt;FormItem label=&amp;#34;方法名称&amp;#34; prop=&amp;#34;aliasName&amp;#34;&amp;gt; &amp;lt;Input v-model=&amp;#34;setAliasData.aliasName&amp;#34; :maxlength=&amp;#34;25&amp;#34; placeholder=&amp;#34;请输入新的方法名(最长不超过25)&amp;#34;&amp;gt;&amp;lt;/Input&amp;gt; &amp;lt;/FormItem&amp;gt; &amp;lt;/Form&amp;gt; &amp;lt;template slot=&amp;#34;footer&amp;#34;&amp;gt; &amp;lt;Button type=&amp;#34;text&amp;#34; @click=&amp;#34;resetSetAlias&amp;#34;&amp;gt;取消&amp;lt;/Button&amp;gt; &amp;lt;Button type=&amp;#34;primary&amp;#34; @click=&amp;#34;setAliasHandleSubmit&amp;#34;&amp;gt;保存&amp;lt;/Button&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;/Modal&amp;gt; 需求描述 需求是Modal组件中嵌套Form组件，需要进行表单规则校验，如果校验通过，则关闭Modal进行后续逻辑；如果校验不通过，那么Modal不能关闭，提示用户规则校验不通过。
Form表单提供了 this.$refs[&amp;quot;xxx&amp;quot;].validate 方法来校验规则。
如果使用Modal提供的@on-ok事件来处理的话，不管校验是否通过，都会默认关闭Modal的。
所以处理的方法，是不要使用Modal提供的@on-ok方法，自己写两个Button来分别处理取消和确定的事件。</description>
			<content type="html"><![CDATA[

<hr />

<p>最近开发中使用iView遇到了一个问题，困扰了很久。使用了iView的Modal组件和Form组件。</p>

<h3 id="问题总结">问题总结</h3>

<p>iView的Modal组件中暴露两个事件——点击确定和取消的回调。<code>@on-ok</code>和<code>@on-cancel</code>。如果Modal中嵌入表单并且表单需要校验的话，不可以使用Modal提供的<code>on-ok</code>方法。需要自己加一个Button单独添加事件来处理。</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">Modal</span> 
  <span class="na">title</span><span class="o">=</span><span class="s">&#34;修改名称&#34;</span> 
  <span class="na">v-model</span><span class="o">=</span><span class="s">&#34;setAliasModal&#34;</span> 
  <span class="na">:mask-closable</span><span class="o">=</span><span class="s">&#34;false&#34;</span>
  <span class="err">@</span><span class="na">on-cancel</span><span class="o">=</span><span class="s">&#34;resetSetAlias&#34;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">Form</span> <span class="na">ref</span><span class="o">=</span><span class="s">&#34;setalias&#34;</span> <span class="na">:model</span><span class="o">=</span><span class="s">&#34;setAliasData&#34;</span> <span class="na">:label-width</span><span class="o">=</span><span class="s">&#34;80&#34;</span> <span class="na">:rules</span><span class="o">=</span><span class="s">&#34;aliasrules&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">FormItem</span> <span class="na">label</span><span class="o">=</span><span class="s">&#34;方法名称&#34;</span> <span class="na">prop</span><span class="o">=</span><span class="s">&#34;aliasName&#34;</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">Input</span> <span class="na">v-model</span><span class="o">=</span><span class="s">&#34;setAliasData.aliasName&#34;</span> <span class="na">:maxlength</span><span class="o">=</span><span class="s">&#34;25&#34;</span> <span class="na">placeholder</span><span class="o">=</span><span class="s">&#34;请输入新的方法名(最长不超过25)&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">Input</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">FormItem</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">Form</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">template</span> <span class="na">slot</span><span class="o">=</span><span class="s">&#34;footer&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">Button</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;text&#34;</span> <span class="err">@</span><span class="na">click</span><span class="o">=</span><span class="s">&#34;resetSetAlias&#34;</span><span class="p">&gt;</span>取消<span class="p">&lt;/</span><span class="nt">Button</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">Button</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;primary&#34;</span> <span class="err">@</span><span class="na">click</span><span class="o">=</span><span class="s">&#34;setAliasHandleSubmit&#34;</span><span class="p">&gt;</span>保存<span class="p">&lt;/</span><span class="nt">Button</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">template</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">Modal</span><span class="p">&gt;</span></code></pre></div>
<h3 id="需求描述">需求描述</h3>

<p>需求是Modal组件中嵌套Form组件，需要进行表单规则校验，如果校验通过，则关闭Modal进行后续逻辑；如果校验不通过，那么Modal不能关闭，提示用户规则校验不通过。</p>

<p>Form表单提供了 <code>this.$refs[&quot;xxx&quot;].validate</code> 方法来校验规则。</p>

<p><span style="color: red">如果使用Modal提供的<code>@on-ok</code>事件来处理的话，不管校验是否通过，都会默认关闭Modal的。</span></p>

<p>所以处理的方法，是不要使用Modal提供的@on-ok方法，自己写两个Button来分别处理取消和确定的事件。</p>
]]></content>
		</item>
		
		<item>
			<title>如何给Highchart折线图添加阴影</title>
			<link>https://caychance.github.io/posts/%E5%A6%82%E4%BD%95%E7%BB%99highchart%E6%8A%98%E7%BA%BF%E5%9B%BE%E6%B7%BB%E5%8A%A0%E9%98%B4%E5%BD%B1/</link>
			<pubDate>Thu, 31 Oct 2019 11:52:54 +0800</pubDate>
			
			<guid>https://caychance.github.io/posts/%E5%A6%82%E4%BD%95%E7%BB%99highchart%E6%8A%98%E7%BA%BF%E5%9B%BE%E6%B7%BB%E5%8A%A0%E9%98%B4%E5%BD%B1/</guid>
			<description>最近遇到一些使用Highcharts开发图表的需求，需要把图表设置成带shadow的。类似这样子的效果：
由于英文不太好，中文文档又不太齐全。害得我花了好半天的时间。配置在倒数第7行的代码
// 设置如下 { chart: { events: { // 加载页面的时候绘制一些按钮之类的东西  load: function(event) { let x = event.target.chartWidth * 0.5; this.flashText = this.renderer .text( `&amp;lt;div align=&amp;#34;right&amp;#34; &amp;gt;&amp;lt;div id=&amp;#34;${item.key}&amp;#34; style=&amp;#34;display:none;&amp;#34;&amp;gt;&amp;lt;button style=&amp;#34;height:31px;width:84px;background:&amp;#34;#f7f7f7&amp;#34; class=&amp;#34;btn green pull-right&amp;#34; data-toggle=&amp;#34;modal&amp;#34;&amp;gt;&amp;lt;font size=&amp;#34;2&amp;#34;&amp;gt;&amp;lt;b&amp;gt;detail info&amp;lt;/b&amp;gt;&amp;lt;/font&amp;gt;&amp;lt;/button&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;`, x + 100, 20, true ) .attr({ zIndex: 101 }) .add(); }, // 图表放大的时候  selection: event =&amp;gt; { if (event.xAxis) { let btn = document.getElementById(`${item.key}`); btn.style.display = &amp;#34;block&amp;#34;; btn.removeEventListener(&amp;#34;click&amp;#34;, this.detailInfo); let min = Math.</description>
			<content type="html"><![CDATA[<hr />

<p>最近遇到一些使用Highcharts开发图表的需求，需要把图表设置成带shadow的。类似这样子的效果：</p>

<p><img src="https://blog-pics.pek3b.qingstor.com/412803b3-c06b-4f7c-9a26-4011976f8dc1.png" alt="" /></p>

<p>由于英文不太好，中文文档又不太齐全。害得我花了好半天的时间。配置在倒数第7行的代码</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// 设置如下
</span><span class="c1"></span><span class="p">{</span>
  <span class="nx">chart</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">events</span><span class="o">:</span> <span class="p">{</span>
      <span class="c1">// 加载页面的时候绘制一些按钮之类的东西
</span><span class="c1"></span>      <span class="nx">load</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">chartWidth</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">;</span>

        <span class="k">this</span><span class="p">.</span><span class="nx">flashText</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">renderer</span>
          <span class="p">.</span><span class="nx">text</span><span class="p">(</span>
            <span class="sb">`&lt;div align=&#34;right&#34; &gt;&lt;div id=&#34;</span><span class="si">${</span><span class="nx">item</span><span class="p">.</span><span class="nx">key</span><span class="si">}</span><span class="sb">&#34; style=&#34;display:none;&#34;&gt;&lt;button  style=&#34;height:31px;width:84px;background:&#34;#f7f7f7&#34; class=&#34;btn green pull-right&#34; data-toggle=&#34;modal&#34;&gt;&lt;font size=&#34;2&#34;&gt;&lt;b&gt;detail info&lt;/b&gt;&lt;/font&gt;&lt;/button&gt;&lt;/div&gt;&lt;/div&gt;`</span><span class="p">,</span>
            <span class="nx">x</span> <span class="o">+</span> <span class="mi">100</span><span class="p">,</span>
            <span class="mi">20</span><span class="p">,</span>
            <span class="kc">true</span>
          <span class="p">)</span>
          <span class="p">.</span><span class="nx">attr</span><span class="p">({</span>
            <span class="nx">zIndex</span><span class="o">:</span> <span class="mi">101</span>
          <span class="p">})</span>
          <span class="p">.</span><span class="nx">add</span><span class="p">();</span>
      <span class="p">},</span>
      <span class="c1">// 图表放大的时候
</span><span class="c1"></span>      <span class="nx">selection</span><span class="o">:</span> <span class="nx">event</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">xAxis</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">let</span> <span class="nx">btn</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="nx">item</span><span class="p">.</span><span class="nx">key</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
          <span class="nx">btn</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">display</span> <span class="o">=</span> <span class="s2">&#34;block&#34;</span><span class="p">;</span>
          <span class="nx">btn</span><span class="p">.</span><span class="nx">removeEventListener</span><span class="p">(</span><span class="s2">&#34;click&#34;</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">detailInfo</span><span class="p">);</span>
          <span class="kd">let</span> <span class="nx">min</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">xAxis</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">min</span><span class="p">);</span>
          <span class="kd">let</span> <span class="nx">max</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">ceil</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">xAxis</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">max</span><span class="p">);</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">startTime</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getLogTimeWidthYearMonthDay</span><span class="p">[</span><span class="nx">min</span><span class="p">];</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">endTime</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getLogTimeWidthYearMonthDay</span><span class="p">[</span><span class="nx">max</span><span class="p">];</span>
          <span class="nx">btn</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s2">&#34;click&#34;</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">detailInfo</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">},</span>
    <span class="nx">zoomType</span><span class="o">:</span> <span class="s2">&#34;x&#34;</span>
  <span class="p">},</span>
  <span class="nx">title</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">text</span><span class="o">:</span> <span class="nx">item</span><span class="p">.</span><span class="nx">title</span>
  <span class="p">},</span>
  <span class="nx">subtitle</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">text</span><span class="o">:</span>
      <span class="nb">document</span><span class="p">.</span><span class="nx">ontouchstart</span> <span class="o">===</span> <span class="kc">undefined</span>
        <span class="o">?</span> <span class="s2">&#34;鼠标拖动可以进行缩放&#34;</span>
        <span class="o">:</span> <span class="s2">&#34;手势操作进行缩放&#34;</span>
  <span class="p">},</span>
  <span class="nx">xAxis</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">categories</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">getLogTime</span>
  <span class="p">},</span>
  <span class="nx">tooltip</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">dateTimeLabelFormats</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">millisecond</span><span class="o">:</span> <span class="s2">&#34;%H:%M:%S.%L&#34;</span><span class="p">,</span>
      <span class="nx">second</span><span class="o">:</span> <span class="s2">&#34;%H:%M:%S&#34;</span><span class="p">,</span>
      <span class="nx">minute</span><span class="o">:</span> <span class="s2">&#34;%H:%M&#34;</span><span class="p">,</span>
      <span class="nx">hour</span><span class="o">:</span> <span class="s2">&#34;%H:%M&#34;</span><span class="p">,</span>
      <span class="nx">day</span><span class="o">:</span> <span class="s2">&#34;%Y-%m-%d&#34;</span><span class="p">,</span>
      <span class="nx">week</span><span class="o">:</span> <span class="s2">&#34;%m-%d&#34;</span><span class="p">,</span>
      <span class="nx">month</span><span class="o">:</span> <span class="s2">&#34;%Y-%m&#34;</span><span class="p">,</span>
      <span class="nx">year</span><span class="o">:</span> <span class="s2">&#34;%Y&#34;</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="nx">yAxis</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">title</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">text</span><span class="o">:</span> <span class="nx">item</span><span class="p">.</span><span class="nx">yAxisName</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="nx">legend</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">enabled</span><span class="o">:</span> <span class="kc">false</span>
  <span class="p">},</span>
  <span class="nx">plotOptions</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">area</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">fillColor</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">linearGradient</span><span class="o">:</span> <span class="p">{</span>
          <span class="nx">x1</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
          <span class="nx">y1</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
          <span class="nx">x2</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
          <span class="nx">y2</span><span class="o">:</span> <span class="mi">1</span>
        <span class="p">},</span>
        <span class="nx">stops</span><span class="o">:</span> <span class="p">[</span>
          <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="nx">Highcharts</span><span class="p">.</span><span class="nx">getOptions</span><span class="p">().</span><span class="nx">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
          <span class="p">[</span>
            <span class="mi">1</span><span class="p">,</span>
            <span class="nx">Highcharts</span><span class="p">.</span><span class="nx">Color</span><span class="p">(</span><span class="nx">Highcharts</span><span class="p">.</span><span class="nx">getOptions</span><span class="p">().</span><span class="nx">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
              <span class="p">.</span><span class="nx">setOpacity</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
              <span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">&#34;rgba&#34;</span><span class="p">)</span>
          <span class="p">]</span>
        <span class="p">]</span>
      <span class="p">},</span>
      <span class="nx">marker</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">radius</span><span class="o">:</span> <span class="mi">1</span>
      <span class="p">},</span>
      <span class="nx">lineWidth</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">states</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">hover</span><span class="o">:</span> <span class="p">{</span>
          <span class="nx">lineWidth</span><span class="o">:</span> <span class="mi">1</span>
        <span class="p">}</span>
      <span class="p">},</span>
      <span class="nx">threshold</span><span class="o">:</span> <span class="kc">null</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="nx">series</span><span class="o">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="c1">// 此处设置type等于area就可以应用plotOptions中area的属性了
</span><span class="c1"></span>      <span class="nx">type</span><span class="o">:</span> <span class="s2">&#34;area&#34;</span><span class="p">,</span>
      <span class="nx">data</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">chartData</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">it</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">it</span><span class="p">[</span><span class="nx">item</span><span class="p">.</span><span class="nx">key</span><span class="p">];</span>
      <span class="p">})</span>
    <span class="p">}</span>
  <span class="p">]</span>
<span class="p">};</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Vue中v-for之key</title>
			<link>https://caychance.github.io/posts/vue%E4%B8%ADv-for%E4%B9%8Bkey/</link>
			<pubDate>Wed, 23 Oct 2019 20:02:37 +0800</pubDate>
			
			<guid>https://caychance.github.io/posts/vue%E4%B8%ADv-for%E4%B9%8Bkey/</guid>
			<description>最近的在帮别人维护代码的过程中遇到一个bug。使用v-for循环的时候，key设置的是index。
业务需求需要使用splice对数组进行删减，然后发现在删除数据的时候，页面上显示的还是的删除前的数据。后来定位发现问题是因为key设置的不对从而导致的bug。
之前写过一篇diff算法的——diff算法。 
提到过为什么一定要设置key，设置了key就会复用。具有相同key的dom都会复用，这样子就会大大的提高性能。
但是平时设置的时候看到很多时候直接使用index的，这种情况下，不删除数据还好，一旦需要删除数据，就会有上述的问题出现。
之前在掘金上看到过一篇文章说有的大公司后台是需要专门给前端返回的list中加一个唯一的id让前端当做key来用。
如果没有这样的话，可以使用 :key=&amp;quot;index+JSON.stringify(item)&amp;quot; 这样子来使用，可以保证key的唯一性。</description>
			<content type="html"><![CDATA[<hr />

<p>最近的在帮别人维护代码的过程中遇到一个bug。使用v-for循环的时候，key设置的是index。</p>

<p>业务需求需要使用splice对数组进行删减，然后发现在删除数据的时候，页面上显示的还是的删除前的数据。后来定位发现问题是因为key设置的不对从而导致的bug。</p>

<p>之前写过一篇diff算法的——<a href="https://caychance.github.io/posts/diff%E7%AE%97%E6%B3%95/#%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E7%BD%AEkey">diff算法。
</a></p>

<p>提到过为什么一定要设置key，设置了key就会复用。具有相同key的dom都会复用，这样子就会大大的提高性能。</p>

<p>但是平时设置的时候看到很多时候直接使用index的，这种情况下，不删除数据还好，一旦需要删除数据，就会有上述的问题出现。</p>

<p>之前在掘金上看到过一篇文章说有的大公司后台是需要专门给前端返回的list中加一个唯一的id让前端当做key来用。</p>

<p>如果没有这样的话，可以使用 <code>:key=&quot;index+JSON.stringify(item)&quot;</code> 这样子来使用，可以保证key的唯一性。</p>
]]></content>
		</item>
		
		<item>
			<title>修改elementUI样式</title>
			<link>https://caychance.github.io/posts/%E4%BF%AE%E6%94%B9elementui%E6%A0%B7%E5%BC%8F/</link>
			<pubDate>Sat, 12 Oct 2019 19:06:29 +0800</pubDate>
			
			<guid>https://caychance.github.io/posts/%E4%BF%AE%E6%94%B9elementui%E6%A0%B7%E5%BC%8F/</guid>
			<description>最近做一个需求，需要把之前写的系统样式全部修改成统一的设计样式。
由于之前的系统是使用element-ui做的，本身用的element-ui的组件不多，基本都是table,select,input等几个标签。
有两种思路：
 不考虑scoped的话，在全局写一个element-ui的样式，xxx.css或者xxx.scss，在全局引入该文件。
 考虑scoped的话，可以使用 /deep/ 或者 &amp;gt;&amp;gt;&amp;gt; 操作符。
  因为开发的系统基本全部使用的element-ui的样式，基本没有自己写css，所以可以使用方法1。
使用 &amp;gt;&amp;gt;&amp;gt; 或者 /deep/ 示例
&amp;lt;style lang=&amp;#34;scss&amp;#34; scoped&amp;gt; .home { // *** } .home /deep/ .skeleton{ background: red; /deep/ .header { background: pink; } /deep/ .like-wrapper { background: #fff; /deep/ .title{ /deep/ .img{ border: 1px solid red; } /deep/ .text{ width: 300px; border-top: 1px solid green; } } } } &amp;lt;/style&amp;gt;</description>
			<content type="html"><![CDATA[<hr />

<p>最近做一个需求，需要把之前写的系统样式全部修改成统一的设计样式。</p>

<p>由于之前的系统是使用element-ui做的，本身用的element-ui的组件不多，基本都是table,select,input等几个标签。</p>

<p>有两种思路：</p>

<ol>
<li><p>不考虑scoped的话，在全局写一个element-ui的样式，xxx.css或者xxx.scss，在全局引入该文件。</p></li>

<li><p>考虑scoped的话，可以使用 /deep/ 或者 &gt;&gt;&gt; 操作符。</p></li>
</ol>

<p>因为开发的系统基本全部使用的element-ui的样式，基本没有自己写css，所以可以使用方法1。</p>

<p>使用 &gt;&gt;&gt; 或者 /deep/ 示例</p>
<div class="highlight"><pre class="chroma"><code class="language-scss" data-lang="scss"><span class="o">&lt;</span><span class="nt">style</span> <span class="nt">lang</span><span class="o">=</span><span class="s2">&#34;scss&#34;</span> <span class="nt">scoped</span><span class="o">&gt;</span>
<span class="nc">.home</span> <span class="p">{</span>
  <span class="c1">// ***
</span><span class="c1"></span><span class="p">}</span>
<span class="nc">.home</span> <span class="o">/</span><span class="nt">deep</span><span class="o">/</span> <span class="nc">.skeleton</span><span class="p">{</span>
  <span class="nt">background</span><span class="nd">:</span> <span class="nt">red</span><span class="o">;</span>
  <span class="o">/</span><span class="nt">deep</span><span class="o">/</span> <span class="nc">.header</span> <span class="p">{</span>
    <span class="nt">background</span><span class="nd">:</span> <span class="nt">pink</span><span class="o">;</span>
  <span class="p">}</span>
  <span class="o">/</span><span class="nt">deep</span><span class="o">/</span> <span class="nc">.like-wrapper</span> <span class="p">{</span>
    <span class="nt">background</span><span class="nd">:</span> <span class="nn">#fff</span><span class="o">;</span>
    <span class="o">/</span><span class="nt">deep</span><span class="o">/</span> <span class="nc">.title</span><span class="p">{</span>
      <span class="o">/</span><span class="nt">deep</span><span class="o">/</span> <span class="nc">.img</span><span class="p">{</span>
        <span class="nt">border</span><span class="nd">:</span> <span class="nt">1px</span> <span class="nt">solid</span> <span class="nt">red</span><span class="o">;</span>
      <span class="p">}</span>
      <span class="o">/</span><span class="nt">deep</span><span class="o">/</span> <span class="nc">.text</span><span class="p">{</span>
        <span class="nt">width</span><span class="nd">:</span> <span class="nt">300px</span><span class="o">;</span>
        <span class="nt">border-top</span><span class="nd">:</span> <span class="nt">1px</span> <span class="nt">solid</span> <span class="nt">green</span><span class="o">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="o">&lt;/</span><span class="nt">style</span><span class="o">&gt;</span></code></pre></div>]]></content>
		</item>
		
		<item>
			<title>代码分析</title>
			<link>https://caychance.github.io/posts/%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</link>
			<pubDate>Tue, 03 Sep 2019 20:41:46 +0800</pubDate>
			
			<guid>https://caychance.github.io/posts/%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</guid>
			<description>最近在和别的团队合作一个项目。看了别人的代码，感触特别多。代码写的特别优雅。
// flexbridge.js const FlexBridge = class { constructor(){ //桥接具体实现(自动依赖注入)  this.bridge = null // 前端的枚举类型  this.IOS = &amp;#34;ios&amp;#34; this.ANDROID = &amp;#34;android&amp;#34; this.UNKNOWN = &amp;#34;unknown&amp;#34; this.APP = &amp;#34;app&amp;#34; this.H5 = &amp;#34;h5&amp;#34; this.WEIXIN = &amp;#34;weixin&amp;#34; this.WXXCX = &amp;#34;wxxcx&amp;#34; this.QQ = &amp;#34;qq&amp;#34; //全局暴露，给静态页面使用  window[&amp;#34;FlexBridge&amp;#34;] = this } async _(method, args){ if(this.bridge === null){ let client = await this.getClientInfo().type let bridgeModule = null switch (client) { // 实现按需加载 根据不同的端 加载对应的实现类  case this.</description>
			<content type="html"><![CDATA[<hr />

<p>最近在和别的团队合作一个项目。看了别人的代码，感触特别多。代码写的特别优雅。</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// flexbridge.js
</span><span class="c1"></span><span class="k">const</span> <span class="nx">FlexBridge</span> <span class="o">=</span> <span class="k">class</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">(){</span>

    <span class="c1">//桥接具体实现(自动依赖注入)
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">bridge</span> <span class="o">=</span> <span class="kc">null</span>
    
    <span class="c1">// 前端的枚举类型
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">IOS</span> <span class="o">=</span> <span class="s2">&#34;ios&#34;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">ANDROID</span> <span class="o">=</span> <span class="s2">&#34;android&#34;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">UNKNOWN</span> <span class="o">=</span> <span class="s2">&#34;unknown&#34;</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">APP</span> <span class="o">=</span> <span class="s2">&#34;app&#34;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">H5</span> <span class="o">=</span> <span class="s2">&#34;h5&#34;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">WEIXIN</span> <span class="o">=</span> <span class="s2">&#34;weixin&#34;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">WXXCX</span> <span class="o">=</span> <span class="s2">&#34;wxxcx&#34;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">QQ</span> <span class="o">=</span> <span class="s2">&#34;qq&#34;</span>

    <span class="c1">//全局暴露，给静态页面使用
</span><span class="c1"></span>    <span class="nb">window</span><span class="p">[</span><span class="s2">&#34;FlexBridge&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span>
  <span class="p">}</span>

  <span class="kr">async</span> <span class="nx">_</span><span class="p">(</span><span class="nx">method</span><span class="p">,</span> <span class="nx">args</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">bridge</span> <span class="o">===</span> <span class="kc">null</span><span class="p">){</span>
      <span class="kd">let</span> <span class="nx">client</span> <span class="o">=</span> <span class="kr">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">getClientInfo</span><span class="p">().</span><span class="nx">type</span>
      <span class="kd">let</span> <span class="nx">bridgeModule</span> <span class="o">=</span> <span class="kc">null</span>
      <span class="k">switch</span> <span class="p">(</span><span class="nx">client</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 实现按需加载 根据不同的端 加载对应的实现类
</span><span class="c1"></span>        <span class="k">case</span> <span class="k">this</span><span class="p">.</span><span class="nx">APP</span><span class="o">:</span>
          <span class="nx">bridgeModule</span> <span class="o">=</span> <span class="k">import</span><span class="p">(</span> <span class="cm">/* webpackChunkName: &#34;bridge-app&#34; */</span> <span class="s1">&#39;./bridges/app.js&#39;</span><span class="p">)</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="k">this</span><span class="p">.</span><span class="nx">H5</span><span class="o">:</span>
          <span class="nx">bridgeModule</span> <span class="o">=</span> <span class="k">import</span><span class="p">(</span> <span class="cm">/* webpackChunkName: &#34;bridge-h5&#34; */</span> <span class="s1">&#39;./bridges/h5.js&#39;</span><span class="p">)</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="k">this</span><span class="p">.</span><span class="nx">WXXCX</span><span class="o">:</span>
        <span class="k">case</span> <span class="k">this</span><span class="p">.</span><span class="nx">WEIXIN</span><span class="o">:</span>
          <span class="nx">bridgeModule</span> <span class="o">=</span> <span class="k">import</span><span class="p">(</span> <span class="cm">/* webpackChunkName: &#34;bridge-weixin&#34; */</span> <span class="s1">&#39;./bridges/weixin.js&#39;</span><span class="p">)</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="k">default</span><span class="o">:</span>
          <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;Unknown Client&#39;</span><span class="p">)</span>
          <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">bridgeModule</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">bridgeModule</span>

    <span class="c1">// 实例化 具体的桥接
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">bridge</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">bridgeModule</span><span class="p">.</span><span class="k">default</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>

    <span class="c1">// 返回一个promise
</span><span class="c1"></span>    <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;{</span>
      <span class="c1">// 如果桥接中有该方法 
</span><span class="c1"></span>      <span class="k">if</span><span class="p">(</span><span class="nx">method</span> <span class="k">in</span> <span class="k">this</span><span class="p">.</span><span class="nx">bridge</span><span class="p">)</span>
        <span class="c1">// 把resolve、reject作为入参，和args一起传给bridge的method
</span><span class="c1"></span>        <span class="k">this</span><span class="p">.</span><span class="nx">bridge</span><span class="p">[</span><span class="nx">method</span><span class="p">].</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">bridge</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span>
      <span class="c1">// 如果没有 则抛出异常  
</span><span class="c1"></span>      <span class="k">else</span>
        <span class="nx">reject</span><span class="p">({</span>
          <span class="nx">code</span><span class="o">:</span> <span class="mi">99</span><span class="p">,</span>
          <span class="nx">message</span><span class="o">:</span> <span class="sb">`</span><span class="si">${</span><span class="nx">method</span><span class="si">}</span><span class="sb">尚未实现`</span>
        <span class="p">})</span>
    <span class="p">})</span>
  <span class="p">}</span>

  <span class="c1">// 获取系统信息
</span><span class="c1"></span>  <span class="nx">getOSInfo</span><span class="p">(){</span>
    <span class="kd">let</span> <span class="nx">ua</span> <span class="o">=</span> <span class="nx">navigator</span><span class="p">.</span><span class="nx">userAgent</span>
    <span class="kd">let</span> <span class="nx">type</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">UNKNOWN</span>

    <span class="k">if</span> <span class="p">(</span><span class="sr">/Android|Adr\s|Linux\sU|U\sLinux/i</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">ua</span><span class="p">))</span>
      <span class="nx">type</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">ANDROID</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="sr">/iPh(one)?\sOS|iOS/i</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">ua</span><span class="p">))</span>
      <span class="nx">type</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">IOS</span>

    <span class="kd">let</span> <span class="nx">info</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">type</span><span class="o">:</span> <span class="nx">type</span><span class="p">,</span>
      <span class="nx">version</span><span class="o">:</span> <span class="s2">&#34;&#34;</span> <span class="c1">//todo...
</span><span class="c1"></span>    <span class="p">}</span>

    <span class="c1">// 1. 返回立即执行函数
</span><span class="c1"></span>    <span class="c1">// 2. 给getOSInfo方法重新赋值为 info
</span><span class="c1"></span>    <span class="c1">// 3. 使用闭包 第二次调用就不用再次执行正则的判断了
</span><span class="c1"></span>    <span class="k">return</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">getOSInfo</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">info</span><span class="p">)()</span>
  <span class="p">}</span>

  <span class="c1">// 获取端信息
</span><span class="c1"></span>  <span class="nx">getClientInfo</span><span class="p">(){</span>
    <span class="kd">let</span> <span class="nx">ua</span> <span class="o">=</span> <span class="nx">navigator</span><span class="p">.</span><span class="nx">userAgent</span>
    <span class="kd">let</span> <span class="nx">type</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">H5</span>

    <span class="k">if</span><span class="p">(</span><span class="sr">/xxx/i</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">ua</span><span class="p">))</span> <span class="p">{</span>
      <span class="nx">type</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">APP</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="sr">/MicroMessenger/i</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">ua</span><span class="p">))</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="kc">null</span>
      <span class="k">try</span> <span class="p">{</span>
        <span class="nx">res</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">wx</span><span class="p">.</span><span class="nx">miniProgram</span><span class="p">.</span><span class="nx">getEnv</span><span class="p">()</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">res</span> <span class="o">&amp;&amp;</span> <span class="nx">res</span><span class="p">.</span><span class="nx">miniprogram</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">type</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">WXXCX</span>
        <span class="p">}</span> 
        <span class="k">else</span> <span class="p">{</span>
          <span class="nx">type</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">WEIXIN</span>
        <span class="p">}</span>
      <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">type</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">WEIXIN</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="sr">/QQ\//i</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">ua</span><span class="p">))</span> <span class="p">{</span>
      <span class="nx">type</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">QQ</span>
    <span class="p">}</span>

    <span class="kd">let</span> <span class="nx">info</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">type</span><span class="p">,</span>
      <span class="nx">version</span><span class="o">:</span> <span class="s2">&#34;预留字段&#34;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">getClientInfo</span> <span class="o">=</span> <span class="p">()=&gt;</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">info</span><span class="p">))()</span>
  <span class="p">}</span>

  <span class="c1">// 获取定位信息
</span><span class="c1"></span>  <span class="nx">getLocation</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_</span><span class="p">(</span><span class="s1">&#39;getLocation&#39;</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">)</span> <span class="p">}</span>

<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="k">new</span> <span class="nx">FlexBridge</span><span class="p">()</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// main.js
</span><span class="c1"></span><span class="k">import</span> <span class="nx">FlexBridge</span> <span class="nx">from</span> <span class="s2">&#34;flex-bridge&#34;</span>

<span class="nx">Vue</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">bridge</span> <span class="o">=</span> <span class="nx">FlexBridge</span>

<span class="c1">// xxx.vue 用户页面中调用
</span><span class="c1"></span><span class="k">this</span><span class="p">.</span><span class="nx">bridge</span><span class="p">.</span><span class="nx">getLocation</span><span class="p">({</span>
  <span class="nx">needAddress</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="nx">needPoi</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="nx">radius</span><span class="o">:</span> <span class="mi">1000</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="nx">data</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
<span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
<span class="p">})</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// h5.js
</span><span class="c1"></span><span class="k">class</span> <span class="nx">H5</span> <span class="o">=</span> <span class="k">class</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">(</span><span class="nx">flexbridge</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">flexbridge</span> <span class="o">=</span> <span class="nx">flexbridge</span>
  <span class="p">}</span>

  <span class="nx">getLocation</span><span class="p">(</span><span class="nx">args</span><span class="p">,</span> <span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="s1">&#39;geolocation&#39;</span> <span class="k">in</span> <span class="nx">navigator</span><span class="p">){</span>
      <span class="kd">let</span> <span class="p">{</span> <span class="nx">needAddress</span><span class="p">,</span> <span class="nx">needPoi</span><span class="p">,</span> <span class="nx">radius</span><span class="p">,</span> <span class="nx">bizType</span><span class="p">,</span> <span class="nx">uuid</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
      <span class="nx">navigator</span><span class="p">.</span><span class="nx">geolocation</span><span class="p">.</span><span class="nx">getCurrentPosition</span><span class="p">(</span><span class="nx">data</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">lat</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">coords</span><span class="p">.</span><span class="nx">latitude</span>
        <span class="kd">let</span> <span class="nx">lng</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">coords</span><span class="p">.</span><span class="nx">longitude</span>
        <span class="kd">let</span> <span class="nx">coordType</span> <span class="o">=</span> <span class="s1">&#39;wgs84&#39;</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">needAddress</span> <span class="o">===</span> <span class="mi">1</span><span class="p">){</span>
          <span class="c1">// xxx
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="k">else</span><span class="p">{</span>
          <span class="nx">resolve</span><span class="p">({</span><span class="nx">lat</span><span class="p">,</span> <span class="nx">lng</span><span class="p">,</span> <span class="nx">coordType</span><span class="p">})</span>
        <span class="p">}</span>
      <span class="p">},</span> <span class="nx">error</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">error</span><span class="p">.</span><span class="nx">code</span> <span class="o">==</span> <span class="nx">error</span><span class="p">.</span><span class="nx">TIMEOUT</span><span class="p">){</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">getLocation</span><span class="p">({</span>
            <span class="nx">enableHighAcuracy</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
            <span class="nx">timeout</span><span class="o">:</span> <span class="mi">4</span><span class="nx">e3</span><span class="p">,</span>
            <span class="nx">retryed</span><span class="o">:</span> <span class="kc">true</span>
          <span class="p">},</span> <span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">else</span><span class="p">{</span>
          <span class="nx">reject</span><span class="p">({</span>
            <span class="nx">code</span><span class="o">:</span> <span class="s1">&#39;xx&#39;</span><span class="p">,</span>
            <span class="nx">exception</span><span class="o">:</span> <span class="nx">error</span>
          <span class="p">})</span>
        <span class="p">}</span>
      <span class="p">})</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span>
      <span class="nx">reject</span><span class="p">({</span>
        <span class="nx">code</span><span class="o">:</span> <span class="s1">&#39;xx&#39;</span><span class="p">,</span>
        <span class="nx">message</span><span class="o">:</span> <span class="s1">&#39;Not support geolocation&#39;</span>
      <span class="p">})</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">H5</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>React初识</title>
			<link>https://caychance.github.io/posts/react%E5%88%9D%E8%AF%86/</link>
			<pubDate>Mon, 12 Aug 2019 18:53:42 +0800</pubDate>
			
			<guid>https://caychance.github.io/posts/react%E5%88%9D%E8%AF%86/</guid>
			<description>作为前端的三大框架之一，react在国外的使用范围还是特别广泛的，最近在看react的入门学习视频。React16免费视频教程（共28集）
总结几点react中的学习心得：
 react和vue一样，render函数是不允许有多个根元素。如果我非要在页面显示多个根元素呢？可以使用 Fragment 标签 类似vue中的v-html，react中叫做 dangerouslySetInnerHTML={{ __html: this.state.title }}（PS：此处是两个大括号） react中render函数中的class叫做className，这么做的目的是为了区分关键字class label的属性for改为htmlFor react中的添加方法使用onClick render函数中{}大括号表示这里是js代码 不可以直接修改state的值，需要使用setState方法 父子组件传值  父组件中引入子组件标签后，在标签中使用自定义的属性来传递属性和方法。例如：key,content,index,deleteItem
子组件中使用this.props
// 父组件 import React, { Component, Fragment } from &amp;#34;react&amp;#34;; import Listitem from &amp;#34;./Listitem&amp;#34;; class Todolist extends Component { constructor(props) { super(props) this.state = { inputValue: &amp;#39;test&amp;#39;, list: [&amp;#39;test1&amp;#39;, &amp;#39;test2&amp;#39;], title: `&amp;lt;h3&amp;gt;Todolist&amp;lt;/h3&amp;gt;` } } inputChange(e) { this.setState({ inputValue: e.target.value }) } addList = ()=&amp;gt; { let newList = [...this.state.list, this.state.inputValue] this.</description>
			<content type="html"><![CDATA[<hr />

<p>作为前端的三大框架之一，react在国外的使用范围还是特别广泛的，最近在看react的入门学习视频。<a href="https://jspang.com/posts/2019/05/04/new-react-base.html">React16免费视频教程（共28集）</a></p>

<p>总结几点react中的学习心得：</p>

<ul>
<li>react和vue一样，render函数是不允许有多个根元素。如果我非要在页面显示多个根元素呢？可以使用 Fragment 标签</li>
<li>类似vue中的v-html，react中叫做 dangerouslySetInnerHTML={{ __html: this.state.title }}（PS：此处是两个大括号）</li>
<li>react中render函数中的class叫做className，这么做的目的是为了区分关键字class</li>
<li>label的属性for改为htmlFor</li>
<li>react中的添加方法使用onClick</li>
<li>render函数中{}大括号表示这里是js代码</li>
<li>不可以直接修改state的值，需要使用setState方法</li>
<li>父子组件传值</li>
</ul>

<p>父组件中引入子组件标签后，在标签中使用自定义的属性来传递属性和方法。例如：key,content,index,deleteItem</p>

<p>子组件中使用<code>this.props</code></p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// 父组件
</span><span class="c1"></span><span class="k">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">Component</span><span class="p">,</span> <span class="nx">Fragment</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&#34;react&#34;</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">Listitem</span> <span class="nx">from</span> <span class="s2">&#34;./Listitem&#34;</span><span class="p">;</span>
<span class="k">class</span> <span class="nx">Todolist</span> <span class="k">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">inputValue</span><span class="o">:</span> <span class="s1">&#39;test&#39;</span><span class="p">,</span>
      <span class="nx">list</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;test1&#39;</span><span class="p">,</span> <span class="s1">&#39;test2&#39;</span><span class="p">],</span>
      <span class="nx">title</span><span class="o">:</span> <span class="sb">`&lt;h3&gt;Todolist&lt;/h3&gt;`</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">inputChange</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span>
      <span class="nx">inputValue</span><span class="o">:</span> <span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span>
    <span class="p">})</span>
  <span class="p">}</span>

  <span class="nx">addList</span> <span class="o">=</span> <span class="p">()=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">newList</span> <span class="o">=</span> <span class="p">[...</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">list</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">inputValue</span><span class="p">]</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span>
      <span class="nx">list</span><span class="o">:</span> <span class="nx">newList</span><span class="p">,</span>
      <span class="nx">inputValue</span><span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
    <span class="p">})</span>
  <span class="p">}</span>

  <span class="nx">deleteItem</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">list</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">list</span><span class="p">;</span>
    <span class="nx">list</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span>
      <span class="nx">list</span>
    <span class="p">})</span>
  <span class="p">}</span>

  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">Fragment</span><span class="o">&gt;</span>
        <span class="p">{</span><span class="cm">/* 注释 */</span><span class="p">}</span>
        <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">dangerouslySetInnerHTML</span><span class="o">=</span><span class="p">{{</span> <span class="nx">__html</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">title</span> <span class="p">}}</span><span class="o">&gt;&lt;</span><span class="err">/div&gt;</span>
        <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="s2">&#34;header&#34;</span><span class="o">&gt;</span>
          <span class="o">&lt;</span><span class="nx">label</span> <span class="nx">htmlFor</span><span class="o">=</span><span class="s2">&#34;input-item&#34;</span><span class="o">&gt;</span><span class="nx">加入清单</span><span class="o">&lt;</span><span class="err">/label&gt;</span>
          <span class="o">&lt;</span><span class="nx">input</span>
            <span class="nx">id</span><span class="o">=</span><span class="s2">&#34;input-item&#34;</span>
            <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">inputValue</span><span class="p">}</span>
            <span class="nx">onChange</span><span class="o">=</span><span class="p">{(</span><span class="nx">e</span><span class="p">)=&gt;{</span><span class="k">this</span><span class="p">.</span><span class="nx">inputChange</span><span class="p">(</span><span class="nx">e</span><span class="p">)}}</span>
            <span class="nx">type</span><span class="o">=</span><span class="s2">&#34;text&#34;</span> <span class="o">/&gt;</span>
          <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">addList</span><span class="p">}</span><span class="o">&gt;</span><span class="nx">添加</span><span class="o">&lt;</span><span class="err">/button&gt;</span>
        <span class="o">&lt;</span><span class="err">/div&gt;</span>
        <span class="o">&lt;</span><span class="nx">ul</span> <span class="nx">className</span><span class="o">=</span><span class="s2">&#34;content&#34;</span><span class="o">&gt;</span>
          <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">list</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span>
              <span class="p">(</span><span class="nx">ele</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
                <span class="k">return</span> <span class="o">&lt;</span><span class="nx">Listitem</span>
                  <span class="nx">key</span><span class="o">=</span><span class="p">{</span><span class="nx">ele</span> <span class="o">+</span> <span class="nx">index</span><span class="p">}</span>
                  <span class="nx">content</span><span class="o">=</span><span class="p">{</span><span class="nx">ele</span><span class="p">}</span> 
                  <span class="nx">index</span><span class="o">=</span><span class="p">{</span><span class="nx">index</span><span class="p">}</span>
                  <span class="nx">deleteItem</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">deleteItem</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">)}</span> <span class="o">/&gt;</span>
              <span class="p">})</span>
          <span class="p">}</span>
        <span class="o">&lt;</span><span class="err">/ul&gt;</span>
      <span class="o">&lt;</span><span class="err">/Fragment&gt;</span>
    <span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">Todolist</span>

<span class="c1">// 子组件
</span><span class="c1"></span><span class="k">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">Component</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;react&#39;</span><span class="p">;</span>

<span class="k">class</span> <span class="nx">Listitem</span> <span class="k">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">){</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>

    <span class="p">}</span>
    <span class="c1">// this.handleClick = this.handleClick.bind(this)
</span><span class="c1"></span>  <span class="p">}</span>

  <span class="nx">handleClick</span> <span class="o">=</span> <span class="p">()=&gt;{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">deleteItem</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">index</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">li</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span><span class="p">}</span><span class="o">&gt;</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">content</span><span class="p">}</span><span class="o">&lt;</span><span class="err">/li&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
 
<span class="k">export</span> <span class="k">default</span> <span class="nx">Listitem</span><span class="p">;</span>
</code></pre></div>
<ul>
<li>为什么es6中的class中的自定义方法是有this的，但是react中自定义方法this是undefined？—— <a href="https://juejin.im/post/5afa6e2f6fb9a07aa2137f51">[译] 为什么需要在 React 类组件中为事件处理程序绑定 this</a></li>
</ul>

<p>TLTR:</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="k">class</span> <span class="nx">Foo</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span>
  <span class="p">}</span>

  <span class="nx">display</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Foo</span><span class="p">(</span><span class="s1">&#39;Saurabh&#39;</span><span class="p">);</span>
<span class="nx">foo</span><span class="p">.</span><span class="nx">display</span><span class="p">();</span> <span class="c1">// Saurabh
</span><span class="c1"></span>
<span class="c1">//下面的赋值操作模拟了上下文的丢失。 
</span><span class="c1">//与实际在 React Component 中将处理程序作为 callback 参数传递相似。
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">display</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">.</span><span class="nx">display</span><span class="p">;</span> 
<span class="nx">display</span><span class="p">();</span> <span class="c1">// TypeError: this is undefined
</span></code></pre></div>
<ul>
<li>绑定this的方式——可以在constructor或者render方法中使用箭头函数或者bind方法来绑定</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Socket</title>
			<link>https://caychance.github.io/posts/socket/</link>
			<pubDate>Mon, 15 Jul 2019 20:25:14 +0800</pubDate>
			
			<guid>https://caychance.github.io/posts/socket/</guid>
			<description>之前在做业务的时候，有一种情况，前端需要写一个定时器，每个2秒去请求一遍后台的接口，这样子做其实很耗费性能的，现在计划改成使用socket的形式。
其实之前就简单了解一下WebSocket的基本概念，并没有深入的去做过。此处并不会记录一些基本的概念，而且介绍在实际的业务中，如何使用现成的工具去处理。
sockjs-client和stompjs sockjs-client和stompjs是两个现成的库，配合使用，可以帮助我们省很多事情。这样子的不好的地方也很明显，开发变得只是去使用现成的库。
/** * 背景：由于业务需求，多个模块需要每隔2s去轮询一下接口 * 方案：使用socket来通讯，可避免前端耗费性能的去轮询接口 */ import SockJS from &amp;#34;sockjs-client&amp;#34;; import Stomp from &amp;#34;stompjs&amp;#34;; import Bus from &amp;#34;./bus&amp;#34;; let socket = {}; let stompClient = null; // 建立通讯地址 const DefaultConnectUrl = &amp;#34;http://xxx.com/endpointWisely&amp;#34;; const SubscribePath = &amp;#34;/topic/pod1&amp;#34; /** * connect 建立连接 */ socket.connect = () =&amp;gt; { // 声明一个stomp客户端  stompClient = Stomp.over(new SockJS(DefaultConnectUrl)); // stomp客户端建立通讯  stompClient.connect({}, frame =&amp;gt; { // stomp订阅  stompClient.subscribe(SubscribePath, response =&amp;gt; { // 使用Bus.</description>
			<content type="html"><![CDATA[

<hr />

<p>之前在做业务的时候，有一种情况，前端需要写一个定时器，每个2秒去请求一遍后台的接口，这样子做其实很耗费性能的，现在计划改成使用socket的形式。</p>

<p>其实之前就简单了解一下WebSocket的基本概念，并没有深入的去做过。此处并不会记录一些基本的概念，而且介绍在实际的业务中，如何使用现成的工具去处理。</p>

<h3 id="sockjs-client和stompjs">sockjs-client和stompjs</h3>

<p>sockjs-client和stompjs是两个现成的库，配合使用，可以帮助我们省很多事情。这样子的不好的地方也很明显，开发变得只是去使用现成的库。</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="cm">/**
</span><span class="cm"> * 背景：由于业务需求，多个模块需要每隔2s去轮询一下接口
</span><span class="cm"> * 方案：使用socket来通讯，可避免前端耗费性能的去轮询接口
</span><span class="cm"> */</span>

<span class="k">import</span> <span class="nx">SockJS</span> <span class="nx">from</span> <span class="s2">&#34;sockjs-client&#34;</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">Stomp</span> <span class="nx">from</span> <span class="s2">&#34;stompjs&#34;</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">Bus</span> <span class="nx">from</span> <span class="s2">&#34;./bus&#34;</span><span class="p">;</span>


<span class="kd">let</span> <span class="nx">socket</span> <span class="o">=</span> <span class="p">{};</span>
<span class="kd">let</span> <span class="nx">stompClient</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="c1">// 建立通讯地址
</span><span class="c1"></span><span class="k">const</span> <span class="nx">DefaultConnectUrl</span> <span class="o">=</span> <span class="s2">&#34;http://xxx.com/endpointWisely&#34;</span><span class="p">;</span>
<span class="k">const</span> <span class="nx">SubscribePath</span> <span class="o">=</span> <span class="s2">&#34;/topic/pod1&#34;</span>

<span class="cm">/**
</span><span class="cm"> * connect 建立连接
</span><span class="cm"> */</span>
<span class="nx">socket</span><span class="p">.</span><span class="nx">connect</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="c1">// 声明一个stomp客户端
</span><span class="c1"></span>  <span class="nx">stompClient</span> <span class="o">=</span> <span class="nx">Stomp</span><span class="p">.</span><span class="nx">over</span><span class="p">(</span><span class="k">new</span> <span class="nx">SockJS</span><span class="p">(</span><span class="nx">DefaultConnectUrl</span><span class="p">));</span>
  <span class="c1">// stomp客户端建立通讯
</span><span class="c1"></span>  <span class="nx">stompClient</span><span class="p">.</span><span class="nx">connect</span><span class="p">({},</span> <span class="nx">frame</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="c1">// stomp订阅
</span><span class="c1"></span>    <span class="nx">stompClient</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="nx">SubscribePath</span><span class="p">,</span> <span class="nx">response</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="c1">// 使用Bus.$emit将订阅到的数据分发出去
</span><span class="c1"></span>      <span class="nx">Bus</span><span class="p">.</span><span class="nx">$emit</span><span class="p">(</span><span class="s1">&#39;socketData&#39;</span><span class="p">,</span> <span class="nx">response</span><span class="p">);</span>
    <span class="p">})</span>
  <span class="p">});</span>
<span class="p">}</span>

<span class="cm">/**
</span><span class="cm"> * send 主动给后台发送消息
</span><span class="cm"> * @param { Function } sendPath 
</span><span class="cm"> * @param { Object } param
</span><span class="cm"> * @param { Object } config
</span><span class="cm"> */</span>
<span class="nx">socket</span><span class="p">.</span><span class="nx">send</span> <span class="o">=</span> <span class="p">(</span><span class="nx">sendPath</span><span class="p">,</span> <span class="nx">param</span> <span class="o">=</span> <span class="p">{},</span> <span class="nx">config</span> <span class="o">=</span> <span class="p">{})</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">stompClient</span><span class="p">)</span> <span class="k">return</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;请先建立通讯&#39;</span><span class="p">);</span>
  <span class="c1">// stomp主动发送消息
</span><span class="c1"></span>  <span class="nx">stompClient</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="nx">sendPath</span><span class="p">,</span> <span class="nx">config</span><span class="p">,</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">param</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**
</span><span class="cm"> * disconnect 断开连接
</span><span class="cm"> */</span>
<span class="nx">socket</span><span class="p">.</span><span class="nx">disconnect</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">stompClient</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// stomp断开连接
</span><span class="c1"></span>    <span class="nx">stompClient</span><span class="p">.</span><span class="nx">disconnect</span><span class="p">();</span>
    <span class="nx">stompClient</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">socket</span><span class="p">;</span>
</code></pre></div>
<h3 id="参考链接">参考链接</h3>

<p><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">WebSocket 教程</a></p>

<p><a href="http://jmesnil.net/stomp-websocket/doc/">STOMP Over WebSocket</a></p>
]]></content>
		</item>
		
		<item>
			<title>PostMessage使用</title>
			<link>https://caychance.github.io/posts/postmessage%E4%BD%BF%E7%94%A8/</link>
			<pubDate>Thu, 11 Jul 2019 16:47:15 +0800</pubDate>
			
			<guid>https://caychance.github.io/posts/postmessage%E4%BD%BF%E7%94%A8/</guid>
			<description>跨域的问题有一种postMessage的解决方案，之前也一直是听过但是没有用过。
用法  发送消息:otherWindow.postMessage(message, targetOrigin, [transfer]); 接收消息:window.addEventListener(&amp;ldquo;message&amp;rdquo;, (event)=&amp;gt;{}, false); postMessage方法的入参:  message:要发送的数据 targetOrigin:数据接收方。设置为&amp;rsquo;*&amp;lsquo;，则不限制。不建议这么设置。 transfer:可选参数。是一串和message 同时传递的 Transferable 对象.这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。  event对象的几个属性:  data:从其他窗口发送过来的消息对象 type:发型消息的类型 source:发送消息的窗口对象 origin:发送消息的窗口的源   举个栗子🌰 下面的写了一个小demo，page one (http://10.161.114.80:8080/index.html/#/test) 和page two (http://10.161.114.80:8082/index.html/#/test)。
 page one在mounted的时候，新打开了一个窗口，然后8秒后了一条消息给page two； page one在mounted的时候，监听postMessage回来的消息；并判断如果当前发消息的窗口对象，不是当前窗口对象(window)的话，就发送一条消息给page two。 page two在mounted的时候，监听postMessage回来的消息。 page two在mounted的时候，发送一个消息给page one。  //page one &amp;lt;template&amp;gt; &amp;lt;div&amp;gt; &amp;lt;h3&amp;gt;page one&amp;lt;/h3&amp;gt; &amp;lt;input v-model=&amp;#34;message&amp;#34; placeholder=&amp;#34;edit me&amp;#34; /&amp;gt; &amp;lt;button @click=&amp;#34;handleClick&amp;#34;&amp;gt;sendMessage&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; export default { data() { return { message: &amp;#34;&amp;#34;, popup: null }; }, methods: { /** * 打开新窗口 */ openWindow() { this.</description>
			<content type="html"><![CDATA[

<hr />

<p>跨域的问题有一种postMessage的解决方案，之前也一直是听过但是没有用过。</p>

<h3 id="用法">用法</h3>

<ul>
<li>发送消息:otherWindow.postMessage(message, targetOrigin, [transfer]);</li>
<li>接收消息:window.addEventListener(&ldquo;message&rdquo;, (event)=&gt;{}, false);</li>
<li>postMessage方法的入参:

<ul>
<li>message:要发送的数据</li>
<li>targetOrigin:数据接收方。设置为&rsquo;*&lsquo;，则不限制。不建议这么设置。</li>
<li>transfer:可选参数。是一串和message 同时传递的 Transferable 对象.这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</li>
</ul></li>
<li>event对象的几个属性:

<ul>
<li>data:从其他窗口发送过来的消息对象</li>
<li>type:发型消息的类型</li>
<li>source:发送消息的窗口对象</li>
<li>origin:发送消息的窗口的源</li>
</ul></li>
</ul>

<h3 id="举个栗子">举个栗子🌰</h3>

<p>下面的写了一个小demo，page one (<a href="http://10.161.114.80:8080/index.html/#/test">http://10.161.114.80:8080/index.html/#/test</a>) 和page two (<a href="http://10.161.114.80:8082/index.html/#/test)。">http://10.161.114.80:8082/index.html/#/test)。</a></p>

<ol>
<li>page one在mounted的时候，新打开了一个窗口，然后8秒后了一条消息给page two；</li>
<li>page one在mounted的时候，监听postMessage回来的消息；并判断如果当前发消息的窗口对象，不是当前窗口对象(window)的话，就发送一条消息给page two。</li>
<li>page two在mounted的时候，监听postMessage回来的消息。</li>
<li>page two在mounted的时候，发送一个消息给page one。</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">//page one
</span><span class="c1"></span><span class="o">&lt;</span><span class="nx">template</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">h3</span><span class="o">&gt;</span><span class="nx">page</span> <span class="nx">one</span><span class="o">&lt;</span><span class="err">/h3&gt;</span>
    <span class="o">&lt;</span><span class="nx">input</span> <span class="nx">v</span><span class="o">-</span><span class="nx">model</span><span class="o">=</span><span class="s2">&#34;message&#34;</span> <span class="nx">placeholder</span><span class="o">=</span><span class="s2">&#34;edit me&#34;</span> <span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="nx">button</span> <span class="err">@</span><span class="nx">click</span><span class="o">=</span><span class="s2">&#34;handleClick&#34;</span><span class="o">&gt;</span><span class="nx">sendMessage</span><span class="o">&lt;</span><span class="err">/button&gt;</span>
  <span class="o">&lt;</span><span class="err">/div&gt;</span>
<span class="o">&lt;</span><span class="err">/template&gt;</span>

<span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
<span class="k">export</span> <span class="k">default</span> <span class="p">{</span>
  <span class="nx">data</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="nx">message</span><span class="o">:</span> <span class="s2">&#34;&#34;</span><span class="p">,</span>
      <span class="nx">popup</span><span class="o">:</span> <span class="kc">null</span>
    <span class="p">};</span>
  <span class="p">},</span>
  <span class="nx">methods</span><span class="o">:</span> <span class="p">{</span>
    <span class="cm">/**
</span><span class="cm">     * 打开新窗口
</span><span class="cm">     */</span>
    <span class="nx">openWindow</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">popup</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span>
        <span class="s2">&#34;http://10.161.114.80:8082/index.html/#/test&#34;</span><span class="p">,</span>
        <span class="s2">&#34;title&#34;</span>
      <span class="p">);</span>
      <span class="nx">setTimeout</span><span class="p">(()=&gt;{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">sendMess</span><span class="p">(</span><span class="s2">&#34;Hello World!&#34;</span><span class="p">);</span>
      <span class="p">},</span><span class="mi">8000</span><span class="p">)</span>
    <span class="p">},</span>

    <span class="cm">/**
</span><span class="cm">     * 使用postMessage发送消息
</span><span class="cm">     */</span>
    <span class="nx">sendMess</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">popup</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">(</span>
        <span class="nx">message</span><span class="p">,</span>
        <span class="s2">&#34;http://10.161.114.80:8082/index.html/#/test&#34;</span>
      <span class="p">);</span>
    <span class="p">},</span>

    <span class="cm">/**
</span><span class="cm">     * 点击按钮 发送消息
</span><span class="cm">     */</span>
    <span class="nx">handleClick</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">message</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">sendMess</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
    <span class="p">},</span>

    <span class="cm">/**
</span><span class="cm">     * 接收消息
</span><span class="cm">     */</span>
    <span class="nx">receiveMess</span><span class="p">()</span> <span class="p">{</span>
      <span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span>
        <span class="s2">&#34;message&#34;</span><span class="p">,</span>
        <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">source</span> <span class="o">!=</span> <span class="nb">window</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 如果当前source不是window(当前窗口)的话，再发送一条消息出去
</span><span class="c1"></span>            <span class="nx">e</span><span class="p">.</span><span class="nx">source</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">(</span>
              <span class="s2">&#34;hello cc&#34;</span><span class="p">,</span>
              <span class="s2">&#34;http://10.161.114.80:8082/index.html/#/test&#34;</span>
            <span class="p">);</span>
          <span class="p">}</span>
        <span class="p">},</span>
        <span class="kc">false</span>
      <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="nx">mounted</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">openWindow</span><span class="p">();</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">receiveMess</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="o">&lt;</span><span class="err">/script&gt;</span>

<span class="c1">//page two 
</span><span class="c1"></span><span class="o">&lt;</span><span class="nx">template</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">h3</span><span class="o">&gt;</span><span class="nx">page</span> <span class="nx">two</span><span class="o">&lt;</span><span class="err">/h3&gt;</span>
    <span class="o">&lt;</span><span class="nx">input</span> <span class="nx">v</span><span class="o">-</span><span class="nx">model</span><span class="o">=</span><span class="s2">&#34;message&#34;</span> <span class="nx">placeholder</span><span class="o">=</span><span class="s2">&#34;edit me&#34;</span> <span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="nx">button</span> <span class="err">@</span><span class="nx">click</span><span class="o">=</span><span class="s2">&#34;handleClick&#34;</span><span class="o">&gt;</span><span class="nx">sendMessage</span><span class="o">&lt;</span><span class="err">/button&gt;</span>
  <span class="o">&lt;</span><span class="err">/div&gt;</span>
<span class="o">&lt;</span><span class="err">/template&gt;</span>

<span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
<span class="k">export</span> <span class="k">default</span> <span class="p">{</span>
  <span class="nx">data</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="nx">message</span><span class="o">:</span> <span class="s2">&#34;&#34;</span>
    <span class="p">};</span>
  <span class="p">},</span>
  <span class="nx">methods</span><span class="o">:</span> <span class="p">{</span>
    <span class="cm">/**
</span><span class="cm">     * 点击按钮 发送消息
</span><span class="cm">     */</span>
    <span class="nx">handleClick</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">message</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">sendMess</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
    <span class="p">},</span>

    <span class="cm">/**
</span><span class="cm">     * 使用postMessage发送消息
</span><span class="cm">     */</span>
    <span class="nx">sendMess</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
      <span class="nb">window</span><span class="p">.</span><span class="nx">opener</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">(</span>
        <span class="nx">message</span><span class="p">,</span>
        <span class="s2">&#34;http://10.161.114.80:8080/index.html/#/test&#34;</span>
      <span class="p">);</span>
    <span class="p">},</span>

    <span class="cm">/**
</span><span class="cm">     * 接收消息
</span><span class="cm">     */</span>
    <span class="nx">receive</span><span class="p">()</span> <span class="p">{</span>
      <span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span>
        <span class="s2">&#34;message&#34;</span><span class="p">,</span>
        <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
        <span class="p">},</span>
        <span class="kc">false</span>
      <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="nx">mounted</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">receive</span><span class="p">();</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">sendMess</span><span class="p">(</span><span class="s2">&#34;Nice to see you&#34;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="o">&lt;</span><span class="err">/script&gt;</span>
</code></pre></div>
<h3 id="postmessage的应用场景">postMessage的应用场景</h3>

<p>最近在看之前同事留下来的代码，其中有一个功能大量用到postMessage。</p>

<p>postMessage常用于两个页面之间通讯。或者页面中引入了iframe，想让当前页面和iframe窗口页面进行通讯。可以使用postMessage。应用场景就是，一般不依赖后台服务，就单纯的前端页面之间的交互。</p>

<h3 id="注意事项">!!!注意事项</h3>

<ul>
<li>直接在浏览器中打开A和B两个页面，之间是无法使用postMessage通讯的。符合通讯的有两种情况：</li>
<li>情况一：必须其中一个页面是另一个页面通过window.open()打开的；</li>
<li>情况二：A、B两个页面是页面嵌套iframe的关系。可以在iframe的load事件回调中发送请求。</li>
<li>监听message事件的时候需要对event.origin进行过滤。</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Vue组件间通信的方式总结</title>
			<link>https://caychance.github.io/posts/vue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/</link>
			<pubDate>Fri, 05 Jul 2019 18:48:17 +0800</pubDate>
			
			<guid>https://caychance.github.io/posts/vue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/</guid>
			<description>Vue组件之间通讯的常见方法总结
1. props/$emit 最常用的一种方法。
 父组件传值给子组件  子组件中通过声明props传递itemList，父组件引入子组件以后，传入itemList为fruitList
 子组件传值给父组件  子组件中传递值通过$emit的第二个参数。父组件接受值通过声明方法addItem，并获取其中的参数。
// 父组件 &amp;lt;template&amp;gt; &amp;lt;div class=&amp;#34;test&amp;#34;&amp;gt; &amp;lt;h3&amp;gt;this is parents page&amp;lt;/h3&amp;gt; &amp;lt;cChildA v-on:changeItemList=&amp;#39;addItem&amp;#39; v-bind:itemList=&amp;#34;fruitList&amp;#34; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; import cChildA from &amp;#34;./a&amp;#34;; export default { data() { return { fruitList: [&amp;#34;peach&amp;#34;, &amp;#34;banana&amp;#34;, &amp;#34;lemon&amp;#34;] }; }, methods:{ addItem(item){ console.log(item); } }, components: { cChildA } }; //子组件 &amp;lt;template&amp;gt; &amp;lt;div&amp;gt; &amp;lt;h3&amp;gt;{{childTitle}}&amp;lt;/h3&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li v-on:click=&amp;#34;changeItemList&amp;#34; v-for=&amp;#34;(item,index) in itemList&amp;#34; v-bind:key=&amp;#34;index&amp;#34;&amp;gt;{{item}}&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; export default { props: { itemList: { type: Array } }, data() { return { childTitle: `this is child page` }; }, methods: { changeItemList() { this.</description>
			<content type="html"><![CDATA[

<hr />

<p>Vue组件之间通讯的常见方法总结</p>

<h3 id="1-props-emit">1. props/$emit</h3>

<p>最常用的一种方法。</p>

<ul>
<li>父组件传值给子组件</li>
</ul>

<p>子组件中通过声明<code>props</code>传递<code>itemList</code>，父组件引入子组件以后，传入<code>itemList</code>为<code>fruitList</code></p>

<ul>
<li>子组件传值给父组件</li>
</ul>

<p>子组件中传递值通过<code>$emit</code>的第二个参数。父组件接受值通过声明方法<code>addItem</code>，并获取其中的参数。</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="c1">// 父组件
</span><span class="c1"></span><span class="o">&lt;</span><span class="nx">template</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">div</span> <span class="k">class</span><span class="o">=</span><span class="s2">&#34;test&#34;</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">h3</span><span class="o">&gt;</span><span class="k">this</span> <span class="nx">is</span> <span class="nx">parents</span> <span class="nx">page</span><span class="o">&lt;</span><span class="err">/h3&gt;</span>
    <span class="o">&lt;</span><span class="nx">cChildA</span> <span class="nx">v</span><span class="o">-</span><span class="nx">on</span><span class="o">:</span><span class="nx">changeItemList</span><span class="o">=</span><span class="s1">&#39;addItem&#39;</span> <span class="nx">v</span><span class="o">-</span><span class="nx">bind</span><span class="o">:</span><span class="nx">itemList</span><span class="o">=</span><span class="s2">&#34;fruitList&#34;</span> <span class="o">/&gt;</span>
  <span class="o">&lt;</span><span class="err">/div&gt;</span>
<span class="o">&lt;</span><span class="err">/template&gt;</span>

<span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
<span class="k">import</span> <span class="nx">cChildA</span> <span class="nx">from</span> <span class="s2">&#34;./a&#34;</span><span class="p">;</span>
<span class="k">export</span> <span class="k">default</span> <span class="p">{</span>
  <span class="nx">data</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="nx">fruitList</span><span class="o">:</span> <span class="p">[</span><span class="s2">&#34;peach&#34;</span><span class="p">,</span> <span class="s2">&#34;banana&#34;</span><span class="p">,</span> <span class="s2">&#34;lemon&#34;</span><span class="p">]</span>
    <span class="p">};</span>
  <span class="p">},</span>
  <span class="nx">methods</span><span class="o">:</span><span class="p">{</span>
    <span class="nx">addItem</span><span class="p">(</span><span class="nx">item</span><span class="p">){</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="nx">components</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">cChildA</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">//子组件
</span><span class="c1"></span><span class="o">&lt;</span><span class="nx">template</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">h3</span><span class="o">&gt;</span><span class="p">{{</span><span class="nx">childTitle</span><span class="p">}}</span><span class="o">&lt;</span><span class="err">/h3&gt;</span>
    <span class="o">&lt;</span><span class="nx">ul</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">li</span> <span class="nx">v</span><span class="o">-</span><span class="nx">on</span><span class="o">:</span><span class="nx">click</span><span class="o">=</span><span class="s2">&#34;changeItemList&#34;</span> <span class="nx">v</span><span class="o">-</span><span class="k">for</span><span class="o">=</span><span class="s2">&#34;(item,index) in itemList&#34;</span> <span class="nx">v</span><span class="o">-</span><span class="nx">bind</span><span class="o">:</span><span class="nx">key</span><span class="o">=</span><span class="s2">&#34;index&#34;</span><span class="o">&gt;</span><span class="p">{{</span><span class="nx">item</span><span class="p">}}</span><span class="o">&lt;</span><span class="err">/li&gt;</span>
    <span class="o">&lt;</span><span class="err">/ul&gt;</span>
  <span class="o">&lt;</span><span class="err">/div&gt;</span>
<span class="o">&lt;</span><span class="err">/template&gt;</span>

<span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
<span class="k">export</span> <span class="k">default</span> <span class="p">{</span>
  <span class="nx">props</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">itemList</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">type</span><span class="o">:</span> <span class="nb">Array</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="nx">data</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="nx">childTitle</span><span class="o">:</span> <span class="sb">`this is child page`</span>
    <span class="p">};</span>
  <span class="p">},</span>
  <span class="nx">methods</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">changeItemList</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">$emit</span><span class="p">(</span><span class="s2">&#34;changeItemList&#34;</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">childTitle</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="o">&lt;</span><span class="err">/script&gt;</span>
</code></pre></div>
<h3 id="2-vuex">2. Vuex</h3>

<blockquote>
<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
</blockquote>

<p>在网上看到有人把这个也归类到Vue组件间通信的方法。这么说肯定没错的哈。但是看一下Vuex的定义，它是Vue中用来管理所有组件的状态的。它都可以用于管理所有组件的状态了，父子组件之间肯定可以使用它进行通讯。杀鸡焉用牛刀，所以该方法并不适用父子组件通讯这个场景。</p>

<p>具体使用方法就不详细说了，具体可以参考看一下<a href="https://vuex.vuejs.org/zh/">Vuex文档</a>。</p>

<p>平时使用Vuex的时候，需要注意的一个问题，是Vuex的数据不是持久化的，也就是说，页面刷新，或者跳转到第三方页面的时候，Vuex中的数据会清空，所以一般都会配套使用<a href="https://github.com/robinvdvleuten/vuex-persistedstate">vuex-persistedstate</a>。</p>

<h3 id="3-emit-on">3. $emit/$on</h3>

<p>该方法的思路是通过一个空的Vue实例作为事件中心，用来触发事件和监听事件。</p>

<p>假设index页面引入了a，b，c三个组件。a和b组件需要传值给c组件。bus.js就是new了一个空的Vue并暴露出来。</p>

<p>这个方法之前没有接触过，所以就详细的写出来具体的用法。总结一下：</p>

<ul>
<li>使用<strong>一个</strong>空的Vue实例作为中央事件总线(事件中心)</li>
<li>把事件暴露出去使用 <code>Bus.$emit(&quot;event-name&quot;, this.data);</code>，就可以把<code>this.data</code>暴露出去</li>
<li>接收方接受数据使用<code>Bus.$on(&quot;event-name&quot;, data =&gt; {this.data = data;});</code></li>
<li>暴露和接受方法使用的<code>event-name</code>相同即可</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">//index.vue
</span><span class="c1"></span><span class="o">&lt;</span><span class="nx">template</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">div</span> <span class="k">class</span><span class="o">=</span><span class="s2">&#34;test&#34;</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">h3</span><span class="o">&gt;</span><span class="k">this</span> <span class="nx">is</span> <span class="nx">parents</span> <span class="nx">page</span><span class="o">&lt;</span><span class="err">/h3&gt;</span>
    <span class="o">&lt;</span><span class="nx">c</span><span class="o">-</span><span class="nx">child</span><span class="o">-</span><span class="nx">a</span><span class="o">&gt;&lt;</span><span class="err">/c-child-a&gt;</span>
    <span class="o">&lt;</span><span class="nx">c</span><span class="o">-</span><span class="nx">child</span><span class="o">-</span><span class="nx">b</span><span class="o">&gt;&lt;</span><span class="err">/c-child-b&gt;</span>
    <span class="o">&lt;</span><span class="nx">c</span><span class="o">-</span><span class="nx">child</span><span class="o">-</span><span class="nx">c</span><span class="o">&gt;&lt;</span><span class="err">/c-child-c&gt;</span>
  <span class="o">&lt;</span><span class="err">/div&gt;</span>
<span class="o">&lt;</span><span class="err">/template&gt;</span>

<span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
<span class="k">import</span> <span class="nx">cChildA</span> <span class="nx">from</span> <span class="s2">&#34;./a&#34;</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">cChildB</span> <span class="nx">from</span> <span class="s2">&#34;./b&#34;</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">cChildC</span> <span class="nx">from</span> <span class="s2">&#34;./c&#34;</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="p">{</span>
  <span class="nx">data</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
    <span class="p">};</span>
  <span class="p">},</span>
  <span class="nx">methods</span><span class="o">:</span><span class="p">{</span>
    
  <span class="p">},</span>
  <span class="nx">components</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">cChildA</span><span class="p">,</span>
    <span class="nx">cChildB</span><span class="p">,</span>
    <span class="nx">cChildC</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="o">&lt;</span><span class="err">/script&gt;</span>

<span class="c1">// a.vue
</span><span class="c1"></span><span class="o">&lt;</span><span class="nx">template</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">h3</span><span class="o">&gt;</span><span class="nx">A组件</span><span class="p">{{</span><span class="nx">name</span><span class="p">}}</span><span class="o">&lt;</span><span class="err">/h3&gt;</span>
    <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">v</span><span class="o">-</span><span class="nx">on</span><span class="o">:</span><span class="nx">click</span><span class="o">=</span><span class="s2">&#34;send&#34;</span><span class="o">&gt;</span><span class="nx">传值给C</span><span class="o">&lt;</span><span class="err">/button&gt;</span>
  <span class="o">&lt;</span><span class="err">/div&gt;</span>
<span class="o">&lt;</span><span class="err">/template&gt;</span>

<span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
<span class="k">import</span> <span class="nx">Bus</span> <span class="nx">from</span> <span class="s1">&#39;./bus&#39;</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="p">{</span>
  <span class="nx">data</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;Chance&#39;</span>
    <span class="p">};</span>
  <span class="p">},</span>
  <span class="nx">methods</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">send</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">Bus</span><span class="p">.</span><span class="nx">$emit</span><span class="p">(</span><span class="s2">&#34;com-a&#34;</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="o">&lt;</span><span class="err">/script&gt;</span>

<span class="o">&lt;</span><span class="nx">style</span> <span class="nx">scoped</span><span class="o">&gt;</span>
<span class="nx">button</span><span class="p">{</span>
  <span class="nx">width</span><span class="o">:</span> <span class="mi">100</span><span class="nx">px</span><span class="p">;</span>
  <span class="nx">height</span><span class="o">:</span> <span class="mi">20</span><span class="nx">px</span><span class="p">;</span>
  <span class="nx">border</span><span class="o">-</span><span class="nx">radius</span><span class="o">:</span> <span class="mi">10</span><span class="nx">px</span><span class="p">;</span>
  <span class="nx">padding</span><span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="o">&lt;</span><span class="err">/style&gt;</span>

<span class="c1">// b.vue
</span><span class="c1"></span><span class="o">&lt;</span><span class="nx">template</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">h3</span><span class="o">&gt;</span><span class="nx">B组件</span><span class="p">{{</span><span class="nx">age</span><span class="p">}}</span><span class="o">&lt;</span><span class="err">/h3&gt;</span>
    <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">v</span><span class="o">-</span><span class="nx">on</span><span class="o">:</span><span class="nx">click</span><span class="o">=</span><span class="s2">&#34;send&#34;</span><span class="o">&gt;</span><span class="nx">传值给C</span><span class="o">&lt;</span><span class="err">/button&gt;</span>
  <span class="o">&lt;</span><span class="err">/div&gt;</span>
<span class="o">&lt;</span><span class="err">/template&gt;</span>

<span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
<span class="k">import</span> <span class="nx">Bus</span> <span class="nx">from</span> <span class="s1">&#39;./bus&#39;</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="p">{</span>
  <span class="nx">data</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="nx">age</span><span class="o">:</span> <span class="mi">27</span>
    <span class="p">};</span>
  <span class="p">},</span>
  <span class="nx">methods</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">send</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">Bus</span><span class="p">.</span><span class="nx">$emit</span><span class="p">(</span><span class="s2">&#34;com-b&#34;</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">age</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="o">&lt;</span><span class="err">/script&gt;</span>

<span class="o">&lt;</span><span class="nx">style</span> <span class="nx">scoped</span><span class="o">&gt;</span>
<span class="nx">button</span><span class="p">{</span>
  <span class="nx">width</span><span class="o">:</span> <span class="mi">100</span><span class="nx">px</span><span class="p">;</span>
  <span class="nx">height</span><span class="o">:</span> <span class="mi">20</span><span class="nx">px</span><span class="p">;</span>
  <span class="nx">border</span><span class="o">-</span><span class="nx">radius</span><span class="o">:</span> <span class="mi">10</span><span class="nx">px</span><span class="p">;</span>
  <span class="nx">padding</span><span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="o">&lt;</span><span class="err">/style&gt;</span>

<span class="c1">// c.vue
</span><span class="c1"></span><span class="o">&lt;</span><span class="nx">template</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">div</span> <span class="k">class</span><span class="o">=</span><span class="s2">&#34;c&#34;</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">h3</span><span class="o">&gt;</span><span class="nx">C组件</span><span class="o">&lt;</span><span class="err">/h3&gt;</span>
    <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">接受来自A</span><span class="o">/</span><span class="nx">B组件的值</span><span class="p">{{</span><span class="nx">name</span><span class="p">}}{{</span><span class="nx">age</span><span class="p">}}</span><span class="o">&lt;</span><span class="err">/div&gt;</span>
  <span class="o">&lt;</span><span class="err">/div&gt;</span>
<span class="o">&lt;</span><span class="err">/template&gt;</span>

<span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
<span class="k">import</span> <span class="nx">Bus</span> <span class="nx">from</span> <span class="s1">&#39;./bus&#39;</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="p">{</span>
  <span class="nx">data</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="nx">name</span><span class="o">:</span> <span class="s2">&#34;&#34;</span><span class="p">,</span>
      <span class="nx">age</span><span class="o">:</span> <span class="s2">&#34;&#34;</span>
    <span class="p">};</span>
  <span class="p">},</span>
  <span class="nx">mounted</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">Bus</span><span class="p">.</span><span class="nx">$on</span><span class="p">(</span><span class="s2">&#34;com-a&#34;</span><span class="p">,</span> <span class="nx">name</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="p">});</span>
    <span class="nx">Bus</span><span class="p">.</span><span class="nx">$on</span><span class="p">(</span><span class="s2">&#34;com-b&#34;</span><span class="p">,</span> <span class="nx">age</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
    <span class="p">});</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="o">&lt;</span><span class="err">/script&gt;</span>

<span class="c1">//bus.js
</span><span class="c1"></span><span class="k">import</span> <span class="nx">Vue</span> <span class="nx">from</span> <span class="s1">&#39;vue&#39;</span>
<span class="k">const</span> <span class="nx">Bus</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vue</span><span class="p">()</span>
<span class="k">export</span> <span class="k">default</span> <span class="nx">Bus</span>
</code></pre></div>
<h3 id="4-parent-children-ref">4. $parent/$children/ref</h3>

<blockquote>
<p>ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例。</p>

<p>$parent 父实例，如果当前实例有的话。</p>

<p>$children 当前实例的直接子组件。</p>
</blockquote>

<h3 id="5-provide-inject">5. provide/inject</h3>

<blockquote>
<p>2.2.0新增。
这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。</p>
</blockquote>

<p><code>provide/inject</code>使用起来很方便，它的适用场景就是爷父子孙这种的组件关系，只能从祖先组件向子孙后台往下流。</p>

<p>通过在父组件<code>povide</code>钩子中声明变量暴露出数据；在子组件<code>inject</code>钩子中接受数据即可。</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// index.vue
</span><span class="c1"></span><span class="o">&lt;</span><span class="nx">template</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">div</span> <span class="k">class</span><span class="o">=</span><span class="s2">&#34;test&#34;</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">h3</span><span class="o">&gt;</span><span class="k">this</span> <span class="nx">is</span> <span class="nx">parents</span> <span class="nx">page</span><span class="o">&lt;</span><span class="err">/h3&gt;</span>
    <span class="o">&lt;</span><span class="nx">c</span><span class="o">-</span><span class="nx">child</span><span class="o">-</span><span class="nx">c</span><span class="o">&gt;&lt;</span><span class="err">/c-child-c&gt;</span>
    <span class="o">&lt;</span><span class="nx">c</span><span class="o">-</span><span class="nx">child</span><span class="o">-</span><span class="nx">b</span><span class="o">&gt;&lt;</span><span class="err">/c-child-b&gt;</span>
  <span class="o">&lt;</span><span class="err">/div&gt;</span>
<span class="o">&lt;</span><span class="err">/template&gt;</span>

<span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
<span class="k">import</span> <span class="nx">cChildC</span> <span class="nx">from</span> <span class="s2">&#34;./c&#34;</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">cChildB</span> <span class="nx">from</span> <span class="s2">&#34;./b&#34;</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="p">{</span>
  <span class="nx">provide</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;chance&#39;</span><span class="p">,</span>
    <span class="nx">age</span><span class="o">:</span> <span class="s1">&#39;27&#39;</span>
  <span class="p">},</span>
  <span class="nx">components</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">cChildC</span><span class="p">,</span>
    <span class="nx">cChildB</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="o">&lt;</span><span class="err">/script&gt;</span>

<span class="c1">// b.vue
</span><span class="c1"></span><span class="o">&lt;</span><span class="nx">template</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">div</span> <span class="k">class</span><span class="o">=</span><span class="s2">&#34;b&#34;</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">h3</span><span class="o">&gt;</span><span class="nx">B组件</span><span class="o">&lt;</span><span class="err">/h3&gt;</span>
    <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">接受来自父组件组件的值</span><span class="p">{{</span><span class="nx">name</span><span class="p">}}{{</span><span class="nx">age</span><span class="p">}}</span><span class="o">&lt;</span><span class="err">/div&gt;</span>
  <span class="o">&lt;</span><span class="err">/div&gt;</span>
<span class="o">&lt;</span><span class="err">/template&gt;</span>

<span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
<span class="k">export</span> <span class="k">default</span> <span class="p">{</span>
  <span class="nx">inject</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span><span class="s1">&#39;age&#39;</span><span class="p">]</span>
<span class="p">};</span>
<span class="o">&lt;</span><span class="err">/script&gt;</span>
</code></pre></div>
<h3 id="6-attrs-listeners">6. $attrs/$listeners</h3>

<p>来自官方的说明：</p>

<blockquote>
<p>$attrs</p>

<p>包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=&ldquo;$attrs&rdquo; 传入内部组件——在创建高级别的组件时非常有用。</p>

<p>$listeners</p>

<p>包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=&ldquo;$listeners&rdquo; 传入内部组件——在创建更高层次的组件时非常有用。</p>
</blockquote>

<ul>
<li>$attrs</li>
</ul>

<p>看着是有些晦涩的，用自己的话，来解释一下就是。在index组件中，data中声明了foo、boo、coo、doo、name、age共6个变量，其中前4个变量和title，index组件都传给了子组件childCom1；在childCom1组件中用props接受了foo变量，剩余的4个变量都是通过$attrs来接受的。往下的传递同理。</p>

<p>该属性需配合inheritAttrs来决定是否可以获取父组件中定义的数据。(PS:试了一下不太好使，不知道是不是没有用对)</p>

<ul>
<li>$listeners</li>
</ul>

<p>这一块还没有完全弄明白，暂时的理解就是子组件可以调用父组件中的方法。父组件中定义了两个方法，eventClick1和eventClick2。在childCom1组件的mounted钩子的时候，就触发了event1；在childCom2组件中button标签中声明handleClick去触发了event2。</p>

<p>下面的例子中：index.vue为根组件，childCom1是index的子组件，childCom2是childCom1的子组件，childCom3是childCom2的子组件。</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// index.vue
</span><span class="c1"></span><span class="o">&lt;</span><span class="nx">template</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">h2</span><span class="o">&gt;</span><span class="nx">index</span> <span class="nx">page</span><span class="o">&lt;</span><span class="err">/h2&gt;</span>
    <span class="o">&lt;</span><span class="nx">child</span><span class="o">-</span><span class="nx">com1</span>
      <span class="o">:</span><span class="nx">foo</span><span class="o">=</span><span class="s2">&#34;foo&#34;</span>
      <span class="o">:</span><span class="nx">boo</span><span class="o">=</span><span class="s2">&#34;boo&#34;</span>
      <span class="o">:</span><span class="nx">coo</span><span class="o">=</span><span class="s2">&#34;coo&#34;</span>
      <span class="o">:</span><span class="nx">doo</span><span class="o">=</span><span class="s2">&#34;doo&#34;</span>
      <span class="nx">title</span><span class="o">=</span><span class="s2">&#34;前端&#34;</span>
      <span class="err">@</span><span class="nx">event1</span><span class="o">=</span><span class="s1">&#39;eventClick1&#39;</span>
      <span class="err">@</span><span class="nx">event2</span><span class="o">=</span><span class="s1">&#39;eventClick2&#39;</span>
    <span class="o">&gt;&lt;</span><span class="err">/child-com1&gt;</span>
  <span class="o">&lt;</span><span class="err">/div&gt;</span>
<span class="o">&lt;</span><span class="err">/template&gt;</span>
<span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
<span class="k">const</span> <span class="nx">childCom1</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="k">import</span><span class="p">(</span><span class="s2">&#34;./childCom1.vue&#34;</span><span class="p">);</span>
<span class="k">export</span> <span class="k">default</span> <span class="p">{</span>
  <span class="nx">components</span><span class="o">:</span> <span class="p">{</span> <span class="nx">childCom1</span> <span class="p">},</span>
  <span class="nx">data</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="nx">foo</span><span class="o">:</span> <span class="s2">&#34;Javascript&#34;</span><span class="p">,</span>
      <span class="nx">boo</span><span class="o">:</span> <span class="s2">&#34;Html&#34;</span><span class="p">,</span>
      <span class="nx">coo</span><span class="o">:</span> <span class="s2">&#34;CSS&#34;</span><span class="p">,</span>
      <span class="nx">doo</span><span class="o">:</span> <span class="s2">&#34;Vue&#34;</span><span class="p">,</span>
      <span class="nx">name</span><span class="o">:</span> <span class="s2">&#34;chance&#34;</span><span class="p">,</span>
      <span class="nx">age</span><span class="o">:</span> <span class="mi">17</span>
    <span class="p">};</span>
  <span class="p">},</span>
  <span class="nx">methods</span><span class="o">:</span><span class="p">{</span>
    <span class="nx">eventClick1</span><span class="p">(){</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;this is event click1&#39;</span><span class="p">)</span>
    <span class="p">},</span>
    <span class="nx">eventClick2</span><span class="p">(){</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;this is event click2&#39;</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="o">&lt;</span><span class="err">/script&gt;</span>

<span class="c1">// childCom1.vue
</span><span class="c1"></span><span class="o">&lt;</span><span class="nx">template</span> <span class="k">class</span><span class="o">=</span><span class="s2">&#34;border&#34;</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">foo</span><span class="o">:</span> <span class="p">{{</span> <span class="nx">foo</span> <span class="p">}}</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
    <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">childCom1的$attrs</span><span class="o">:</span> <span class="p">{{</span> <span class="nx">$attrs</span> <span class="p">}}</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
    <span class="o">&lt;</span><span class="nx">child</span><span class="o">-</span><span class="nx">com2</span> <span class="nx">v</span><span class="o">-</span><span class="nx">bind</span><span class="o">=</span><span class="s2">&#34;$attrs&#34;</span> <span class="nx">v</span><span class="o">-</span><span class="nx">on</span><span class="o">=</span><span class="s2">&#34;$listeners&#34;</span><span class="o">&gt;&lt;</span><span class="err">/child-com2&gt;</span>
  <span class="o">&lt;</span><span class="err">/div&gt;</span>
<span class="o">&lt;</span><span class="err">/template&gt;</span>
<span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
<span class="k">const</span> <span class="nx">childCom2</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="k">import</span><span class="p">(</span><span class="s2">&#34;./childCom2.vue&#34;</span><span class="p">);</span>
<span class="k">export</span> <span class="k">default</span> <span class="p">{</span>
  <span class="nx">components</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">childCom2</span>
  <span class="p">},</span>
  <span class="nx">inheritAttrs</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span> <span class="c1">// 可以关闭自动挂载到组件根元素上的没有在props声明的属性
</span><span class="c1"></span>  <span class="nx">props</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">foo</span><span class="o">:</span> <span class="nb">String</span> <span class="c1">// foo作为props属性绑定
</span><span class="c1"></span>  <span class="p">},</span>
  <span class="nx">mounted</span><span class="p">(){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">$emit</span><span class="p">(</span><span class="s1">&#39;event1&#39;</span><span class="p">)</span>
  <span class="p">},</span>
  <span class="nx">created</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;c1&#39;</span><span class="p">,</span><span class="k">this</span><span class="p">.</span><span class="nx">$attrs</span><span class="p">);</span> <span class="c1">// { &#34;boo&#34;: &#34;Html&#34;, &#34;coo&#34;: &#34;CSS&#34;, &#34;doo&#34;: &#34;Vue&#34;, &#34;title&#34;: &#34;前端&#34; }
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">};</span>
<span class="o">&lt;</span><span class="err">/script&gt;</span>

<span class="c1">// childCom2.vue
</span><span class="c1"></span><span class="o">&lt;</span><span class="nx">template</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">div</span> <span class="k">class</span><span class="o">=</span><span class="s2">&#34;border&#34;</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">boo</span><span class="o">:</span> <span class="p">{{</span> <span class="nx">boo</span> <span class="p">}}</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
    <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">childCom2</span><span class="o">:</span> <span class="p">{{</span> <span class="nx">$attrs</span> <span class="p">}}</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
    <span class="o">&lt;</span><span class="nx">button</span> <span class="err">@</span><span class="nx">click</span><span class="o">=</span><span class="s2">&#34;handleClick&#34;</span><span class="o">&gt;</span><span class="nx">fire</span><span class="o">&lt;</span><span class="err">/button&gt;</span>
    <span class="o">&lt;</span><span class="nx">child</span><span class="o">-</span><span class="nx">com3</span> <span class="nx">v</span><span class="o">-</span><span class="nx">bind</span><span class="o">=</span><span class="s2">&#34;$attrs&#34;</span> <span class="nx">v</span><span class="o">-</span><span class="nx">on</span><span class="o">=</span><span class="s2">&#34;$listeners&#34;</span><span class="o">&gt;&lt;</span><span class="err">/child-com3&gt;</span>
  <span class="o">&lt;</span><span class="err">/div&gt;</span>
<span class="o">&lt;</span><span class="err">/template&gt;</span>
<span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
<span class="k">const</span> <span class="nx">childCom3</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="k">import</span><span class="p">(</span><span class="s2">&#34;./childCom3.vue&#34;</span><span class="p">);</span>
<span class="k">export</span> <span class="k">default</span> <span class="p">{</span>
  <span class="nx">components</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">childCom3</span>
  <span class="p">},</span>
  <span class="nx">inheritAttrs</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
  <span class="nx">props</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">boo</span><span class="o">:</span> <span class="nb">String</span>
  <span class="p">},</span>
  <span class="nx">mounted</span><span class="p">()</span> <span class="p">{},</span>
  <span class="nx">methods</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">handleClick</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">$emit</span><span class="p">(</span><span class="s2">&#34;event2&#34;</span><span class="p">);</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;fried&#39;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="nx">created</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;c2&#34;</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">$attrs</span><span class="p">);</span> <span class="c1">// { &#34;coo&#34;: &#34;CSS&#34;, &#34;doo&#34;: &#34;Vue&#34;, &#34;title&#34;: &#34;前端&#34; }
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">};</span>
<span class="o">&lt;</span><span class="err">/script&gt;</span>

<span class="c1">// childCom3.vue
</span><span class="c1"></span><span class="o">&lt;</span><span class="nx">template</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">div</span> <span class="k">class</span><span class="o">=</span><span class="s2">&#34;border&#34;</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">childCom3</span><span class="o">:</span> <span class="p">{{</span> <span class="nx">$attrs</span> <span class="p">}}</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
  <span class="o">&lt;</span><span class="err">/div&gt;</span>
<span class="o">&lt;</span><span class="err">/template&gt;</span>
<span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
<span class="k">export</span> <span class="k">default</span> <span class="p">{</span>
  <span class="nx">props</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">coo</span><span class="o">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="nx">title</span><span class="o">:</span> <span class="nb">String</span>
  <span class="p">},</span>
  <span class="nx">created</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;c3&#39;</span><span class="p">,</span><span class="k">this</span><span class="p">.</span><span class="nx">$attrs</span><span class="p">)</span> <span class="c1">// { &#34;doo&#34;: &#34;Vue&#34;}
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">};</span>
<span class="o">&lt;</span><span class="err">/script&gt;</span>
</code></pre></div>
<h3 id="总结">总结</h3>

<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">使用场景</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">props/$emit</td>
<td align="center">正常的父子组件传输</td>
</tr>

<tr>
<td align="center">Vuex</td>
<td align="center">多组件之间的状态共享</td>
</tr>

<tr>
<td align="center">$emit/$on</td>
<td align="center">兄弟组件之间传输，不通过父组件统一下发数据来解决</td>
</tr>

<tr>
<td align="center">$parent/$children/ref</td>
<td align="center">兄弟组件不适用</td>
</tr>

<tr>
<td align="center">provide/inject</td>
<td align="center">爷=&gt;父=&gt;子=&gt;孙 数据流向</td>
</tr>
</tbody>
</table>
]]></content>
		</item>
		
		<item>
			<title>项目总结</title>
			<link>https://caychance.github.io/posts/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</link>
			<pubDate>Fri, 21 Jun 2019 08:03:50 +0800</pubDate>
			
			<guid>https://caychance.github.io/posts/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</guid>
			<description>本来想总结一下刚来做的这个项目中，遇到的一些问题，或者说，下次在做类似的项目，有哪些地方可以做的更好。结果周五周六团建两天再回来，发现忘得差不多了。(PS:下次应该随手就记下来)
暂时能想到的：
 常用的简单动画，最好使用css去完成，不要一想起来动画就想到js。 页面的内容部分，左右padding最好有一些留白，这样子可以保证页面在小屏幕上，左右也会有一些留白。 页面header添加scroll事件，监听页面滚动距离来动态修改header的透明度。监听页面的子元素页面溢出，监听页面设置overflow-y: scroll;，获取该页面的scrollTop值。(PS:这一块老忘记)  this.$refs.home.scrollIntoView(true); const homeParent = this.$refs.home.parentElement; const header = this.$refs.home.firstChild; homeParent.addEventListener(&amp;#34;scroll&amp;#34;, () =&amp;gt; { if (homeParent.scrollTop &amp;lt; 80) { header.style.background = &amp;#34;none&amp;#34;; } else { header.style.backgroundImage = &amp;#34;url(&amp;#39;http://******/swiper.png&amp;#39;)&amp;#34;; } });   使用transform: scale(0.5);，即使你配合transform-origin: 0 0;一起使用，虽然元素被缩小了一倍，但是原本的位置还是在的，会自动预留出来，周围的元素并不能覆盖上去。(PS:这里挺疑惑的)   为啥会用到transform: scale(0.5);？设计童鞋在切图的时候，同一个功能块切出来的图大小不一，导致我们需要给每个img标签设定尺寸。(PS:就算同一个功能块，设计的icon大小不一，但是切图的时候，还是可以切成尺寸一样的，就是切出来的icon周围留白多少的问题了)  </description>
			<content type="html"><![CDATA[<hr />

<p>本来想总结一下刚来做的这个项目中，遇到的一些问题，或者说，下次在做类似的项目，有哪些地方可以做的更好。结果周五周六团建两天再回来，发现忘得差不多了。(PS:下次应该随手就记下来)</p>

<p>暂时能想到的：</p>

<ul>
<li>常用的简单动画，最好使用css去完成，不要一想起来动画就想到js。</li>
<li>页面的内容部分，左右padding最好有一些留白，这样子可以保证页面在小屏幕上，左右也会有一些留白。</li>
<li>页面header添加scroll事件，监听页面滚动距离来动态修改header的透明度。监听页面的子元素页面溢出，监听页面设置<code>overflow-y: scroll;</code>，获取该页面的scrollTop值。(PS:这一块老忘记)</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="k">this</span><span class="p">.</span><span class="nx">$refs</span><span class="p">.</span><span class="nx">home</span><span class="p">.</span><span class="nx">scrollIntoView</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
<span class="k">const</span> <span class="nx">homeParent</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">$refs</span><span class="p">.</span><span class="nx">home</span><span class="p">.</span><span class="nx">parentElement</span><span class="p">;</span>
<span class="k">const</span> <span class="nx">header</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">$refs</span><span class="p">.</span><span class="nx">home</span><span class="p">.</span><span class="nx">firstChild</span><span class="p">;</span>
<span class="nx">homeParent</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s2">&#34;scroll&#34;</span><span class="p">,</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">homeParent</span><span class="p">.</span><span class="nx">scrollTop</span> <span class="o">&lt;</span> <span class="mi">80</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">header</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">background</span> <span class="o">=</span> <span class="s2">&#34;none&#34;</span><span class="p">;</span>
  <span class="p">}</span> 
  <span class="k">else</span> <span class="p">{</span>
    <span class="nx">header</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">backgroundImage</span> <span class="o">=</span>
      <span class="s2">&#34;url(&#39;http://******/swiper.png&#39;)&#34;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<ul>
<li>使用<code>transform: scale(0.5);</code>，即使你配合<code>transform-origin: 0 0;</code>一起使用，虽然元素被缩小了一倍，但是原本的位置还是在的，会自动预留出来，周围的元素并不能覆盖上去。(PS:这里挺疑惑的)</li>
</ul>

<p><img src="https://blog-pics.pek3b.qingstor.com/c-9ac6-e6dcd9c901fc.png" alt="" /></p>

<ul>
<li>为啥会用到<code>transform: scale(0.5);</code>？设计童鞋在切图的时候，同一个功能块切出来的图大小不一，导致我们需要给每个img标签设定尺寸。(PS:就算同一个功能块，设计的icon大小不一，但是切图的时候，还是可以切成尺寸一样的，就是切出来的icon周围留白多少的问题了)</li>
</ul>

<!-- ### 两种工作模式的对比

上一家公司走的是敏捷，虽然我们总在吐槽敏捷没什么卵用，但是换一个公司对比之下，感觉敏捷确实还是有它的优势。

上一家整个集团分了多个大的业务线，每个业务线下面又细分了很多团队，每个团队负责不同的业务。每个团队下都有前端，客户端，后台，测试，产品等角色。

现在的是这样子的，最小的单位是研发中心，产品中心等等。是按照职能部门区划分而不是业务线区划分的。

感觉后者会有不少问题。沟通成本+大家没有共同的目标，因为每个小单位有自己的目标或者KPI，我的目标是我的KPI，而我的协作方和我没有共同的KPI。所以大家没有共赢的那种意识。

之前那个，可能就是团队里前端人比较少，然后相对的领导都是后端的人。
 -->
]]></content>
		</item>
		
		<item>
			<title>Vue中相同页面跳转的问题及解决方案</title>
			<link>https://caychance.github.io/posts/vue%E4%B8%AD%E7%9B%B8%E5%90%8C%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link>
			<pubDate>Wed, 19 Jun 2019 17:31:40 +0800</pubDate>
			
			<guid>https://caychance.github.io/posts/vue%E4%B8%AD%E7%9B%B8%E5%90%8C%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid>
			<description>问题 也是最近做需求遇到的一个问题。首页的一个总台系统。如图页面顶部的导航条，其中*解决方案*这一项下面的四项一期都暂时不做，等下一个排期再做。
为了考虑用户体验，这四个点进去，都会进入同一个页面——敬请期待页面。
当然了，Vue中为了提高性能，相同的组件会被复用，也就是说，组件的生命周期钩子不会再次被调用。详细可参考-响应路由参数的变化
 提醒一下，当使用路由参数时，例如从 /user/foo 导航到 /user/bar，原来的组件实例会被复用。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。不过，这也意味着组件的生命周期钩子不会再被调用。
 解决方案 当然，文档中也给出了对应的解决方案。
方案1： 必须要设置该页面对应的router为动态路由。 path: &#39;/user/:id&#39;，否则也不会生效。
const User = { template: &amp;#39;...&amp;#39;, watch: { &amp;#39;$route&amp;#39; (to, from) { // 对路由变化作出响应...  } } }  方案2： 不知道是不是我用法不对：这个导航守卫只会触发一次。
const User = { template: &amp;#39;...&amp;#39;, beforeRouteUpdate (to, from, next) { // react to route changes...  // don&amp;#39;t forget to call next()  } }  方案3： 这个自己想了一个方法。
方法的弊端就是，如果多出页面涉及到该问题，需要依次去添加。
navigateTo (path) { if (!</description>
			<content type="html"><![CDATA[

<hr />

<h3 id="问题">问题</h3>

<p>也是最近做需求遇到的一个问题。首页的一个总台系统。如图页面顶部的导航条，其中*解决方案*这一项下面的四项一期都暂时不做，等下一个排期再做。</p>

<p><img src="https://blog-pics.pek3b.qingstor.com/f88c6218-9fc0-444b-af32-f9ed10347de5.png" alt="" /></p>

<p>为了考虑用户体验，这四个点进去，都会进入同一个页面——敬请期待页面。</p>

<p>当然了，Vue中为了提高性能，相同的组件会被复用，也就是说，组件的生命周期钩子不会再次被调用。详细可参考-<a href="https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html#%E5%93%8D%E5%BA%94%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%98%E5%8C%96">响应路由参数的变化</a></p>

<blockquote>
<p>提醒一下，当使用路由参数时，例如从 <code>/user/foo</code> 导航到 <code>/user/bar</code>，原来的组件实例会被复用。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。不过，这也意味着组件的生命周期钩子不会再被调用。</p>
</blockquote>

<h3 id="解决方案">解决方案</h3>

<p>当然，文档中也给出了对应的解决方案。</p>

<h4 id="方案1">方案1：</h4>

<p><strong>必须要设置</strong>该页面对应的router为动态路由。 <code>path: '/user/:id'</code>，否则也不会生效。</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="k">const</span> <span class="nx">User</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">template</span><span class="o">:</span> <span class="s1">&#39;...&#39;</span><span class="p">,</span>
  <span class="nx">watch</span><span class="o">:</span> <span class="p">{</span>
    <span class="s1">&#39;$route&#39;</span> <span class="p">(</span><span class="nx">to</span><span class="p">,</span> <span class="nx">from</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 对路由变化作出响应...
</span><span class="c1"></span>    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="方案2">方案2：</h4>

<p>不知道是不是我用法不对：这个导航守卫只会触发一次。</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="k">const</span> <span class="nx">User</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">template</span><span class="o">:</span> <span class="s1">&#39;...&#39;</span><span class="p">,</span>
  <span class="nx">beforeRouteUpdate</span> <span class="p">(</span><span class="nx">to</span><span class="p">,</span> <span class="nx">from</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// react to route changes...
</span><span class="c1"></span>    <span class="c1">// don&#39;t forget to call next()
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="方案3">方案3：</h4>

<p>这个自己想了一个方法。</p>

<p>方法的弊端就是，如果多出页面涉及到该问题，需要依次去添加。</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">navigateTo</span> <span class="p">(</span><span class="nx">path</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">path</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">path</span> <span class="o">===</span> <span class="s2">&#34;/stay-tuned&#34;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">$router</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span> <span class="nx">path</span> <span class="p">});</span>
    <span class="nx">location</span><span class="p">.</span><span class="nx">reload</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">$router</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span> <span class="nx">path</span> <span class="p">});</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>在vue中使用swiper遇到的一些问题</title>
			<link>https://caychance.github.io/posts/%E5%9C%A8vue%E4%B8%AD%E4%BD%BF%E7%94%A8swiper%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</link>
			<pubDate>Sun, 16 Jun 2019 16:40:47 +0800</pubDate>
			
			<guid>https://caychance.github.io/posts/%E5%9C%A8vue%E4%B8%AD%E4%BD%BF%E7%94%A8swiper%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</guid>
			<description>最近做需求，需要做一个轮播图，由于项(ben)目(ren)时(bi)间(jiao)紧(lan)，所以没有自己去写，而是去选择找了一个现成的，用的是swiper。
swiper官网上的不是针对vue的，但是API是一样的。vue中的用的是——vue-awesome-swiper。
有两件事情需要解决：
 分页器pagination的样式需要单独设定； 给分页器添加事件，做到点击分页器跳转至其对应的轮播图。  思路1：刚开始我的思路是可以使用swiper提供的api，来配置分页器,配置如图(PS:不知道还有没有别的办法)。然后再在页面mounted钩子的时候，操作dom给每个分页器添加方法。
但是，这个思路的问题： 开启自动轮播以后，轮播图的每次轮播，都会执行renderCustom方法来重新生成dom，总不能一直给dom添加方法吧。
... data() { return { swiperOption: { //分页器  pagination: { el: &amp;#34;.swiper-pagination&amp;#34;, type: &amp;#34;custom&amp;#34;, paginationClickable: true, renderCustom: function(swiper, current, total) { const activeOpacity = 0.7; const normalOpacity = 0.3; let opacity = &amp;#34;&amp;#34;; let paginationStyle = &amp;#34;&amp;#34;; let html = &amp;#34;&amp;#34;; for (let i = 1; i &amp;lt;= total; i++) { if (i === current) { opacity = activeOpacity; } else { opacity = normalOpacity; } paginationStyle = `background:#fff;border-radius:0;opacity:${opacity};width:45px;height:5px;margin-right:10px;border:3px solid;`; html += `&amp;lt;span class=&amp;#34;swiper-pagination-bullet&amp;#34; style=${paginationStyle}&amp;gt;&amp;lt;/span&amp;gt;`; } return html; } }, //前端后退按钮  // navigation: {  // nextEl: &amp;#34;.</description>
			<content type="html"><![CDATA[<hr />

<p>最近做需求，需要做一个轮播图，由于项(ben)目(ren)时(bi)间(jiao)紧(lan)，所以没有自己去写，而是去选择找了一个现成的，用的是swiper。</p>

<p>swiper官网上的不是针对vue的，但是API是一样的。vue中的用的是——<a href="https://github.com/surmon-china/vue-awesome-swiper">vue-awesome-swiper</a>。</p>

<p>有两件事情需要解决：</p>

<ol>
<li>分页器pagination的样式需要单独设定；</li>
<li>给分页器添加事件，做到点击分页器跳转至其对应的轮播图。</li>
</ol>

<p>思路1：刚开始我的思路是可以使用swiper提供的api，来配置分页器,配置如图(PS:不知道还有没有别的办法)。然后再在页面mounted钩子的时候，操作dom给每个分页器添加方法。</p>

<p>但是，这个思路的问题：
开启自动轮播以后，轮播图的每次轮播，都会执行renderCustom方法来重新生成dom，总不能一直给dom添加方法吧。</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="p">...</span> 
<span class="nx">data</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="nx">swiperOption</span><span class="o">:</span> <span class="p">{</span>
      <span class="c1">//分页器
</span><span class="c1"></span>      <span class="nx">pagination</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">el</span><span class="o">:</span> <span class="s2">&#34;.swiper-pagination&#34;</span><span class="p">,</span>
        <span class="nx">type</span><span class="o">:</span> <span class="s2">&#34;custom&#34;</span><span class="p">,</span>
        <span class="nx">paginationClickable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="nx">renderCustom</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">swiper</span><span class="p">,</span> <span class="nx">current</span><span class="p">,</span> <span class="nx">total</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">const</span> <span class="nx">activeOpacity</span> <span class="o">=</span> <span class="mf">0.7</span><span class="p">;</span>
          <span class="k">const</span> <span class="nx">normalOpacity</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">;</span>
          <span class="kd">let</span> <span class="nx">opacity</span> <span class="o">=</span> <span class="s2">&#34;&#34;</span><span class="p">;</span>
          <span class="kd">let</span> <span class="nx">paginationStyle</span> <span class="o">=</span> <span class="s2">&#34;&#34;</span><span class="p">;</span>
          <span class="kd">let</span> <span class="nx">html</span> <span class="o">=</span> <span class="s2">&#34;&#34;</span><span class="p">;</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">total</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">===</span> <span class="nx">current</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">opacity</span> <span class="o">=</span> <span class="nx">activeOpacity</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
              <span class="nx">opacity</span> <span class="o">=</span> <span class="nx">normalOpacity</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="nx">paginationStyle</span> <span class="o">=</span> <span class="sb">`background:#fff;border-radius:0;opacity:</span><span class="si">${</span><span class="nx">opacity</span><span class="si">}</span><span class="sb">;width:45px;height:5px;margin-right:10px;border:3px solid;`</span><span class="p">;</span>
            <span class="nx">html</span> <span class="o">+=</span> <span class="sb">`&lt;span class=&#34;swiper-pagination-bullet&#34; style=</span><span class="si">${</span><span class="nx">paginationStyle</span><span class="si">}</span><span class="sb">&gt;&lt;/span&gt;`</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="nx">html</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">},</span>
      <span class="c1">//前端后退按钮
</span><span class="c1"></span>      <span class="c1">// navigation: {
</span><span class="c1"></span>      <span class="c1">//   nextEl: &#34;.swiper-button-next&#34;,
</span><span class="c1"></span>      <span class="c1">//   prevEl: &#34;.swiper-button-prev&#34;
</span><span class="c1"></span>      <span class="c1">// },
</span><span class="c1"></span>      <span class="nx">autoplay</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
      <span class="nx">loop</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
      <span class="nx">speed</span><span class="o">:</span> <span class="mi">800</span>
      <span class="c1">// some swiper options/callbacks
</span><span class="c1"></span>      <span class="c1">// 所有的参数同 swiper 官方 api 参数
</span><span class="c1"></span>      <span class="c1">// ...
</span><span class="c1"></span>    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">}</span>
</code></pre></div>
<p>思路2：我先给分页器添加点击事件，然后再想办法处理样式问题。swiper官网上的示例，是直接操作dom给分页器添加事件的，不知道有没有更简单的方法。</p>

<p>这个思路的问题是：class等于swiper-pagination的样式在我当前页面是没法修改的，之前也遇到过类似情况，大多都是因为css设置了scoped属性倒置。</p>

<p>后来，就突发奇想，可以在node_modules包中把swiper的css修改。于是就找到<code>swiper/dist/css/swiper.css</code>文件，修改其中的对应处的css，然后把<code>import &quot;swiper/dist/css/swiper.css&quot;;</code>注释掉，引入我本地替换后的文件<code>import &quot;@assets/css/swiper.css&quot;;</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="o">&lt;</span><span class="nx">template</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">swiper</span> <span class="o">:</span><span class="nx">options</span><span class="o">=</span><span class="s2">&#34;swiperOption&#34;</span> <span class="nx">ref</span><span class="o">=</span><span class="s2">&#34;mySwiper&#34;</span> <span class="err">@</span><span class="nx">someSwiperEvent</span><span class="o">=</span><span class="s2">&#34;callback&#34;</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">swiper</span><span class="o">-</span><span class="nx">slide</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="err">/swiper-slide&gt;</span>
      <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">ref</span><span class="o">=</span><span class="s2">&#34;swiperPagination&#34;</span> <span class="k">class</span><span class="o">=</span><span class="s2">&#34;swiper-pagination&#34;</span> <span class="nx">slot</span><span class="o">=</span><span class="s2">&#34;pagination&#34;</span><span class="o">&gt;&lt;</span><span class="err">/div&gt;</span>
    <span class="o">&lt;</span><span class="err">/swiper&gt;</span>
  <span class="o">&lt;</span><span class="err">/div&gt;</span>
<span class="o">&lt;</span><span class="err">/template&gt;</span>
<span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
<span class="cm">/**
</span><span class="cm"> * 按照文档的要求是需要引入第一行的
</span><span class="cm"> * 由于样式需要可配置化
</span><span class="cm"> * 所以在node_modules中找到该css并修改对应的部分
</span><span class="cm"> */</span>
<span class="c1">// import &#34;swiper/dist/css/swiper.css&#34;;
</span><span class="c1"></span><span class="k">import</span> <span class="s2">&#34;@assets/css/swiper.css&#34;</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">swiper</span><span class="p">,</span> <span class="nx">swiperSlide</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&#34;vue-awesome-swiper&#34;</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="p">{</span>
  <span class="nx">data</span><span class="p">(){</span>
    <span class="k">return</span> <span class="p">{}</span>
  <span class="p">},</span>
  <span class="nx">computed</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">swiper</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">$refs</span><span class="p">.</span><span class="nx">mySwiper</span><span class="p">.</span><span class="nx">swiper</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="nx">methods</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">swiperChildrenList</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">$refs</span><span class="p">.</span><span class="nx">swiperPagination</span><span class="p">.</span><span class="nx">children</span><span class="p">;</span>
      <span class="nx">swiperChildrenList</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">style</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">swiperChildrenList</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">swiperChildrenList</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s2">&#34;click&#34;</span><span class="p">,</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">swiper</span><span class="p">.</span><span class="nx">slideTo</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
        <span class="p">});</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="nx">mounted</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">init</span><span class="p">();</span>
  <span class="p">},</span>
  <span class="nx">components</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">swiper</span><span class="p">,</span>
    <span class="nx">swiperSlide</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="o">&lt;</span><span class="err">/script&gt;</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>css3的动画</title>
			<link>https://caychance.github.io/posts/css3%E7%9A%84%E5%8A%A8%E7%94%BB/</link>
			<pubDate>Thu, 13 Jun 2019 19:54:06 +0800</pubDate>
			
			<guid>https://caychance.github.io/posts/css3%E7%9A%84%E5%8A%A8%E7%94%BB/</guid>
			<description> 最近在做一个中台门户网站，其中首页有不少动画效果。列举几个：
 鼠标悬浮div整体放大 鼠标悬浮整个div上移 鼠标悬浮第二个div向上运动覆盖第一个div  前公司有同事分享过css3中，2D转换，3D转换，过渡，动画之间的区别。
2D转换 2D转换主要用到transform属性，常用的值包括移动translate(x,y),旋转rotate(),缩放scale(x,y),倾斜skew(x,y),前四者合集matrix。
3D转换 3D转换用的也是transform属性。 主要是移动，旋转，缩放三者从X，Y，Z轴进行变换，或者X，Y，Z的合集。
过渡 transition 用途：从一种样式转变到另一种样式。
使用注意的点：
 常用于添加hover触发动画，哪个元素是动画的触发点，hover就加给该元素。 运动的元素需要添加transition:width|all 3s; 。 两元素之间的关系可以是同级兄弟元素，也可以是父子元素。  动画 用途：创建动画。
使用：
div { width:100px; height:100px; background:red; animation:myfirst 5s; } @keyframes myfirst { from {background:red;} to {background:yellow;} } 区别 列一下三者的区别，其实一看他们的英文意思，区别也就显而易见了。
 transform并不算真正意义上的动画，只是单纯做一下转变，你甚至都看不到这个转变的过程。 transition常用于hover的简单动画，一般就hover前后的两个状态。 animation属于真正意义上的动画，一般可以做复杂的动画。     属性 词义 异同 关注点 强调 帧动画     transform 转变 非动画 忽略 忽略 忽略   transition 过渡 简单动画 更关注css property的变化 强调过渡 只有两个关键帧   animation 动画 复杂动画 作用于元素本身而非样式属性 强调流程与控制 很多个关键帧    </description>
			<content type="html"><![CDATA[

<hr />

<p>最近在做一个中台门户网站，其中首页有不少动画效果。列举几个：</p>

<ol>
<li>鼠标悬浮div整体放大</li>
<li>鼠标悬浮整个div上移</li>
<li>鼠标悬浮第二个div向上运动覆盖第一个div</li>
</ol>

<p>前公司有同事分享过css3中，2D转换，3D转换，过渡，动画之间的区别。</p>

<h3 id="2d转换">2D转换</h3>

<p>2D转换主要用到<code>transform</code>属性，常用的值包括<em>移动</em><code>translate(x,y)</code>,<em>旋转</em><code>rotate()</code>,<em>缩放</em><code>scale(x,y)</code>,<em>倾斜</em><code>skew(x,y)</code>,前四者合集<code>matrix</code>。</p>

<h3 id="3d转换">3D转换</h3>

<p>3D转换用的也是<code>transform</code>属性。
主要是移动，旋转，缩放三者从X，Y，Z轴进行变换，或者X，Y，Z的合集。</p>

<h3 id="过渡-transition">过渡 transition</h3>

<p>用途：从一种样式转变到另一种样式。</p>

<p>使用注意的点：</p>

<ol>
<li>常用于添加hover触发动画，哪个元素是动画的触发点，hover就加给该元素。</li>
<li>运动的元素需要添加<code>transition:width|all 3s;</code> 。</li>
<li>两元素之间的关系可以是同级兄弟元素，也可以是父子元素。</li>
</ol>

<h3 id="动画">动画</h3>

<p>用途：创建动画。</p>

<p>使用：</p>
<div class="highlight"><pre class="chroma"><code class="language-css" data-lang="css"><span class="nt">div</span>
<span class="p">{</span>
	<span class="k">width</span><span class="p">:</span><span class="mi">100</span><span class="kt">px</span><span class="p">;</span>
	<span class="k">height</span><span class="p">:</span><span class="mi">100</span><span class="kt">px</span><span class="p">;</span>
	<span class="k">background</span><span class="p">:</span><span class="kc">red</span><span class="p">;</span>
	<span class="k">animation</span><span class="p">:</span><span class="n">myfirst</span> <span class="mi">5</span><span class="kt">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">@</span><span class="k">keyframes</span> <span class="nt">myfirst</span>
<span class="p">{</span>
	<span class="nt">from</span> <span class="p">{</span><span class="k">background</span><span class="p">:</span><span class="kc">red</span><span class="p">;}</span>
	<span class="nt">to</span> <span class="p">{</span><span class="k">background</span><span class="p">:</span><span class="kc">yellow</span><span class="p">;}</span>
<span class="p">}</span></code></pre></div>
<h3 id="区别">区别</h3>

<p>列一下三者的区别，其实一看他们的英文意思，区别也就显而易见了。</p>

<ul>
<li>transform并不算真正意义上的动画，只是单纯做一下转变，你甚至都看不到这个转变的过程。</li>
<li>transition常用于hover的简单动画，一般就hover前后的两个状态。</li>
<li>animation属于真正意义上的动画，一般可以做复杂的动画。</li>
</ul>

<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">词义</th>
<th align="center">异同</th>
<th align="center">关注点</th>
<th align="center">强调</th>
<th align="center">帧动画</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">transform</td>
<td align="center">转变</td>
<td align="center">非动画</td>
<td align="center">忽略</td>
<td align="center">忽略</td>
<td align="center">忽略</td>
</tr>

<tr>
<td align="center">transition</td>
<td align="center">过渡</td>
<td align="center">简单动画</td>
<td align="center">更关注css property的变化</td>
<td align="center">强调过渡</td>
<td align="center">只有两个关键帧</td>
</tr>

<tr>
<td align="center">animation</td>
<td align="center">动画</td>
<td align="center">复杂动画</td>
<td align="center">作用于元素本身而非样式属性</td>
<td align="center">强调流程与控制</td>
<td align="center">很多个关键帧</td>
</tr>
</tbody>
</table>
]]></content>
		</item>
		
		<item>
			<title>关于css中的z-index的使用</title>
			<link>https://caychance.github.io/posts/%E5%85%B3%E4%BA%8Ecss%E4%B8%AD%E7%9A%84z-index%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
			<pubDate>Wed, 12 Jun 2019 10:05:20 +0800</pubDate>
			
			<guid>https://caychance.github.io/posts/%E5%85%B3%E4%BA%8Ecss%E4%B8%AD%E7%9A%84z-index%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
			<description>&amp;lt;header&amp;gt; &amp;lt;div class=&amp;#34;nav&amp;#34;&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt; 产品服务 &amp;lt;div class=&amp;#34;content&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/header&amp;gt; &amp;lt;div class=&amp;#34;swiper&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; 如上代码，这几天在做一个需求的时候，突然发现z-index不生效了。
以上结构，header是网站的头部，div.swiper是header下面的轮播图。div.nav是头部的导航条，li是其中一个导航，li被鼠标hover的时候，显示div.content。最后的效果如图参考。
轮播图直接使用的swiper，还没有做swiper部分之前，hover那一块是没有问题的，swiper做了以后，发现hover就有问题了。后来排查了一下，是因为swiper的z-index设置为1。我心想这下好办了，把li的z-index设置成2不就好了。然而，并不好使。
 z-index只对定位元素有效果 position的属性值包括：absolute-绝对定位、relative-相对定位、fixed-固定定位、inherit-继承父元素定位，static-静态定位。前三者肯定有效；inherit取决于父元素；静态定位-static，否则z-index会无效。
 同一个父元素下的元素的层叠效果会受父元素的z-index影响 如果父元素的z-index值很小,那么子元素的z-index值很大也不起作用
 当前标签不能含有float属性 这个是在网上找到的，我自己验证了一下结论正好相反。
  </description>
			<content type="html"><![CDATA[<hr />
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">header</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;nav&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">ul</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">li</span><span class="p">&gt;</span>
        产品服务
        <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;content&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
      <span class="p">&lt;/</span><span class="nt">li</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">ul</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">header</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;swiper&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">div</span><span class="p">&gt;</span></code></pre></div>
<p><img src="https://blog-pics.pek3b.qingstor.com/c2ed4dc809ca.png" alt="" /></p>

<p>如上代码，这几天在做一个需求的时候，突然发现z-index不生效了。</p>

<p>以上结构，header是网站的头部，div.swiper是header下面的轮播图。div.nav是头部的导航条，li是其中一个导航，li被鼠标hover的时候，显示div.content。最后的效果如图参考。</p>

<p>轮播图直接使用的swiper，还没有做swiper部分之前，hover那一块是没有问题的，swiper做了以后，发现hover就有问题了。后来排查了一下，是因为swiper的z-index设置为1。我心想这下好办了，把li的z-index设置成2不就好了。然而，并不好使。</p>

<ul>
<li><p><strong>z-index只对定位元素有效果</strong> <br>
position的属性值包括：absolute-绝对定位、relative-相对定位、fixed-固定定位、inherit-继承父元素定位，static-静态定位。前三者肯定有效；inherit取决于父元素；静态定位-static，否则z-index会无效。</p></li>

<li><p><strong>同一个父元素下的元素的层叠效果会受父元素的z-index影响</strong> <br>
如果父元素的z-index值很小,那么子元素的z-index值很大也不起作用</p></li>

<li><p><strong>当前标签不能含有float属性</strong> <br>
这个是在网上找到的，我自己验证了一下结论正好相反。</p></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Todolist</title>
			<link>https://caychance.github.io/posts/todolist/</link>
			<pubDate>Thu, 06 Jun 2019 13:07:46 +0800</pubDate>
			
			<guid>https://caychance.github.io/posts/todolist/</guid>
			<description>刚接触新项目，有不少疑惑。在此列出来，后续做完项目或者做项目的过程当中，要把这些问题弄明白。
 之前都是用vue做的spa应用，这边使用vue做的是单/多页模板。这一块怎么配置的 使用的是hash的路由配置规则 脚手架是在vue cli3的基础上做的。需要深入学习一下vue cli3 项目中的sass只需要 npm install -D sass-loader node-sass 即可用。不需要webpack手动配置？ 改进一下自己的编程风格。主要就是平时写代码的时候，加上详细的注释。  /** * get 提交 * @param {String} url 请求的url * @param {any} params 请求的参数 * @param {Obejct} config 请求配置 * @returns Promise */ export function get(url, params = {}, config = {}) { let opts = {...config} opts.params = params return fetch.get(url, opts) } </description>
			<content type="html"><![CDATA[<hr />

<p>刚接触新项目，有不少疑惑。在此列出来，后续做完项目或者做项目的过程当中，要把这些问题弄明白。</p>

<ol>
<li>之前都是用vue做的spa应用，这边使用vue做的是单/多页模板。这一块怎么配置的</li>
<li>使用的是hash的路由配置规则</li>
<li>脚手架是在vue cli3的基础上做的。需要深入学习一下vue cli3</li>
<li>项目中的sass只需要 <code>npm install -D sass-loader node-sass</code> 即可用。不需要webpack手动配置？</li>
<li>改进一下自己的编程风格。主要就是平时写代码的时候，加上详细的注释。</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="cm">/**
</span><span class="cm"> * get 提交
</span><span class="cm"> * @param {String} url 请求的url
</span><span class="cm"> * @param {any} params  请求的参数
</span><span class="cm"> * @param {Obejct} config  请求配置
</span><span class="cm"> * @returns Promise
</span><span class="cm"> */</span>
<span class="k">export</span> <span class="kd">function</span> <span class="nx">get</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span> <span class="nx">params</span> <span class="o">=</span> <span class="p">{},</span> <span class="nx">config</span> <span class="o">=</span> <span class="p">{})</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">opts</span> <span class="o">=</span> <span class="p">{...</span><span class="nx">config</span><span class="p">}</span>
  <span class="nx">opts</span><span class="p">.</span><span class="nx">params</span> <span class="o">=</span> <span class="nx">params</span>
  <span class="k">return</span> <span class="nx">fetch</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span> <span class="nx">opts</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>随感2019-06</title>
			<link>https://caychance.github.io/posts/%E9%9A%8F%E6%84%9F2019-06/</link>
			<pubDate>Wed, 05 Jun 2019 20:11:34 +0800</pubDate>
			
			<guid>https://caychance.github.io/posts/%E9%9A%8F%E6%84%9F2019-06/</guid>
			<description>辗转许久，最终还是换了份工作。
希望可以在新公司和新岗位上更进一步成长。</description>
			<content type="html"><![CDATA[<hr />

<p>辗转许久，最终还是换了份工作。</p>

<p>希望可以在新公司和新岗位上更进一步成长。</p>
]]></content>
		</item>
		
		<item>
			<title>nodejs使用三两事之爬取</title>
			<link>https://caychance.github.io/posts/node%E4%BD%BF%E7%94%A8%E4%B8%89%E4%B8%A4%E4%BA%8B%E4%B9%8B%E7%88%AC%E5%8F%96/</link>
			<pubDate>Wed, 29 May 2019 23:48:31 +0800</pubDate>
			
			<guid>https://caychance.github.io/posts/node%E4%BD%BF%E7%94%A8%E4%B8%89%E4%B8%A4%E4%BA%8B%E4%B9%8B%E7%88%AC%E5%8F%96/</guid>
			<description>遇到这么一个问题，女朋友负责做某个汽车品牌的公关活动，平时每隔一段时间会有人发一些关于该品牌的一些文章，需要她们逐行去看并且得出一个结论，这篇文章是夸赞的，还是批评的？做好分类之后再发送给下一个环节。
 需求 输入一堆的url，根据不同的url来做不同的爬取规则。抓取到链接中的所有内容后，使用AI去分析当前段落或者文章的情感度，正面还是负面。（此例子中均用微信公众号中的链接去做抓取。）
 拆分
 step1: 把所有的url以数组的形式存在json中。其实也可以考虑做一个简单的页面，把所有的url以xml表格的形式上传并且读取。 step2: 确定爬取的规则和爬取的工具，自动爬取到数据并保存到本地。puppeteer step3: 确定分析段落或者文章的工具，自动来分析当前文章的情感度。腾讯的一个工具，收费的。   // index.js const puppeteer = require(&amp;#39;puppeteer&amp;#39;); const {fileWrite} = require(&amp;#39;./file-write&amp;#39;); const fs = require(&amp;#39;fs&amp;#39;); /** * readFile 把node的fs.readFile封装成promise形式 * @param {String} url */ const readFile = function (url) { return new Promise((resolve, reject) =&amp;gt; { fs.readFile(url, &amp;#39;utf-8&amp;#39;, (err, data) =&amp;gt; { if (err) reject(err); resolve(data); }) }) }; (async () =&amp;gt; { const browser = await puppeteer.</description>
			<content type="html"><![CDATA[<hr />

<p>遇到这么一个问题，女朋友负责做某个汽车品牌的公关活动，平时每隔一段时间会有人发一些关于该品牌的一些文章，需要她们逐行去看并且得出一个结论，这篇文章是夸赞的，还是批评的？做好分类之后再发送给下一个环节。</p>

<ul>
<li><p>需求
输入一堆的url，根据不同的url来做不同的爬取规则。抓取到链接中的所有内容后，使用AI去分析当前段落或者文章的情感度，正面还是负面。（此例子中均用微信公众号中的链接去做抓取。）</p></li>

<li><p>拆分</p>

<ul>
<li>step1: 把所有的url以数组的形式存在json中。其实也可以考虑做一个简单的页面，把所有的url以xml表格的形式上传并且读取。</li>
<li>step2: 确定爬取的规则和爬取的工具，自动爬取到数据并保存到本地。puppeteer</li>
<li>step3: 确定分析段落或者文章的工具，自动来分析当前文章的情感度。腾讯的一个工具，收费的。</li>
</ul></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// index.js
</span><span class="c1"></span><span class="k">const</span> <span class="nx">puppeteer</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;puppeteer&#39;</span><span class="p">);</span>
<span class="k">const</span> <span class="p">{</span><span class="nx">fileWrite</span><span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;./file-write&#39;</span><span class="p">);</span>
<span class="k">const</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">);</span>

<span class="cm">/**
</span><span class="cm"> * readFile 把node的fs.readFile封装成promise形式
</span><span class="cm"> * @param {String} url 
</span><span class="cm"> */</span>
<span class="k">const</span> <span class="nx">readFile</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">url</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span> <span class="s1">&#39;utf-8&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
      <span class="nx">resolve</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
    <span class="p">})</span>
  <span class="p">})</span>
<span class="p">};</span>

<span class="p">(</span><span class="kr">async</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">const</span> <span class="nx">browser</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">puppeteer</span><span class="p">.</span><span class="nx">launch</span><span class="p">({</span> <span class="nx">headless</span><span class="o">:</span> <span class="kc">false</span> <span class="p">})</span>
  <span class="k">const</span> <span class="nx">page</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">browser</span><span class="p">.</span><span class="nx">newPage</span><span class="p">()</span>
  <span class="k">const</span> <span class="nx">urlList</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="kr">await</span> <span class="nx">readFile</span><span class="p">(</span><span class="s1">&#39;./url.json&#39;</span><span class="p">))</span>
  <span class="kd">let</span> <span class="nx">temArr</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="p">{</span><span class="nx">url</span><span class="p">,</span><span class="nx">title</span><span class="p">,</span><span class="nx">author</span><span class="p">}</span> <span class="k">of</span> <span class="nx">urlList</span><span class="p">){</span>
    <span class="kr">await</span> <span class="nx">page</span><span class="p">.</span><span class="kr">goto</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
    <span class="k">const</span> <span class="nx">pageInnerText</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">page</span><span class="p">.</span><span class="nx">evaluate</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="c1">//浏览器中执行
</span><span class="c1"></span>      <span class="k">const</span> <span class="nx">pageDom</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;#img-content&#39;</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">pageDom</span><span class="p">.</span><span class="nx">innerText</span><span class="p">)</span> <span class="nx">retutn</span> <span class="p">;</span>
      <span class="k">return</span> <span class="p">{</span>
        <span class="nx">innerText</span><span class="o">:</span> <span class="nx">pageDom</span><span class="p">.</span><span class="nx">innerText</span><span class="p">,</span>
        <span class="nx">documentTitle</span><span class="o">:</span> <span class="nb">document</span><span class="p">.</span><span class="nx">title</span><span class="p">,</span>
      <span class="p">};</span>
    <span class="p">})</span>
    <span class="nx">temArr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">pageInnerText</span><span class="p">,{</span><span class="nx">url</span><span class="p">,</span><span class="nx">title</span><span class="p">,</span><span class="nx">author</span><span class="p">}))</span>
  <span class="p">}</span>
  <span class="nx">fileWrite</span><span class="p">(</span><span class="nx">temArr</span><span class="p">)</span>
  <span class="kr">await</span> <span class="nx">browser</span><span class="p">.</span><span class="nx">close</span><span class="p">()</span>
<span class="p">})()</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// file-write.js
</span><span class="c1"></span><span class="k">const</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">);</span>

<span class="cm">/**
</span><span class="cm"> * fileWrite 把爬取到的数据追加到message.json文件里面
</span><span class="cm"> * @param {Array} arr 
</span><span class="cm"> * @param {String} path 
</span><span class="cm"> */</span>
<span class="kd">function</span> <span class="nx">fileWrite</span><span class="p">(</span><span class="nx">arr</span><span class="o">=</span><span class="p">[],</span><span class="nx">path</span> <span class="o">=</span> <span class="s1">&#39;./message.json&#39;</span><span class="p">){</span>
  <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="s1">&#39;utf8&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">tem</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">err</span> <span class="o">&amp;&amp;</span> <span class="nx">err</span><span class="p">.</span><span class="nx">code</span> <span class="o">===</span> <span class="s1">&#39;ENOENT&#39;</span><span class="p">)</span> <span class="nx">tem</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="nx">tem</span> <span class="o">=</span> <span class="nx">data</span><span class="o">?</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span><span class="o">:</span><span class="p">[];</span>
    <span class="p">}</span>
    <span class="nx">tem</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">;</span>
    <span class="nx">fs</span><span class="p">.</span><span class="nx">writeFile</span><span class="p">(</span><span class="s1">&#39;message.json&#39;</span><span class="p">,</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">tem</span><span class="p">),</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">err</span><span class="p">;</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;数据已追加到文件&#39;</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">});</span>
<span class="p">}</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span><span class="nx">fileWrite</span><span class="p">};</span>
</code></pre></div>
<p>其实step3这一块很深，然后本身精力有限所以也只能使用一些现有的工具之类，当然感兴趣的朋友可以自己来做这一块。</p>
]]></content>
		</item>
		
		<item>
			<title>node使用三两事之图床更换</title>
			<link>https://caychance.github.io/posts/node%E4%BD%BF%E7%94%A8%E4%B8%89%E4%B8%A4%E4%BA%8B%E4%B9%8B%E5%9B%BE%E5%BA%8A%E6%9B%B4%E6%8D%A2/</link>
			<pubDate>Fri, 24 May 2019 16:34:15 +0000</pubDate>
			
			<guid>https://caychance.github.io/posts/node%E4%BD%BF%E7%94%A8%E4%B8%89%E4%B8%A4%E4%BA%8B%E4%B9%8B%E5%9B%BE%E5%BA%8A%E6%9B%B4%E6%8D%A2/</guid>
			<description>前几天微博可能是官方在采取防盗链措施，导致很多使用微博图床做博客的童鞋的图片全部都403了。所以准备换一个，之前注册了七牛云，但是没有实名认证，所以去实名认证了一下，结果，我把身份证正反面上传了，但是一直提示我上传失败，具体原因也没有，F12打开开发者模式，也看不到接口报错的信息。手机上试了2次，电脑上试了3次，然后放弃了。最后注册了青云。话说青云的服务还是挺不错的，希望可以一直坚持一下去，我注册了以后，就及时的打电话跟我沟通。
博客里面的图片需要手动替换吗 博客里面的图片是个烦心事，总不能手动去替换吧？
 需求： 使用node写一个脚本，替换掉blog中的所有新浪图床的图片链接。
 拆分：
 step1: 获取blog中的所有新浪图床图片的链接，并且保存起来data.json。 step2: 读取data.json文件，并把所有的图片保存在同级目录下的pics下。 step3: 使用青云的API自动上传pics下的所有图片。 step4: 使用新链接自动替换掉老连接。   step1
/** * Created by chenchen on 2019/5/22. */ let fs = require(&amp;#39;fs&amp;#39;); let path = require(&amp;#39;path&amp;#39;); let dirList = []; let result = {}; const _postsPath = path.resolve(__dirname,&amp;#39;./../source/_posts&amp;#39;); /** * promiseMethod 把node的异步方法转成promise形式 * @param {String} methodName 要修改的方法名 * @param {String} path 路径 * @param {any} param 请求配置 * @returns Promise */ const promiseMethod = function (methodName) { return function (path,param) { return new Promise((resolve,reject)=&amp;gt;{ methodName(path,param?</description>
			<content type="html"><![CDATA[

<hr />

<p>前几天微博可能是官方在采取防盗链措施，导致很多使用微博图床做博客的童鞋的图片全部都403了。所以准备换一个，之前注册了七牛云，但是没有实名认证，所以去实名认证了一下，结果，我把身份证正反面上传了，但是一直提示我上传失败，具体原因也没有，F12打开开发者模式，也看不到接口报错的信息。手机上试了2次，电脑上试了3次，然后放弃了。最后注册了<a href="https://console.qingcloud.com/">青云。</a>话说青云的服务还是挺不错的，希望可以一直坚持一下去，我注册了以后，就及时的打电话跟我沟通。</p>

<h3 id="博客里面的图片需要手动替换吗">博客里面的图片需要手动替换吗</h3>

<p>博客里面的图片是个烦心事，总不能手动去替换吧？</p>

<ul>
<li><p>需求：
使用node写一个脚本，替换掉blog中的所有新浪图床的图片链接。</p></li>

<li><p>拆分：</p>

<ul>
<li>step1: 获取blog中的所有新浪图床图片的链接，并且保存起来data.json。</li>
<li>step2: 读取data.json文件，并把所有的图片保存在同级目录下的pics下。</li>
<li>step3: 使用青云的API自动上传pics下的所有图片。</li>
<li>step4: 使用新链接自动替换掉老连接。</li>
</ul></li>
</ul>

<p>step1</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="cm">/**
</span><span class="cm"> * Created by chenchen on 2019/5/22.
</span><span class="cm"> */</span>

<span class="kd">let</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">path</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;path&#39;</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">dirList</span> <span class="o">=</span> <span class="p">[];</span>
<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">{};</span>
<span class="k">const</span>  <span class="nx">_postsPath</span> <span class="o">=</span> <span class="nx">path</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">,</span><span class="s1">&#39;./../source/_posts&#39;</span><span class="p">);</span>

<span class="cm">/**
</span><span class="cm"> * promiseMethod 把node的异步方法转成promise形式
</span><span class="cm"> * @param {String} methodName 要修改的方法名
</span><span class="cm"> * @param {String} path  路径
</span><span class="cm"> * @param {any} param  请求配置
</span><span class="cm"> * @returns Promise
</span><span class="cm"> */</span>
<span class="k">const</span> <span class="nx">promiseMethod</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">methodName</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">path</span><span class="p">,</span><span class="nx">param</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">)=&gt;{</span>
      <span class="nx">methodName</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span><span class="nx">param</span><span class="o">?</span><span class="nx">param</span><span class="o">:</span><span class="s1">&#39;utf-8&#39;</span><span class="p">,(</span><span class="nx">err</span><span class="p">,</span><span class="nx">data</span><span class="p">)=&gt;{</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
        <span class="k">else</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
      <span class="p">})</span>
    <span class="p">})</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">const</span> <span class="nx">readDirByPromise</span> <span class="o">=</span> <span class="nx">promiseMethod</span><span class="p">(</span><span class="nx">fs</span><span class="p">.</span><span class="nx">readdir</span><span class="p">);</span>
<span class="k">const</span> <span class="nx">readFileByPromise</span> <span class="o">=</span> <span class="nx">promiseMethod</span><span class="p">(</span><span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">);</span>
<span class="k">const</span> <span class="nx">writeFileByPromise</span> <span class="o">=</span> <span class="nx">promiseMethod</span><span class="p">(</span><span class="nx">fs</span><span class="p">.</span><span class="nx">writeFile</span><span class="p">);</span>

<span class="c1">//匹配出posts目录下的所有新浪图床的链接，并保存到data.json
</span><span class="c1"></span><span class="kr">async</span> <span class="kd">function</span> <span class="nx">getUrl</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">tempArr</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="nx">dirList</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">readDirByPromise</span><span class="p">(</span><span class="nx">_postsPath</span><span class="p">);</span>
  <span class="nx">dirList</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kr">async</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">item</span><span class="p">,</span><span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">data</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">readFileByPromise</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="nx">_postsPath</span><span class="si">}</span><span class="sb">/</span><span class="si">${</span><span class="nx">item</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">tempResult</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/https:\/\/blog\-pics[\S]*jpg/g</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">tempResult</span> <span class="k">instanceof</span> <span class="nb">Array</span><span class="p">){</span>
      <span class="nx">tempArr</span> <span class="o">=</span> <span class="nx">tempArr</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">tempResult</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">dirList</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span> <span class="o">===</span> <span class="nx">index</span><span class="p">){</span>
      <span class="nx">result</span> <span class="o">=</span> <span class="p">[...</span><span class="k">new</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">tempArr</span><span class="p">)];</span>
      <span class="nx">writeFileByPromise</span><span class="p">(</span><span class="s1">&#39;./data.json&#39;</span><span class="p">,</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">result</span><span class="p">));</span>
    <span class="p">}</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="nx">getUrl</span><span class="p">();</span>
</code></pre></div>
<p>step2</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="cm">/**
</span><span class="cm"> * Created by chenchen on 2019/5/23.
</span><span class="cm"> */</span>

<span class="kd">let</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">request</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;request&#39;</span><span class="p">);</span>

<span class="k">const</span> <span class="nx">promiseMethod</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">methodName</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">path</span><span class="p">,</span><span class="nx">param</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">)=&gt;{</span>
      <span class="nx">methodName</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span><span class="nx">param</span><span class="o">?</span><span class="nx">param</span><span class="o">:</span><span class="s1">&#39;utf-8&#39;</span><span class="p">,(</span><span class="nx">err</span><span class="p">,</span><span class="nx">data</span><span class="p">)=&gt;{</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
        <span class="k">else</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
      <span class="p">})</span>
    <span class="p">})</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**
</span><span class="cm"> * downLoadPic 下载图片到本地
</span><span class="cm"> * @param {String} url 下载图片的地址
</span><span class="cm"> * @param {String} filename  图片保存的名字
</span><span class="cm"> * @param {Function} callback  回调函数
</span><span class="cm"> * @returns null
</span><span class="cm"> */</span>
<span class="k">const</span> <span class="nx">downLoadPic</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">url</span><span class="p">,</span> <span class="nx">filename</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">request</span><span class="p">.</span><span class="nx">head</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">body</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;content-type:&#39;</span><span class="p">,</span> <span class="nx">res</span><span class="p">.</span><span class="nx">headers</span><span class="p">[</span><span class="s1">&#39;content-type&#39;</span><span class="p">]);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;content-length:&#39;</span><span class="p">,</span> <span class="nx">res</span><span class="p">.</span><span class="nx">headers</span><span class="p">[</span><span class="s1">&#39;content-length&#39;</span><span class="p">]);</span>
    <span class="nx">request</span><span class="p">(</span><span class="nx">url</span><span class="p">).</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">fs</span><span class="p">.</span><span class="nx">createWriteStream</span><span class="p">(</span><span class="nx">filename</span><span class="p">)).</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;close&#39;</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">}</span>

<span class="k">const</span> <span class="nx">readFile</span> <span class="o">=</span> <span class="nx">promiseMethod</span><span class="p">(</span><span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">);</span>

<span class="c1">// 读取step1中data.json中的url，然后依次下载保存。
</span><span class="c1"></span><span class="kr">async</span> <span class="kd">function</span> <span class="nx">getData</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">urlList</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">readFile</span><span class="p">(</span><span class="s1">&#39;./data.json&#39;</span><span class="p">);</span>
  <span class="nx">urlList</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">urlList</span><span class="p">);</span>
  <span class="nx">urlList</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">item</span><span class="p">,</span><span class="nx">index</span><span class="p">)=&gt;{</span>
    <span class="kd">let</span> <span class="nx">picName</span> <span class="o">=</span> <span class="nx">item</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/https:\/\/ws[0-9].sinaimg.cn\/large\/(.+).jpg/</span><span class="p">)[</span><span class="mi">1</span><span class="p">];</span>
    <span class="nx">downLoadPic</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span><span class="sb">`./pics/</span><span class="si">${</span><span class="nx">picName</span><span class="si">}</span><span class="sb">.jpg`</span><span class="p">,</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{});</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="nx">getData</span><span class="p">();</span>

<span class="c1">// downLoadPic(&#39;https://blog-pics.pek3b.qingstor.com/006tNbRwly1fxq5n1iao5j30go097gm9.jpg&#39;,&#39;./test.jpg&#39;,function () {
</span><span class="c1">//   console.log(&#39;down&#39;);
</span><span class="c1">// });
</span></code></pre></div>
<h3 id="分享一个面试题">分享一个面试题</h3>

<p>使用node遍历某个目录下的所有文件</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>

<span class="c1">// 方法1：同步方法读取
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">readDirSync</span><span class="p">(</span><span class="nx">path</span><span class="p">){</span>
  <span class="kd">let</span> <span class="nx">paths</span> <span class="o">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readdirSync</span><span class="p">(</span><span class="nx">path</span><span class="p">);</span>
  <span class="nx">paths</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">item</span><span class="p">=&gt;{</span>
    <span class="kd">let</span> <span class="nx">info</span> <span class="o">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">statSync</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="nx">path</span><span class="si">}</span><span class="sb">/</span><span class="si">${</span><span class="nx">item</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">info</span><span class="p">.</span><span class="nx">isDirectory</span><span class="p">()){</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;dir&#39;</span><span class="p">,</span><span class="nx">item</span><span class="p">);</span>
      <span class="nx">readDirSync</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="nx">path</span><span class="si">}</span><span class="sb">/</span><span class="si">${</span><span class="nx">item</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;file&#39;</span><span class="p">,</span><span class="nx">item</span><span class="p">);</span>
      <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">})</span>
<span class="p">}</span>
<span class="nx">readDirSync</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">);</span>

<span class="c1">// 方法2：异步方法读取
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">readDir</span><span class="p">(</span><span class="nx">path</span><span class="p">){</span>
  <span class="nx">fs</span><span class="p">.</span><span class="nx">readdir</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span><span class="nx">dirs</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">dirs</span><span class="p">)</span> <span class="k">return</span> <span class="p">;</span>
    <span class="nx">dirs</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">item</span><span class="p">=&gt;{</span>
      <span class="nx">fs</span><span class="p">.</span><span class="nx">stat</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="nx">path</span><span class="si">}</span><span class="sb">/</span><span class="si">${</span><span class="nx">item</span><span class="si">}</span><span class="sb">`</span><span class="p">,</span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span><span class="nx">info</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">info</span><span class="p">.</span><span class="nx">isDirectory</span><span class="p">()){</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;dir&#39;</span><span class="p">,</span><span class="nx">item</span><span class="p">);</span>
          <span class="nx">readDir</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="nx">path</span><span class="si">}</span><span class="sb">/</span><span class="si">${</span><span class="nx">item</span><span class="si">}</span><span class="sb">`</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">else</span><span class="p">{</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;file&#39;</span><span class="p">,</span><span class="nx">item</span><span class="p">);</span>
          <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">})</span>
    <span class="p">})</span>
  <span class="p">})</span>
<span class="p">}</span>
<span class="nx">readDir</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">);</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>webpack4.0学习笔记</title>
			<link>https://caychance.github.io/posts/webpack4-0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
			<pubDate>Fri, 26 Apr 2019 16:21:00 +0000</pubDate>
			
			<guid>https://caychance.github.io/posts/webpack4-0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
			<description>webpack是个大学问，此处仅记录自己学习webpack的笔记。最好的方法就是撸文档。
webpack官网
webpack是什么  本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。
 为什么要用webpack 常见功能 加载css 在js模块中import一个css文件
 style-loader css-loader  加载图片 加载字体  file-loader  加载数据  csv-loader xml-loader  常用的loader 常见loader loader是有执行顺序的，默认的执行顺序是从右至左，从下至上执行。 loader的类型：
 前置loader pre 普通loader normal 后置loader post 内联loader  css-loader style-loader 作用：在 DOM 里插入一个 &amp;lt;style&amp;gt; 标签，并且将 CSS 写入这个标签内。
其中 options 的选项是：
   name 含义     injectType Allows to setup how styles will be injected into the DOM   attributes Adds custom attributes to tag   insert Inserts tag at the given position into the DOM   base Sets module ID base (DLLPlugin)    injectType 的可选值包括：</description>
			<content type="html"><![CDATA[

<hr />

<p>webpack是个大学问，此处仅记录自己学习webpack的笔记。最好的方法就是撸文档。</p>

<p><a href="https://www.webpackjs.com/">webpack官网</a></p>

<h2 id="webpack是什么">webpack是什么</h2>

<blockquote>
<p>本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p>
</blockquote>

<h2 id="为什么要用webpack">为什么要用webpack</h2>

<h2 id="常见功能">常见功能</h2>

<h3 id="加载css">加载css</h3>

<p>在js模块中import一个css文件</p>

<ul>
<li>style-loader</li>
<li>css-loader</li>
</ul>

<h3 id="加载图片-加载字体">加载图片 加载字体</h3>

<ul>
<li>file-loader</li>
</ul>

<h3 id="加载数据">加载数据</h3>

<ul>
<li>csv-loader</li>
<li>xml-loader</li>
</ul>

<h2 id="常用的loader">常用的loader</h2>

<p><a href="https://www.webpackjs.com/loaders/">常见loader</a>
loader是有执行顺序的，默认的执行顺序是从右至左，从下至上执行。
loader的类型：</p>

<ol>
<li>前置loader pre</li>
<li>普通loader normal</li>
<li>后置loader post</li>
<li>内联loader</li>
</ol>

<h3 id="css-loader">css-loader</h3>

<h3 id="style-loader">style-loader</h3>

<p>作用：在 <code>DOM</code> 里插入一个 <code>&lt;style&gt;</code> 标签，并且将 <code>CSS</code> 写入这个标签内。</p>

<p>其中 <code>options</code> 的选项是：</p>

<table>
<thead>
<tr>
<th align="left">name</th>
<th align="left">含义</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">injectType</td>
<td align="left">Allows to setup how styles will be injected into the DOM</td>
</tr>

<tr>
<td align="left">attributes</td>
<td align="left">Adds custom attributes to tag</td>
</tr>

<tr>
<td align="left">insert</td>
<td align="left">Inserts tag at the given position into the DOM</td>
</tr>

<tr>
<td align="left">base</td>
<td align="left">Sets module ID base (DLLPlugin)</td>
</tr>
</tbody>
</table>

<p>injectType 的可选值包括：</p>

<table>
<thead>
<tr>
<th align="left">injectType可选值</th>
<th align="left">含义</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">styleTag</td>
<td align="left">每一次处理引入的样式文件都会在 DOM 上创建一个 <code>&lt;style&gt;</code> 标签</td>
</tr>

<tr>
<td align="left">singletonStyleTag</td>
<td align="left">将所有样式文件打在同一个 <code>&lt;style&gt;</code> 标签</td>
</tr>

<tr>
<td align="left">linkTag</td>
<td align="left">会通过 <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;&quot;&gt;</code> 的形式将样式插入到 <code>DOM</code> 中，需配合<code>file-loader</code>使用</td>
</tr>

<tr>
<td align="left">lazyStyleTag</td>
<td align="left">延迟加载</td>
</tr>

<tr>
<td align="left">lazySingletonStyleTag</td>
<td align="left">延迟加载</td>
</tr>
</tbody>
</table>

<h3 id="less-loader">less-loader</h3>

<p>less less-loader</p>

<h3 id="sass-loader">sass-loader</h3>

<p>加载sass/scss文件，并将其编译为css。</p>

<p>node-sass sass-loader</p>

<h3 id="stylus-loader">stylus-loader</h3>

<p>stylus stylus-loader</p>

<h3 id="postcss-loader">postcss-loader</h3>

<p>postcss-loader autoprefixer</p>

<h3 id="babel">babel</h3>

<p>babel-loader @babel/core @babel/preset-env</p>

<h3 id="eslint">eslint</h3>

<p>eslint-loader</p>

<h3 id="expose-loader">expose-loader</h3>

<p>代码中引入第三方模块，例如jquery，把jquery暴露给window</p>

<h3 id="file-loder-图片打包">file-loder 图片打包</h3>

<p>file-loader默认会在内部生成一张图片到build目录下，并且把生成的图片名字返回回来</p>

<h2 id="常用的plugin">常用的plugin</h2>

<h3 id="html-webpack-plugin">html-webpack-plugin</h3>

<p>动态生成一个html，并且这个html会加载当前打包完成后的所有bundle.js。</p>

<h3 id="clean-webpack-plugin">clean-webpack-plugin</h3>

<p>清理dist目录，每次打包前都会把上一次打包的文件删除掉。</p>

<h3 id="mini-css-extract-plugin">mini-css-extract-plugin</h3>

<h3 id="optimize-css-assets-webpack-plugin">optimize-css-assets-webpack-plugin</h3>

<p>压缩css 并且js还需要去压缩 使用uglifyjs-webpack-plugin</p>

<h3 id="webpack-provideplugin">webpack.ProvidePlugin</h3>

<p>在代码中引入第三方模块，例如jquery，可以在每个模块中引入jquery</p>

<p><a href="https://webpack.docschina.org/plugins/provide-plugin/">ProvidePlugin</a></p>

<h2 id="常用功能">常用功能</h2>

<ul>
<li>错误代码定位</li>
</ul>

<p>source map: 方便追踪错误代码或者警告在源代码中的原始位置。</p>

<ul>
<li>devServer</li>
</ul>

<p>webpack-dev-server: 提供一个简单的web服务器，并且能够实时重新加载。</p>

<ul>
<li>模块热替换</li>
</ul>

<p>Hot Module Replacement: 热更新</p>

<ul>
<li>压缩代码</li>
</ul>

<p>设置mode为production</p>

<p>uglifyjs-webpack-plugin</p>

<ul>
<li>打包后自动生成html</li>
</ul>

<p>html-webpack-plugin</p>

<p>html-webpack-template</p>

<ul>
<li>bundle分析</li>
</ul>

<p>webpack-chart: webpack 数据交互饼图。</p>

<p>webpack-visualizer: 可视化并分析你的 bundle，检查哪些模块占用空间，哪些可能是重复使用的。</p>

<p>webpack-bundle-analyzer: 一款分析 bundle 内容的插件及 CLI 工具，以便捷的、交互式、可缩放的树状图形式展现给用户。</p>

<h2 id="loader和plugin的区别">loader和plugin的区别</h2>

<p>loader</p>

<blockquote>
<p>webpack允许我们使用loader来处理文件，loader是一个导出为function的node模块。可以将匹配到的文件进行一次转换，同时loader可以链式传递。</p>
</blockquote>

<p>plugin</p>

<blockquote>
<p>webpack的plugin比loader强大，通过钩子可以涉及整个构建流程，可以做一些在构建范围内的事情。</p>
</blockquote>

<h2 id="module和chunk的区别">module和chunk的区别</h2>
]]></content>
		</item>
		
		<item>
			<title>面试小记</title>
			<link>https://caychance.github.io/posts/%E9%9D%A2%E8%AF%95%E5%B0%8F%E8%AE%B0/</link>
			<pubDate>Fri, 12 Apr 2019 23:53:48 +0000</pubDate>
			
			<guid>https://caychance.github.io/posts/%E9%9D%A2%E8%AF%95%E5%B0%8F%E8%AE%B0/</guid>
			<description>CSS部分 css三列布局，两边固定宽度，中间自适应 两栏布局(至少三种，float/absolute/flex) 三栏布局(双飞翼/圣杯/flex) BFC(产生条件、用途) 产生条件：
 body根元素 float元素 float不等于none 绝对定位 absolute fixed display等于inline-block、table-cells、flex overflow除了visible以外的值hidden、auto、scroll  BFC的用途/特性：
 同一个BFC中的margin会重叠 浮动的元素会脱离普通文档流，但是BFC却可以包含浮动的元素，即消除浮动。 BFC可以阻止元素被浮动元素覆盖。  传送门-BFC详细了解
用border画一个半圆/三角形  三角形  width: 0; height: 0; border-top: 50px solid blue; border-right: 50px solid red; border-bottom: 50px solid green; border-left: 50px solid yellow;  半圆  width: 100px; height: 50px; border-radius: 50px 50px 0 0; background: pink; 弹出框 实现向内旋转的效果(transform: rotateY) css3如何开启动画的GPU加速(translate3d(0, 0, 0)) 行内元素padding margin有用吗  padding有用 margin左右有用，上下无效。  盒模型有哪两种，区别是啥  IE盒模型 border-box width = content宽度+padding+border W3C盒模型 content-box width = content宽度  常用移动端适配方案，border 1px在dpr比较大的手机上咋解决  传送门-掘金-移动端适配总结 感觉这篇文章里的适配代码是个无敌的答案  css水平垂直居中  table-cell absolute transform:translate flex grid  flex align-item align-content的区别  容器属性  flex-direction 主轴的方向 flex-wrap 主轴一行展示不下，如何换行 justify-content 项目在主轴上的对齐方式 align-items 项目在交叉轴上的对齐方式 align-content 多根轴线如何对齐  项目属性  order 项目的排列顺序 越小越靠前 默认0 flex-grow 项目的放大比例 默认为0 等于0不会放大。大于0，如果有剩余空间的情况下，项目1为x1，项目2为x2，则项目1占剩余空间的x1/(x1+x2) flex-shrink 项目的缩小比例 默认为1 等于0不参与缩小。ul width 100px。两个li宽100px，默认每个li都会被缩小1/(1+1)=1/2。第一个li 2，第二个li 3，则第一个li被缩小2/(2+3)=2/5，被缩小的实际宽度为2/5*100=40，剩余宽度为60。第一个li 为0，如果第二个li为0，那么两者都不缩小，第二个li 大于0，那么li实际宽度，第一个li不缩小。 flex-basis 项目的占据主轴的空间 默认auto flex-self 该项目单独的对齐方式   单行，多行文本超出省略号  单行文本溢出  width: 100px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;  多行文本溢出  :和::代表啥  :伪类 ::伪元素  JS部分 基本类型和引用类型在内存中是如何存储的  基本类型存储在栈内存 引用类型存储在堆内存 栈内存中存的是引用类型在堆内存中的地址 或者说存的是引用类型的引用  事件委托和事件代理 一个ul里面有很多个li的时候，如果想让每个li都有一个点击事件，不需要给每个li都去添加，只需要给ul添加一个就行了。</description>
			<content type="html"><![CDATA[

<hr />

<h2 id="css部分">CSS部分</h2>

<h3 id="css三列布局-两边固定宽度-中间自适应">css三列布局，两边固定宽度，中间自适应</h3>

<h3 id="两栏布局-至少三种-float-absolute-flex">两栏布局(至少三种，float/absolute/flex)</h3>

<h3 id="三栏布局-双飞翼-圣杯-flex">三栏布局(双飞翼/圣杯/flex)</h3>

<h3 id="bfc-产生条件-用途">BFC(产生条件、用途)</h3>

<p>产生条件：</p>

<ul>
<li>body根元素</li>
<li>float元素 float不等于none</li>
<li>绝对定位 absolute fixed</li>
<li>display等于inline-block、table-cells、flex</li>
<li>overflow除了visible以外的值hidden、auto、scroll</li>
</ul>

<p>BFC的用途/特性：</p>

<ul>
<li>同一个BFC中的margin会重叠</li>
<li>浮动的元素会脱离普通文档流，但是BFC却可以包含浮动的元素，即消除浮动。</li>
<li>BFC可以阻止元素被浮动元素覆盖。</li>
</ul>

<p><a href="https://caychance.github.io/posts/bfc/">传送门-BFC详细了解</a></p>

<h3 id="用border画一个半圆-三角形">用border画一个半圆/三角形</h3>

<ul>
<li>三角形</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-css" data-lang="css"><span class="nt">width</span><span class="o">:</span> <span class="nt">0</span><span class="o">;</span>
<span class="nt">height</span><span class="o">:</span> <span class="nt">0</span><span class="o">;</span>
<span class="nt">border-top</span><span class="o">:</span> <span class="nt">50px</span> <span class="nt">solid</span> <span class="nt">blue</span><span class="o">;</span>
<span class="nt">border-right</span><span class="o">:</span> <span class="nt">50px</span> <span class="nt">solid</span> <span class="nt">red</span><span class="o">;</span>
<span class="nt">border-bottom</span><span class="o">:</span> <span class="nt">50px</span> <span class="nt">solid</span> <span class="nt">green</span><span class="o">;</span>
<span class="nt">border-left</span><span class="o">:</span> <span class="nt">50px</span> <span class="nt">solid</span> <span class="nt">yellow</span><span class="o">;</span></code></pre></div>
<ul>
<li>半圆</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-css" data-lang="css"><span class="nt">width</span><span class="o">:</span> <span class="nt">100px</span><span class="o">;</span>
<span class="nt">height</span><span class="o">:</span> <span class="nt">50px</span><span class="o">;</span>
<span class="nt">border-radius</span><span class="o">:</span> <span class="nt">50px</span> <span class="nt">50px</span> <span class="nt">0</span> <span class="nt">0</span><span class="o">;</span>
<span class="nt">background</span><span class="o">:</span> <span class="nt">pink</span><span class="o">;</span></code></pre></div>
<h3 id="弹出框">弹出框</h3>

<h3 id="实现向内旋转的效果-transform-rotatey">实现向内旋转的效果(transform: rotateY)</h3>

<h3 id="css3如何开启动画的gpu加速-translate3d-0-0-0">css3如何开启动画的GPU加速(translate3d(0, 0, 0))</h3>

<h3 id="行内元素padding-margin有用吗">行内元素padding margin有用吗</h3>

<ul>
<li>padding有用</li>
<li>margin左右有用，上下无效。</li>
</ul>

<h3 id="盒模型有哪两种-区别是啥">盒模型有哪两种，区别是啥</h3>

<ul>
<li>IE盒模型 border-box
width = content宽度+padding+border</li>
<li>W3C盒模型 content-box
width = content宽度</li>
</ul>

<h3 id="常用移动端适配方案-border-1px在dpr比较大的手机上咋解决">常用移动端适配方案，border 1px在dpr比较大的手机上咋解决</h3>

<ul>
<li><a href="https://juejin.im/post/5c0dd7ac6fb9a049c43d7edc">传送门-掘金-移动端适配总结</a> 感觉这篇文章里的适配代码是个无敌的答案</li>
</ul>

<h3 id="css水平垂直居中">css水平垂直居中</h3>

<ul>
<li>table-cell</li>
<li>absolute</li>
<li>transform:translate</li>
<li>flex</li>
<li>grid</li>
</ul>

<h3 id="flex-align-item-align-content的区别">flex  align-item align-content的区别</h3>

<ul>
<li>容器属性

<ul>
<li>flex-direction      主轴的方向</li>
<li>flex-wrap       主轴一行展示不下，如何换行</li>
<li>justify-content 项目在主轴上的对齐方式</li>
<li>align-items     项目在交叉轴上的对齐方式</li>
<li>align-content       多根轴线如何对齐</li>
</ul></li>
<li>项目属性

<ul>
<li>order           项目的排列顺序 越小越靠前 默认0</li>
<li>flex-grow       项目的放大比例
默认为0 等于0不会放大。大于0，如果有剩余空间的情况下，项目1为x1，项目2为x2，则项目1占剩余空间的x1/(x1+x2)</li>
<li>flex-shrink     项目的缩小比例
默认为1 等于0不参与缩小。ul width 100px。两个li宽100px，默认每个li都会被缩小1/(1+1)=1/2。第一个li 2，第二个li 3，则第一个li被缩小2/(2+3)=2/5，被缩小的实际宽度为2/5*100=40，剩余宽度为60。第一个li 为0，如果第二个li为0，那么两者都不缩小，第二个li 大于0，那么li实际宽度，第一个li不缩小。</li>
<li>flex-basis      项目的占据主轴的空间 默认auto</li>
<li>flex-self           该项目单独的对齐方式</li>
</ul></li>
</ul>

<h3 id="单行-多行文本超出省略号">单行，多行文本超出省略号</h3>

<ul>
<li>单行文本溢出</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-css" data-lang="css"><span class="nt">width</span><span class="o">:</span> <span class="nt">100px</span><span class="o">;</span>
<span class="nt">overflow</span><span class="o">:</span> <span class="nt">hidden</span><span class="o">;</span>
<span class="nt">text-overflow</span><span class="o">:</span> <span class="nt">ellipsis</span><span class="o">;</span>
<span class="nt">white-space</span><span class="o">:</span> <span class="nt">nowrap</span><span class="o">;</span></code></pre></div>
<ul>
<li>多行文本溢出</li>
</ul>

<h3 id="和-代表啥">:和::代表啥</h3>

<ul>
<li>:伪类</li>
<li>::伪元素</li>
</ul>

<h2 id="js部分">JS部分</h2>

<h3 id="基本类型和引用类型在内存中是如何存储的">基本类型和引用类型在内存中是如何存储的</h3>

<ul>
<li>基本类型存储在栈内存</li>
<li>引用类型存储在堆内存 栈内存中存的是引用类型在堆内存中的地址 或者说存的是引用类型的引用</li>
</ul>

<h3 id="事件委托和事件代理">事件委托和事件代理</h3>

<p>一个ul里面有很多个li的时候，如果想让每个li都有一个点击事件，不需要给每个li都去添加，只需要给ul添加一个就行了。</p>

<p>利用事件冒泡的原理。</p>

<h3 id="闭包-会导致的问题-如何解决">闭包 会导致的问题 如何解决</h3>

<p>闭包使用不当会导致内存溢出。因此，在退出函数之前，将不使用的局部变量全部删除。</p>

<h3 id="js的垃圾回收机制">js的垃圾回收机制</h3>

<ul>
<li>引用计数垃圾收集
概念：语言引擎有一张&rdquo;引用表&rdquo;，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放；
缺点：该算法有一个限制——循环引用。</li>
<li>标记-清除垃圾回收算法
2012年起，所有现代浏览器都是用了该算法</li>
</ul>

<h3 id="原生的ajax">原生的ajax</h3>

<p>XMLHttp​Request</p>

<h3 id="window-onload和document-onload的区别">window.onload和document.onload的区别</h3>

<ul>
<li>todo</li>
</ul>

<h3 id="match方法实现-支持-和-通配符">match方法实现，支持?和*通配符</h3>

<ul>
<li>todo</li>
</ul>

<h3 id="es6模块和commonjs模块的区别">ES6模块和CommonJs模块的区别</h3>

<ul>
<li>commonJs是被加载的时候运行，es6是编译的时候运行</li>
<li>commonJs输出的是值的浅拷贝，es6输出值的引用</li>
<li>commentJs具有缓存。在第一次被加载时，会完整运行整个文件并输出一个对象，拷贝（浅拷贝）在内存中。下次加载文件时，直接从内存中取值</li>
<li>参考链接
<a href="https://juejin.im/post/5ae04fba6fb9a07acb3c8ac5">传送门-掘金-CommonJs 和 ESModule 的 区别整理</a>
<a href="http://www.ruanyifeng.com/blog/2015/11/circular-dependency.html">传送门-JavaScript 模块的循环加载</a></li>
</ul>

<h3 id="es6新特性列举几个">es6新特性列举几个</h3>

<p><code>let/const</code>，<code>箭头函数</code>，<code>解构</code>，<code>模板字符串</code>，<code>Promise</code>，<code>Class</code></p>

<h3 id="var-let-const-区别">var/let/const 区别</h3>

<table>
<thead>
<tr>
<th align="center">声明方式</th>
<th align="center">变量提升</th>
<th align="center">重复声明</th>
<th align="center">暂时性死区</th>
<th align="center">初始值</th>
<th align="center">作用域</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">var</td>
<td align="center">允许</td>
<td align="center">允许</td>
<td align="center">不存在</td>
<td align="center">不需要</td>
<td align="center">除块级</td>
</tr>

<tr>
<td align="center">let</td>
<td align="center">不允许</td>
<td align="center">不允许</td>
<td align="center">存在</td>
<td align="center">需要</td>
<td align="center">块级</td>
</tr>

<tr>
<td align="center">const</td>
<td align="center">不允许</td>
<td align="center">不允许</td>
<td align="center">存在</td>
<td align="center">需要</td>
<td align="center">块级</td>
</tr>
</tbody>
</table>

<p>const实际上保证的，并<strong>不是变量的值不得改动</strong>，而是<strong>变量指向的那个内存地址所保存的数据不得改动</strong>。</p>

<h3 id="es6中object的方法-object-assign-合并对象是浅拷贝-深拷贝">es6中Object的方法  Object.assign()合并对象是浅拷贝，深拷贝</h3>

<ul>
<li>浅拷贝
Object.assign()</li>
<li>深拷贝

<ul>
<li>JSON.parse(JSON.stringify(obj))</li>
<li>手写一个深拷贝</li>
</ul></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="kd">function</span> <span class="nx">deepClone</span><span class="p">(</span><span class="nx">obj</span><span class="p">){</span>
  <span class="kd">let</span> <span class="nx">result</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">obj</span> <span class="o">===</span> <span class="s1">&#39;object&#39;</span><span class="p">){</span>
    <span class="nx">result</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">===</span> <span class="s1">&#39;Array&#39;</span> <span class="o">?</span> <span class="p">[]</span> <span class="o">:</span> <span class="p">{};</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">obj</span><span class="p">){</span>
      <span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">typeof</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="s1">&#39;object&#39;</span> <span class="o">?</span> <span class="nx">deepClone</span><span class="p">(</span><span class="nx">obj</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">:</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">result</span> <span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="es6模板字符串如何实现">es6模板字符串如何实现</h3>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">replace</span><span class="p">(</span><span class="nx">content</span><span class="p">){</span>
  <span class="k">return</span> <span class="nx">content</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/\$\{([^}]+)\}/g</span><span class="p">,</span><span class="kd">function</span><span class="p">(</span><span class="nx">matched</span><span class="p">,</span><span class="nx">childItem</span><span class="p">){</span>
    <span class="k">return</span> <span class="nb">eval</span><span class="p">(</span><span class="nx">childItem</span><span class="p">);</span>
  <span class="p">})</span>
<span class="p">}</span>
<span class="c1">//   /\$\{([^}]+)\}/g
</span><span class="c1"></span><span class="cm">/*
</span><span class="cm">这个正则匹配的内容就是${}，括号里面是除了}以外所有的字符，并且若干个
</span><span class="cm">*/</span>
</code></pre></div>
<h3 id="箭头函数和普通函数的区别">箭头函数和普通函数的区别</h3>

<ul>
<li>箭头函数声明时绑定this。</li>
<li>普通函数执行时绑定this</li>
<li>箭头函数不能用于<strong>构造函数</strong>，不能使用<strong>new</strong>，不能<strong>call,apply,bind</strong>，不能当作<strong>generator函数</strong>，不能使用<strong>yield</strong>，没有<strong>arguments</strong>，没有<strong>prototype</strong>。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="kd">var</span> <span class="nx">a</span><span class="o">=</span><span class="p">{</span>
  <span class="nx">func</span><span class="o">:</span><span class="kd">function</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span> 
<span class="kd">var</span> <span class="nx">b</span><span class="o">=</span><span class="nx">a</span><span class="p">.</span><span class="nx">func</span><span class="p">;</span> 

<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">func</span><span class="o">:</span><span class="p">()=&gt;</span><span class="k">this</span>
<span class="p">}</span> 
<span class="kd">var</span> <span class="nx">d</span><span class="o">=</span><span class="nx">c</span><span class="p">.</span><span class="nx">func</span>
<span class="c1">//a.func 输出a本身 	b(),c.func(),c()输出window
</span></code></pre></div>
<h3 id="继承-原型-原型链">继承 原型 原型链</h3>

<ul>
<li>使用ES5实现一个继承 <strong>核心是用一个 F 空的构造函数去取代执行了 Parent 这个构造函数。</strong></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="kd">function</span> <span class="nx">Parent</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">Parent</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;parent name:&#39;</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">Child</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">parentName</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">Parent</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">parentName</span><span class="p">);</span>  
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">create</span><span class="p">(</span><span class="nx">proto</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="nx">F</span><span class="p">(){}</span>
  <span class="nx">F</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">proto</span><span class="p">;</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nx">F</span><span class="p">();</span>
<span class="p">}</span>
<span class="nx">Child</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">create</span><span class="p">(</span><span class="nx">Parent</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
<span class="nx">Child</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;child name:&#39;</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">Child</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">=</span> <span class="nx">Child</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Parent</span><span class="p">(</span><span class="s1">&#39;father&#39;</span><span class="p">);</span>
<span class="nx">parent</span><span class="p">.</span><span class="nx">sayName</span><span class="p">();</span>    <span class="c1">// parent name: father
</span><span class="c1"></span>
<span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Child</span><span class="p">(</span><span class="s1">&#39;son&#39;</span><span class="p">,</span> <span class="s1">&#39;father&#39;</span><span class="p">);</span>
</code></pre></div>
<ul>
<li>ES6继承</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="k">class</span> <span class="nx">Father</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nx">Son</span> <span class="k">extends</span> <span class="nx">Father</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">(</span><span class="nx">parentName</span><span class="p">,</span><span class="nx">age</span><span class="p">){</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">parentName</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="数组去重">数组去重</h3>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// 方法1
</span><span class="c1"></span><span class="p">[...</span><span class="k">new</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">array</span><span class="p">)]</span>

<span class="c1">// 方法2
</span><span class="c1"></span><span class="nx">handle</span> <span class="o">=</span> <span class="nx">array</span><span class="p">=&gt;</span><span class="nx">array</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">p</span><span class="p">,</span><span class="nx">c</span><span class="p">)=&gt;{</span>
  <span class="o">!</span><span class="nx">p</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">p</span><span class="p">;</span>
<span class="p">},[])</span>
</code></pre></div>
<ul>
<li>遍历</li>
</ul>

<h3 id="数组的方法">数组的方法</h3>

<ul>
<li><code>forEach</code> <code>map</code> <code>reduce</code> <code>filter</code> <code>some</code> <code>every</code> <code>concat</code> <code>push</code> <code>pop</code> <code>unshift</code> <code>shift</code></li>
<li>用reduce实现map</li>
<li>用reduce计算[2, [3, 4], [4, [5, 6]]]里所有的值的和</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">sum</span> <span class="o">=</span> <span class="nx">array</span><span class="p">=&gt;</span><span class="nx">array</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">p</span><span class="p">,</span><span class="nx">c</span><span class="p">)=&gt;</span><span class="nx">p</span><span class="o">+</span><span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="o">?</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="o">:</span> <span class="nx">c</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div>
<ul>
<li>使用reduce实现flap方法</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">Flap</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">array</span><span class="p">){</span>
  <span class="k">return</span> <span class="nx">array</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span><span class="nx">c</span><span class="p">){</span>
    <span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="o">?</span> <span class="nx">myFlap</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="o">:</span> <span class="nx">c</span><span class="p">);</span>
  <span class="p">},[])</span>
<span class="p">}</span>

<span class="nx">myFlap</span> <span class="o">=</span> <span class="nx">array</span><span class="p">=&gt;</span><span class="nx">array</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">p</span><span class="p">,</span><span class="nx">c</span><span class="p">)=&gt;</span><span class="nx">p</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="o">?</span> <span class="nx">myFlap</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="o">:</span> <span class="nx">c</span><span class="p">),[])</span>
</code></pre></div>
<h3 id="for-in-for-of-for-遍历对象-缺点-只能遍历原型的属性">for in/for of/for 遍历对象 缺点 只能遍历原型的属性</h3>

<blockquote>
<p>for&hellip;in语句以任意顺序遍历一个对象自有的、继承的、可枚举的、非Symbol的属性。对于每个不同的属性，语句都会被执行。</p>

<p>for&hellip;of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句</p>
</blockquote>

<ul>
<li><p>for in</p>

<ol>
<li>可以遍历数组和对象。可以获取key和value。</li>
<li>适用于普通对象，并且做了对应的优化。但是不适用于数组，因此速度要慢 10-100 倍。（适用，适合的意思，而不是不能使用的意思。）</li>
<li>循环会遍历 所有属性，不仅仅是这些数字属性。</li>
</ol></li>

<li><p>for of</p>

<ol>
<li>可以遍历数组，<strong>不可遍历对象</strong>。只能获取value</li>
<li>性能更好</li>
<li>遍历具有迭代器属性的对象。因此如果某个对象有迭代器属性，也是可以遍历的。</li>
</ol></li>

<li><p>for循环就是遍历数组的方法。</p></li>
</ul>

<h3 id="如何判断一个数组">如何判断一个数组</h3>

<ul>
<li><code>arr instanceof Array</code></li>
<li><code>arr.constructor === Array</code></li>
<li><code>Object.prototype.toString.call(arr)</code></li>
<li><code>Array.isArray(arr)</code></li>
</ul>

<h3 id="如何判断一个对象是否为空对象">如何判断一个对象是否为空对象</h3>

<ul>
<li><code>for in</code></li>
<li><code>Object.keys()</code></li>
</ul>

<h3 id="如何判断一个类数组对象">如何判断一个类数组对象</h3>

<ul>
<li>本质还是一个对象</li>
<li>有一个length属性</li>
</ul>

<h3 id="异步的处理方式都有哪些">异步的处理方式都有哪些</h3>

<ul>
<li>回调函数</li>
<li>promise</li>
<li>generator</li>
<li>async/await</li>
</ul>

<p><a href="https://caychance.github.io/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A/">传送门-关于js中的异步</a></p>

<h3 id="promise和async-await">Promise和async/await</h3>

<h3 id="promise原理-手写">Promise原理 手写</h3>

<ul>
<li>Promise中存在三个状态    等待态pending 执行态fullfilled 拒绝态rejected</li>
<li>Promise状态不可逆  pending=&gt;fullfied  pending=&gt;rejected</li>
<li>Promise.then()方法返回一个Promise对象，因此可以链式调用</li>
<li>Promise接受的函数参数是同步执行的，但then方法中的回调函数则是异步的</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="c1">//promise声明
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">){</span>
  <span class="k">if</span><span class="p">(){</span><span class="c1">//成功
</span><span class="c1"></span>    <span class="nx">resolve</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">else</span><span class="p">{</span>
    <span class="nx">reject</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">});</span>
<span class="c1">//promise调用
</span><span class="c1"></span><span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">){</span>
  <span class="c1">// succ
</span><span class="c1"></span><span class="p">},</span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">){</span>
  <span class="c1">// fail
</span><span class="c1"></span><span class="p">})</span>
</code></pre></div>
<h3 id="promise封装settimeout">Promise封装setTimeOut</h3>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="nx">wait</span><span class="o">=</span><span class="nx">time</span><span class="p">=&gt;</span><span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">y</span><span class="p">=&gt;</span><span class="nx">setTimeout</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span><span class="nx">time</span><span class="p">))</span>
</code></pre></div>
<h3 id="async-await">async/await</h3>

<p>async/await是generator的语法糖。</p>

<p>async/await对generator的改进有以下几点：</p>

<ul>
<li>内置执行器

<ul>
<li>Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。</li>
</ul></li>
<li>更好的语义

<ul>
<li>async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</li>
</ul></li>
<li>更广的适用性

<ul>
<li>co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。所以，async函数的实现，就是把Generator函数和自动执行器包装在一个函数里。</li>
</ul></li>
<li>返回值是Promise

<ul>
<li>async函数的返回值是 Promise 对象。</li>
</ul></li>
</ul>

<h3 id="event-loop">Event Loop</h3>

<p>Event Loop分为<strong>浏览器中的Event Loop</strong>和<strong>Node中的Event Loop</strong></p>

<p><a href="https://caychance.github.io/posts/js-event-loop/">传送门-JS Event Loop</a></p>

<h3 id="浏览器中的event-loop">浏览器中的Event Loop</h3>

<blockquote>
<p>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</p>

<p>（2）主线程之外，还存在一个&rdquo;任务队列&rdquo;（task queue）。只要异步任务有了运行结果，就在&rdquo;任务队列&rdquo;之中放置一个事件。</p>

<p>（3）一旦&rdquo;执行栈&rdquo;中的所有同步任务执行完毕，系统就会读取&rdquo;任务队列&rdquo;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</p>

<p>（4）主线程不断重复上面的第三步。</p>
</blockquote>

<h3 id="node中的event-loop">Node中的Event Loop</h3>

<blockquote>
<p>（1）V8引擎解析JavaScript脚本。</p>

<p>（2）解析后的代码，调用Node API。</p>

<p>（3）libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），任务的执行结果会以异步的方式返回给V8引擎。</p>

<p>（4）V8引擎再将结果返回给用户。</p>
</blockquote>

<h3 id="宏任务和微任务的执行顺序">宏任务和微任务的执行顺序</h3>

<blockquote>
<p>（1）先执行宏任务，执行完后，查看是否有微任务队列</p>

<p>（2）如果有微任务队列，则执行微任务</p>

<p>（3）如果没有，则读取宏任务中排在最前列的任务</p>

<p>（4）执行宏任务的过程中遇到微任务，则加入微任务队列</p>

<p>（5）执行完宏任务后，查看是否有微任务队列</p>
</blockquote>

<h3 id="常见的宏任务和微任务">常见的宏任务和微任务</h3>

<ul>
<li>宏任务</li>
</ul>

<p>script、setTimeout、setInterval、setImmediate、requestAnimationFrame、I/O、UI Rendering</p>

<ul>
<li>微任务</li>
</ul>

<p>new Promise().then(回调)、Process.nextTick、Object.observe、MutationObserver</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="kr">async</span> <span class="kd">function</span> <span class="nx">async1</span><span class="p">(){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="kr">await</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="p">},</span><span class="mi">0</span><span class="p">)</span>
<span class="nx">async1</span><span class="p">();</span>
<span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
  <span class="nx">resolve</span><span class="p">();</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
<span class="p">});</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
<span class="c1">// 1 2 3 6 9 8 4 7 5
</span></code></pre></div>
<h3 id="node的执行顺序">Node的执行顺序</h3>

<p>数据输入 =&gt; poll轮询 =&gt; check检查 =&gt; close callbacks关闭事件回调 =&gt; timers定时器 =&gt; I/O callbacks I/O事件回调 =&gt; idle prepare 闲置 =&gt; 轮询</p>

<h3 id="同步任务和异步任务的定义">同步任务和异步任务的定义</h3>

<p>CPU会立即执行的任务是同步任务。</p>

<h3 id="node属于多线程还是单线程">node属于多线程还是单线程</h3>

<ul>
<li>单线程</li>
</ul>

<h3 id="node的前端模板">node的前端模板</h3>

<ul>
<li>ejs pug</li>
</ul>

<h3 id="node中间件的理解">node中间件的理解</h3>

<h3 id="node如何遍历整个目录里的所有文件">node如何遍历整个目录里的所有文件</h3>

<h3 id="process">process</h3>

<p>process对象是一个全局变量，它提供有关当前 Node.js 进程的信息并对其进行控制。</p>

<p>类似global全局对象，浏览器中的window。</p>

<h3 id="call-apply-bind的区别-手写">call apply bind的区别 手写？</h3>

<ul>
<li>三者都是改变this的指向。</li>
<li>区别call，apply返回函数执行的结果，bind则返回一个函数</li>
<li>其中call的参数是展开的数据，apply的参数是数组</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="c1">//call
</span><span class="c1"></span><span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">myCall</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">context</span><span class="o">=</span><span class="nb">window</span><span class="p">){</span>
  <span class="nx">context</span><span class="p">.</span><span class="nx">fn</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">args</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">arguments</span><span class="p">].</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">context</span><span class="p">.</span><span class="nx">fn</span><span class="p">(...</span><span class="nx">args</span><span class="p">);</span>
  <span class="k">delete</span> <span class="nx">context</span><span class="p">.</span><span class="nx">fn</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//apply
</span><span class="c1"></span><span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">myApply</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">context</span><span class="o">=</span><span class="nb">window</span><span class="p">){</span>
  <span class="nx">context</span><span class="p">.</span><span class="nx">fn</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">result</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">arguments</span><span class="p">[</span><span class="mi">1</span><span class="p">]){</span>
    <span class="nx">result</span> <span class="o">=</span> <span class="nx">context</span><span class="p">.</span><span class="nx">fn</span><span class="p">(...</span><span class="nx">arguments</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="k">else</span><span class="p">{</span>
    <span class="nx">result</span> <span class="o">=</span> <span class="nx">context</span><span class="p">.</span><span class="nx">fn</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">delete</span> <span class="nx">context</span><span class="p">.</span><span class="nx">fn</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//bind
</span><span class="c1"></span><span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">myBind</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">context</span><span class="p">){</span>
  <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="k">this</span> <span class="o">!==</span> <span class="s1">&#39;function&#39;</span><span class="p">){</span>
    <span class="k">throw</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;not a function&#39;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">fn</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">args</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">arguments</span><span class="p">].</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="kd">let</span> <span class="nx">bindFn</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span> <span class="k">instanceof</span> <span class="nx">bindFn</span> <span class="o">?</span> <span class="k">this</span> <span class="o">:</span> <span class="nx">context</span><span class="p">,</span> <span class="nx">args</span><span class="p">.</span><span class="nx">concat</span><span class="p">([...</span><span class="nx">arguments</span><span class="p">]));</span>
  <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">tem</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){};</span>
  <span class="nx">tem</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
  <span class="nx">bindFn</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">tem</span><span class="p">();</span>
  <span class="k">return</span> <span class="nx">bindFn</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="new发生了什么">new发生了什么</h3>

<ul>
<li>新建一个新对象</li>
<li>this指向新对象</li>
<li>为新对象添加属性</li>
<li>返回新对象</li>
</ul>

<h3 id="函数递归-f-n-返回1到n的累加和">函数递归 f(n) 返回1到n的累加和</h3>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">n</span><span class="p">){</span>
  <span class="kd">let</span> <span class="nx">result</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">n</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">){</span>
    <span class="nx">result</span> <span class="o">=</span> <span class="nx">n</span><span class="o">+</span><span class="nx">sum</span><span class="p">(</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span><span class="p">{</span>
    <span class="nx">result</span> <span class="o">=</span> <span class="nx">n</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="nx">sum</span> <span class="o">=</span> <span class="nx">n</span><span class="p">=&gt;</span><span class="nx">n</span><span class="o">&gt;</span><span class="mi">1</span> <span class="o">?</span> <span class="nx">n</span><span class="o">+</span><span class="nx">sum</span><span class="p">(</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="nx">n</span><span class="p">;</span>
</code></pre></div>
<h3 id="ssr-nuxt-next">SSR Nuxt Next</h3>

<ul>
<li>服务器端渲染</li>
</ul>

<h3 id="正则">正则</h3>

<ul>
<li>匹配所有非空白符 \S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</li>
<li>匹配非回车的字符</li>
<li>匹配所有字符</li>
<li>12345678变成12,345,678的正则</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">//方法1
</span><span class="c1"></span><span class="p">(</span><span class="nx">str</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/\B(?=(\d{3})+$)/g</span><span class="p">,</span> <span class="s1">&#39;,&#39;</span><span class="p">))</span>
<span class="c1">//方法2
</span><span class="c1"></span><span class="nx">str</span><span class="p">.</span><span class="nx">toLocaleString</span><span class="p">()</span>
</code></pre></div>
<ul>
<li>abc-def-hasdk-asdsa转换成驼峰</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">str</span> <span class="o">=</span> <span class="s1">&#39;abc-def-hasdk-asdsa&#39;</span><span class="p">;</span>
<span class="nx">str</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/[\-]{1}[a-z]{1}/g</span><span class="p">,</span><span class="nx">sel</span><span class="p">=&gt;</span><span class="nx">sel</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">toUpperCase</span><span class="p">())</span>
</code></pre></div>
<h3 id="instanceof-object-create-new的实现原理">instanceOf/Object.create/new的实现原理</h3>

<h3 id="已知">已知</h3>

<p>一个全部装着url的数组urls和一个叫fetch的ajax api，实现一个函数ajaxAll(urls, maxParallel, cb)，同时最多并行执行maxParallel个请求，所有url得到结果后执行cb</p>

<h3 id="求以下输出">求以下输出</h3>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="p">{</span><span class="nx">get</span><span class="p">(){</span><span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}})</span>
<span class="c1">// 循环引用 导致内存溢出
</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">){</span>
  <span class="nx">setTimeout</span><span class="p">(()=&gt;</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
<span class="p">}</span>
<span class="c1">//输出什么 如何修改
</span><span class="c1">//输出5个5
</span><span class="c1">//想输出1，2，3，4，5，可以使用let,IIFE,setTimeout第三个参数
</span></code></pre></div>
<h3 id="手写一个div的拖拽功能">手写一个div的拖拽功能</h3>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">style</span><span class="p">&gt;</span>
    <span class="nt">body</span><span class="p">{</span>
      <span class="k">position</span><span class="p">:</span> <span class="kc">relative</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">#</span><span class="nn">drag</span><span class="p">{</span>
      <span class="k">position</span><span class="p">:</span> <span class="kc">absolute</span><span class="p">;</span>
      <span class="k">width</span><span class="p">:</span> <span class="mi">100</span><span class="kt">px</span><span class="p">;</span>
      <span class="k">height</span><span class="p">:</span> <span class="mi">100</span><span class="kt">px</span><span class="p">;</span>
      <span class="k">background</span><span class="p">:</span> <span class="kc">red</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">&lt;/</span><span class="nt">style</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">&#39;drag&#39;</span><span class="p">&gt;</span>  
  <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
    <span class="kd">let</span> <span class="nx">oDiv</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;drag&#39;</span><span class="p">);</span>
    <span class="nx">oDiv</span><span class="p">.</span><span class="nx">onmousedown</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
      <span class="nx">e</span> <span class="o">=</span> <span class="nx">e</span> <span class="o">||</span> <span class="nb">window</span><span class="p">.</span><span class="nx">event</span><span class="p">;</span>
      <span class="kd">let</span> <span class="nx">disX</span> <span class="o">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">clientX</span> <span class="o">-</span> <span class="nx">oDiv</span><span class="p">.</span><span class="nx">offsetLeft</span><span class="p">;</span>
      <span class="kd">let</span> <span class="nx">disY</span> <span class="o">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">clientY</span> <span class="o">-</span> <span class="nx">oDiv</span><span class="p">.</span><span class="nx">offsetTop</span><span class="p">;</span>

      <span class="nb">document</span><span class="p">.</span><span class="nx">onmousemove</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
        <span class="nx">e</span> <span class="o">=</span> <span class="nx">e</span> <span class="o">||</span> <span class="nb">window</span><span class="p">.</span><span class="nx">event</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">l</span> <span class="o">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">clientX</span> <span class="o">-</span> <span class="nx">disX</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">clientY</span> <span class="o">-</span> <span class="nx">disY</span><span class="p">;</span>

        <span class="nx">oDiv</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="nx">l</span><span class="o">+</span><span class="s1">&#39;px&#39;</span><span class="p">;</span>
        <span class="nx">oDiv</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">top</span> <span class="o">=</span> <span class="nx">t</span><span class="o">+</span><span class="s1">&#39;px&#39;</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="nb">document</span><span class="p">.</span><span class="nx">onmouseup</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="nb">document</span><span class="p">.</span><span class="nx">onmousemove</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
        <span class="nb">document</span><span class="p">.</span><span class="nx">onmouseup</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span></code></pre></div>
<h3 id="写一个工厂函数用于生成对象">写一个工厂函数用于生成对象</h3>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">//工厂模式？
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">createPerson</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span><span class="nx">age</span><span class="p">,</span><span class="nx">job</span><span class="p">){</span>
  <span class="kd">let</span> <span class="nx">o</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">();</span>
  <span class="nx">o</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="nx">o</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
  <span class="nx">o</span><span class="p">.</span><span class="nx">job</span> <span class="o">=</span> <span class="nx">job</span><span class="p">;</span>
  <span class="nx">o</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">o</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="实现一个mylog函数">实现一个mylog函数</h3>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">//step1 mylog(str) 控制台输出str
</span><span class="c1"></span><span class="k">const</span> <span class="nx">mylog</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">str</span><span class="p">){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//step2 mylog(str1,str2,str3...) 控制台输出str1 str2 str3
</span><span class="c1"></span><span class="k">const</span> <span class="nx">mylog</span> <span class="o">=</span> <span class="p">(...</span><span class="nx">args</span><span class="p">)=&gt;{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(...</span><span class="nx">args</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//step3 不适用es6的语法，如何实现
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">mylog</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">join</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span><span class="s1">&#39; &#39;</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">//step4 更简单的方法
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">mylog</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span><span class="nx">arguments</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="弹出框-1">弹出框</h3>

<p>一个弹出框，最外面一层遮罩，然后遮罩中间有一个弹出框的div，点击非弹框外的部分，弹框就会关闭。</p>

<p>tips:阻止事件冒泡</p>

<h3 id="手写题">手写题</h3>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="o">&lt;</span><span class="nx">ul</span> <span class="nx">id</span><span class="o">=</span><span class="s1">&#39;ul&#39;</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">li</span><span class="o">&gt;</span><span class="mi">1</span><span class="o">&lt;</span><span class="err">/li&gt;</span>
  <span class="o">&lt;</span><span class="nx">li</span><span class="o">&gt;</span><span class="mi">2</span><span class="o">&lt;</span><span class="err">/li&gt;</span>
  <span class="o">&lt;</span><span class="nx">li</span><span class="o">&gt;</span><span class="mi">3</span><span class="o">&lt;</span><span class="err">/li&gt;</span>
<span class="o">&lt;</span><span class="err">/ul&gt;</span>

<span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
  <span class="kd">let</span> <span class="nx">list</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="s1">&#39;li&#39;</span><span class="p">);</span>

  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="nx">len</span><span class="o">=</span><span class="nx">list</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">len</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">){</span>
    <span class="nx">list</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">index</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
    <span class="nx">list</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">onclick</span><span class="o">=</span><span class="kd">function</span><span class="p">(){</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">index</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="o">&lt;</span><span class="err">/script&gt;</span>
</code></pre></div>
<h3 id="常用的手写">常用的手写</h3>

<ul>
<li>bind,call,apply</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">_call</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">context</span><span class="o">=</span><span class="nb">window</span><span class="p">){</span>
  <span class="nx">context</span><span class="p">.</span><span class="nx">fn</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">args</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">arguments</span><span class="p">].</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">context</span><span class="p">.</span><span class="nx">fn</span><span class="p">(...</span><span class="nx">args</span><span class="p">);</span>
  <span class="k">delete</span> <span class="nx">context</span><span class="p">.</span><span class="nx">fn</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">_apply</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">context</span><span class="o">=</span><span class="nb">window</span><span class="p">){</span>
  <span class="nx">context</span><span class="p">.</span><span class="nx">fn</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">result</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">arguments</span><span class="p">[</span><span class="mi">1</span><span class="p">]){</span>
    <span class="nx">result</span> <span class="o">=</span> <span class="nx">context</span><span class="p">.</span><span class="nx">fn</span><span class="p">(...</span><span class="nx">arguments</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
  <span class="p">}</span>
  <span class="k">else</span><span class="p">{</span>
    <span class="nx">result</span> <span class="o">=</span> <span class="nx">context</span><span class="p">.</span><span class="nx">fn</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="k">delete</span> <span class="nx">context</span><span class="p">.</span><span class="nx">fn</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">_bind</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">context</span><span class="p">){</span>
  <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="k">this</span> <span class="o">!==</span> <span class="s1">&#39;function&#39;</span><span class="p">){</span>
    <span class="k">throw</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;not a function&#39;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">fn</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">args</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">arguments</span><span class="p">].</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="kd">let</span> <span class="nx">bindFn</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="kd">let</span> <span class="nx">bindArgs</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>
    <span class="c1">// this的实例是bindFn，说明使用了new
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span> <span class="k">instanceof</span> <span class="nx">bindFn</span> <span class="o">?</span> <span class="k">this</span> <span class="o">:</span> <span class="nx">context</span><span class="p">,</span><span class="nx">args</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">bindArgs</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="c1">// bindFn继承this
</span><span class="c1"></span>  <span class="kd">function</span> <span class="nx">tem</span><span class="p">(){}</span>
  <span class="nx">tem</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
  <span class="nx">bindFn</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">tem</span><span class="p">();</span>
  <span class="k">return</span> <span class="nx">bindFn</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>new</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// myNew(fn, args) --&gt; new fn(args)
</span><span class="c1"></span><span class="cm">/*
</span><span class="cm">fn是构造函数
</span><span class="cm">1、创建一个新对象；
</span><span class="cm">2、将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；
</span><span class="cm">3、执行构造函数中的代码（为这个新对象添加属性）；
</span><span class="cm">4、返回新对象。
</span><span class="cm">*/</span>
<span class="kd">function</span> <span class="nx">myNew</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="p">...</span><span class="nx">args</span><span class="p">){</span>
  <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">fn</span> <span class="o">!==</span> <span class="s1">&#39;function&#39;</span><span class="p">){</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;not a function&#39;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">fn</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">){</span>
    <span class="nx">obj</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">prototype</span>
  <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span><span class="nx">args</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">res</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">res</span> <span class="o">===</span> <span class="s1">&#39;object&#39;</span> <span class="o">||</span> <span class="k">typeof</span> <span class="nx">res</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span><span class="p">)){</span>
    <span class="k">return</span> <span class="nx">res</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">obj</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>Object.create</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。 
</span><span class="c1">// var b = Object.create(obj)
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">create</span><span class="p">(</span><span class="nx">obj</span><span class="p">){</span>
  <span class="kd">function</span> <span class="nx">F</span><span class="p">(){}</span>
  <span class="nx">F</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">obj</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nx">F</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>instanceOf</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="cm">/*
</span><span class="cm">一直遍历 left的__proto__，一直遍历到null。
</span><span class="cm">如果到null之前都没有proto等于prototype就返回false
</span><span class="cm">*/</span>
<span class="kd">function</span> <span class="nx">instanceOf</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span><span class="nx">right</span><span class="p">){</span>
  <span class="kd">let</span> <span class="nx">proto</span> <span class="o">=</span> <span class="nx">left</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">prototype</span> <span class="o">=</span> <span class="nx">right</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="kc">true</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">proto</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">proto</span> <span class="o">===</span> <span class="nx">prototype</span><span class="p">)</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="nx">proto</span> <span class="o">=</span> <span class="nx">proto</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//这种写法更简洁吧
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">instanceOf</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span><span class="nx">right</span><span class="p">){</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">left</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">left</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nx">right</span><span class="p">.</span><span class="nx">prototye</span><span class="p">)</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="nx">left</span> <span class="o">=</span> <span class="nx">left</span><span class="p">.</span><span class="nx">__proto__</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>Promise</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// todo 手写promise
</span><span class="c1"></span><span class="k">const</span> <span class="nx">PENDING</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">const</span> <span class="nx">FULFILLED</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">const</span> <span class="nx">REJECTED</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">MyPromise</span><span class="p">(</span><span class="nx">fn</span><span class="p">){</span>
  <span class="kd">let</span> <span class="nx">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="nx">self</span><span class="p">.</span><span class="nx">val</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
  <span class="nx">self</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="nx">PENDING</span><span class="p">;</span>
  <span class="nx">self</span><span class="p">.</span><span class="nx">resolveQueue</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="nx">self</span><span class="p">.</span><span class="nx">rejectQueue</span> <span class="o">=</span> <span class="p">[];</span>

  <span class="kd">function</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">val</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">state</span> <span class="o">===</span> <span class="nx">PENGDING</span><span class="p">){</span>
      <span class="nx">setTimeout</span><span class="p">(()=&gt;{</span>
        <span class="nx">self</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="nx">FULFILLED</span><span class="p">;</span>
        <span class="nx">self</span><span class="p">.</span><span class="nx">val</span> <span class="o">=</span> <span class="nx">val</span><span class="p">;</span>
        <span class="nx">self</span><span class="p">.</span><span class="nx">resolveQueue</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">cb</span><span class="p">=&gt;</span><span class="nx">cb</span><span class="p">(</span><span class="nx">val</span><span class="p">))</span>
      <span class="p">})</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">err</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">state</span> <span class="o">===</span> <span class="nx">REJECTED</span><span class="p">){</span>
      <span class="nx">setTimeout</span><span class="p">(()=&gt;{</span>
        <span class="nx">self</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="nx">REJECTED</span><span class="p">;</span>
        <span class="nx">self</span><span class="p">.</span><span class="nx">val</span> <span class="o">=</span> <span class="nx">err</span><span class="p">;</span>
        <span class="nx">self</span><span class="p">.</span><span class="nx">rejectQueue</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">cb</span><span class="p">=&gt;</span><span class="nx">cb</span><span class="p">(</span><span class="nx">err</span><span class="p">))</span>
      <span class="p">})</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">try</span><span class="p">{</span>
    <span class="nx">fn</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">reject</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">MyPromise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">resolveFn</span><span class="p">,</span><span class="nx">rejectFn</span><span class="p">){</span>
  <span class="nx">resolveFn</span> <span class="o">=</span> <span class="k">typeof</span> <span class="nx">resolveFn</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span> <span class="o">?</span> <span class="nx">resolveFn</span> <span class="o">:</span> <span class="p">(</span><span class="nx">v</span><span class="p">=&gt;</span><span class="nx">v</span><span class="p">);</span>
  <span class="nx">rejectFn</span> <span class="o">=</span> <span class="k">typeof</span> <span class="nx">rejectFn</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span> <span class="o">?</span> <span class="nx">rejectFn</span> <span class="o">:</span> <span class="p">(</span><span class="nx">e</span><span class="p">=&gt;{</span><span class="k">throw</span> <span class="nx">e</span><span class="p">});</span>

  <span class="k">if</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">state</span> <span class="o">===</span> <span class="nx">FULFILLED</span><span class="p">){</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">MyPromise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">)=&gt;{</span>
      <span class="nx">setTimeout</span><span class="p">(()=&gt;{</span>
        <span class="k">try</span> <span class="p">{</span>
          <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">resolveFn</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">val</span><span class="p">);</span>
          <span class="k">if</span><span class="p">(</span><span class="nx">x</span> <span class="k">instanceof</span> <span class="nx">MyPromise</span><span class="p">){</span>
            <span class="nx">x</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">resolve</span><span class="p">)</span>
          <span class="p">}</span>
          <span class="k">else</span><span class="p">{</span>
            <span class="nx">resolve</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
          <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
        <span class="p">}</span>
      <span class="p">})</span>
    <span class="p">})</span>
  <span class="p">}</span>

  <span class="k">if</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">state</span> <span class="o">===</span> <span class="nx">REJECTED</span><span class="p">){</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">MyPromise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">)=&gt;{</span>
      <span class="nx">setTimeout</span><span class="p">(()=&gt;{</span>
        <span class="k">try</span> <span class="p">{</span>
          <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">rejectFn</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">val</span><span class="p">);</span>
          <span class="k">if</span><span class="p">(</span><span class="nx">x</span> <span class="k">instanceof</span> <span class="nx">MyPromise</span><span class="p">){</span>
            <span class="nx">x</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">reject</span><span class="p">)</span>
          <span class="p">}</span>
          <span class="k">else</span><span class="p">{</span>
            <span class="nx">resolve</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
          <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">){</span>
          <span class="k">throw</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
        <span class="p">}</span>
      <span class="p">})</span>
    <span class="p">})</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>flat</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">flat</span> <span class="o">=</span> <span class="nx">array</span><span class="p">=&gt;</span><span class="nx">array</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">p</span><span class="p">,</span><span class="nx">c</span><span class="p">)=&gt;</span><span class="nx">p</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="o">?</span> <span class="nx">flat</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="o">:</span> <span class="nx">c</span><span class="p">),[])</span>
</code></pre></div>
<ul>
<li>节流</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">throttle</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span><span class="nx">delay</span><span class="p">){</span>
  <span class="kd">let</span> <span class="nx">prev</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">();</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">(){</span>
    <span class="kd">let</span> <span class="nx">now</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">now</span><span class="o">-</span><span class="nx">prev</span><span class="o">&gt;</span><span class="nx">delay</span><span class="p">){</span>
      <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="nx">arguments</span><span class="p">);</span>
      <span class="nx">prev</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>防抖</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">debounce</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span><span class="nx">delay</span><span class="p">,</span><span class="nx">immediate</span><span class="p">){</span>
  <span class="kd">let</span> <span class="nx">timer</span><span class="p">;</span>
  <span class="k">return</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">immediate</span><span class="p">){</span>
      <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="nx">arguments</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">timer</span><span class="p">)</span> <span class="nx">clearTimeout</span><span class="p">(</span><span class="nx">timer</span><span class="p">);</span>
    <span class="nx">timer</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(()=&gt;{</span>
      <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="nx">arguments</span><span class="p">);</span>
    <span class="p">},</span><span class="nx">delay</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>继承</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">Father</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">Father</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;my name is &#39;</span><span class="p">,</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">Son</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span><span class="nx">fatherName</span><span class="p">){</span>
  <span class="c1">//step 1
</span><span class="c1"></span>  <span class="nx">Father</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="nx">fatherName</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">create</span><span class="p">(</span><span class="nx">Father</span><span class="p">){</span>
  <span class="c1">//step 2
</span><span class="c1"></span>  <span class="kd">function</span> <span class="nx">F</span><span class="p">(){};</span>
  <span class="nx">F</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">Father</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nx">F</span><span class="p">();</span>
<span class="p">}</span>

<span class="nx">Son</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">create</span><span class="p">(</span><span class="nx">Father</span><span class="p">);</span>
<span class="nx">Son</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">say</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;hello boy&#39;</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">Son</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">=</span> <span class="nx">Son</span><span class="p">;</span>
</code></pre></div>
<ul>
<li>参考链接
<a href="https://juejin.im/post/5c9edb066fb9a05e267026dc">传送门-掘金-【前端面试】同学，你会手写代码吗？</a>
<a href="https://juejin.im/post/5c9c3989e51d454e3a3902b6">传送门-「中高级前端面试」JavaScript手写代码无敌秘籍</a></li>
</ul>

<h2 id="vue部分">Vue部分</h2>

<h3 id="mvvm">MVVM</h3>

<p><img src="https://blog-pics.pek3b.qingstor.com/006tNc79ly1g2rmjd1xy1j30fg0brwei.jpg" alt="" /></p>

<ul>
<li><p>M:Model层
数据模型</p></li>

<li><p>V:View层
视图层</p></li>

<li><p>VM:ViewModel层
是Model和Controller之间的一座桥梁。</p></li>

<li><p>双向数据绑定
V和VM之间采用双向数据绑定，View的变动，会自动反映在ViewModel。反之亦然。</p></li>

<li><p>各部分之间的通讯都是双向的。
MVVM的设计思想：关注Model的变化，让MVVM框架去自动更新DOM的状态，从而把开发者从操作DOM的繁琐步骤中解脱出来。</p></li>
</ul>

<h3 id="单向数据流">单向数据流</h3>

<ul>
<li>M，VM和V中，数据流从M流向VM，再由VM去修改V。</li>
</ul>

<h3 id="vue提倡的是单向数据流-但是v-model是双向数据流-为什么">Vue提倡的是单向数据流，但是v-model是双向数据流，为什么?</h3>

<ul>
<li>v-model只是一个语法糖，本质还是单向数据流</li>
<li>v-bind:value和v-on:input</li>
</ul>

<h3 id="vue-use">vue.use()</h3>

<p>全局注入一个插件</p>

<h3 id="vue双向绑定实现原理-数据响应系统原理">Vue双向绑定实现原理/数据响应系统原理</h3>

<blockquote>
<p>Vue.js 是采用 Object.defineProperty 的 getter 和 setter，并结合观察者模式来实现数据绑定的。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。getter 做的事情是依赖收集，setter 做的事情是派发更新</p>
</blockquote>

<h3 id="vue中-数组的操作是如何实现数据响应的-push等原型函数以及为什么用-set">Vue中，数组的操作是如何实现数据响应的(push等原型函数以及为什么用$set)</h3>

<ul>
<li>todo</li>
</ul>

<h3 id="vue父组件向子组件通信-子组件向父组件通信-兄弟组件通信">Vue父组件向子组件通信，子组件向父组件通信，兄弟组件通信</h3>

<ul>
<li><code>props</code> <code>$emit</code></li>
</ul>

<h3 id="vue-3有哪些新的东西知道吗">vue 3有哪些新的东西知道吗</h3>

<ul>
<li>可以着重聊聊数据响应系统使用Proxy和原来的区别，<a href="https://www.html.cn/archives/10052">传送门</a></li>
<li>对Vue确实需要比较深的了解，推荐把这个看完 Vue技术内幕，不过这个里面没有AST的东西</li>
</ul>

<h3 id="以下代码经过模板渲染后变成了什么样子简单讲一下">以下代码经过模板渲染后变成了什么样子简单讲一下</h3>

<pre><code>&lt;parent :prop1=&quot;data1&quot;&gt;
  &lt;child :prop2=&quot;data2&quot;&gt;&lt;/child&gt;
&lt;/parent&gt;
</code></pre>

<h3 id="provide-inject能解决什么问题">provide/inject能解决什么问题</h3>

<ul>
<li>todo</li>
</ul>

<h3 id="computed和props-data的区别-其实现原理是什么">computed和props/data的区别，其实现原理是什么</h3>

<ul>
<li>todo</li>
</ul>

<h3 id="vue-router">Vue Router</h3>

<ul>
<li>主要有两种模式 <strong>hash模式</strong> <strong>history模式</strong></li>
<li><strong>本质</strong>就是监听url的变化，然后匹配路由规则，显示相应的页面，并且无需刷新</li>
<li>hash模式    点击跳转通过hashchange事件来监听到url的变化    手动刷新通过load事件</li>
<li>history模式     点击跳转通过pushState 浏览器动作 回退等 popState      刷新或者输入url 会向服务器发送请求 <strong>需要后端配合重定向</strong></li>
</ul>

<h3 id="vue-router中query和param的区别">Vue Router中query和param的区别</h3>

<ul>
<li>都可以在两个页面之间进行传值</li>
<li>query path?id=1 ; param path/1</li>
<li>param如果不在router中配置的话，页面刷新，param会丢失</li>
</ul>

<h3 id="vuex数据周期-如何使用-有什么好处">Vuex数据周期 如何使用 有什么好处</h3>

<p>state &ndash; dispatch &ndash;&gt; actions &ndash; commit &ndash;&gt; mutations</p>

<h3 id="vue-nexttick的原理-如何找到dom-依赖收集过程">vue.nextTick的原理 如何找到dom 依赖收集过程</h3>

<ul>
<li>nextTick是Vue的一个全局函数，用于处理dom更新操作。Vue里面有一个watcher，用于观察数据的变化，然后更新dom。Vue里面并不是每次数据变化都会触发更新dom，而是将这些操作都缓存在一个队列，在一个事件循环结束之后，刷新队列，统一执行dom操作。</li>
<li>watch的实现，当某个响应式数据发生变化的时候，它的setter函数会通知闭包中的Dep，Dep则会调用它管理的所有Watch对象。触发Watch对象的update实现。<strong>Watch对象并不是立即更新视图，而是被push进了一个队列queue，此时状态处于waiting的状态，这时候继续会有Watch对象被push进这个队列queue，等待下一个tick时，这些Watch对象才会被遍历取出，更新视图。</strong>同时，id重复的Watcher不会被多次加入到queue中去，因为在最终渲染时，我们只需要关心数据的最终结果。</li>
<li>Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。</li>
<li>Vue是异步执行dom更新的</li>
<li>Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。</li>
<li>源码中

<ul>
<li>2.5版本使用宏任务和微任务组合</li>
<li>源码中依次判断的逻辑：先看是否可以使用Promise，MutationObserver，setImmediate，setTimeout</li>
</ul></li>
</ul>

<h3 id="virtual-dom-diff算法具体实现过程">virtual-dom diff算法具体实现过程</h3>

<ul>
<li>diff算法源于snabbdom，复杂度为O(n)</li>
<li>只会在同层级比较，不会跨层级比较</li>
<li>重点是patch方法</li>
</ul>

<h3 id="patch方法详解">patch方法详解</h3>

<p>注释：vnode：新的虚拟节点 oldVnode：旧的虚拟节点</p>

<blockquote>
<ul>
<li>vnode不存在但是oldVnode存在，需要销毁oldVnode</li>
<li>oldVnode不存在但是vnode存在，创建新节点</li>
<li>oldVnode和vnode都存在

<ul>
<li>oldVnode和vnode是同一个节点 执行patchVnode方法</li>
<li>vnode创建真实dom并替换oldVnode.elm</li>
</ul></li>
</ul>
</blockquote>

<h3 id="patchvnode方法详解">patchVnode方法详解</h3>

<blockquote>
<ul>
<li>oldVnode和vnode完全一致，则不需要做任何事情</li>
<li>oldVnode和vnode都是静态节点，且具有相同的key，当vnode是克隆节点或是v-once指令控制的节点时，只需要把oldVnode.elm和oldVnode.child都复制到vnode上即可</li>
<li>vnode不是文本节点或注释节点

<ul>
<li>如果oldVnode和vnode都有子节点，且2方的子节点不完全一致，就执行updateChildren方法</li>
<li>只有oldVnode有子节点，那就把这些节点都删除</li>
<li>如果只有vnode有子节点，那就创建这些子节点</li>
<li>如果oldVnode和vnode都没有子节点，但是oldVnode是文本节点或注释节点，就把vnode.elm的文本设置为空字符串</li>
</ul></li>
<li>vnode是文本节点或注释节点，但是vnode.text != oldVnode.text时，只需要更新vnode.elm的文本内容就可以</li>
</ul>
</blockquote>

<h3 id="updatechildren方法详解">updateChildren方法详解</h3>

<blockquote>
<ul>
<li>oldStartIdx&gt;oldEndIdx
oldCh已经遍历完了，但是newCh还没有，把newStartIdx-newEndIdx之间的vnode都是新增的，把这些vnode添加到oldCh末尾</li>
<li>newStartIdx&gt;newEndIdx
newCh已经遍历完了，但是oldCh还没有，把oldCh中oldStartIdx-oldEndIdx之间的vnode删除</li>
<li>oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx

<ul>
<li>oldVnode第一个child不存在，oldStart索引右移</li>
<li>oldVnode最后一个child不存在，oldEnd索引左移</li>
<li>oldStartVnode和newStartVnode是同一个节点，patchVnode两个节点，索引右移</li>
<li>oldEndVnode和newEndVnode是同一个节点，patchVnode两个节点，索引左移</li>
<li>oldStartVnode和newEndVnode是同一个节点，移动oldStartVnode到oldEndVnode节点后面</li>
<li>oldEndVnode和newStartVnode是同一个节点，移动oldEndVnode到oldStartVnode前面</li>
<li>oldChildren中寻找跟newStartVnode具有相同key的节点，如果找不到相同key的节点，说明newStartVnode是一个新节点，就创建一个，然后把newStartVnode设置为下一个节点</li>
<li>如果找到了相同key的节点，比较两个节点是否属于同一个节点，如果属于同一节点，就patchVnode，否则新创建节点</li>
</ul></li>
</ul>
</blockquote>

<h3 id="为什么要使用key">为什么要使用key？</h3>

<p>不设key，newCh和oldCh只会进行头尾两端的相互比较，设key后，除了头尾两端的比较外，还会从用key生成的对象oldKeyToIdx中查找匹配的节点，所以为节点设置key可以更高效的利用dom。</p>

<h3 id="vue-react-angular区别">Vue,React,Angular区别</h3>

<h3 id="vue多端框架">Vue多端框架</h3>

<ul>
<li>uni-app</li>
</ul>

<h3 id="axios-拦截器">axios 拦截器</h3>

<ul>
<li>axios.interceptors.request.use</li>
<li>axios.interceptors.response.use</li>
<li>axios.default.header</li>
</ul>

<h2 id="wepack以及项目优化">Wepack以及项目优化</h2>

<h3 id="webpack打包原理">webpack打包原理</h3>

<h3 id="module和chunk的区别">module和chunk的区别</h3>

<h3 id="loader和plugin的区别">loader和plugin的区别</h3>

<ul>
<li>loader
loaders是在打包构建过程中用来处理源文件的(JSX,Scss,Less)，一次处理一个；</li>
<li>plugin
plugins并不直接操作单个文件，它直接对整个构建过程起作用。</li>
</ul>

<h3 id="webpack-4相比3有什么变化">webpack 4相比3有什么变化</h3>

<h3 id="webpack构建速度优化有哪些方式-这个能扯半个小时">webpack构建速度优化有哪些方式(这个能扯半个小时)</h3>

<h3 id="tree-shaking-scope-hoisting-code-spliting-都有什么作用">tree-shaking/scope-hoisting/code-spliting 都有什么作用</h3>

<h3 id="webpack热更新的模块">webpack热更新的模块</h3>

<ul>
<li>HotModuleReplacementPlugin</li>
<li>该模块是如何做到监听代码修改然后刷新页面的</li>
</ul>

<h3 id="webpack配置压缩一个js如何配置">webpack配置压缩一个js如何配置</h3>

<ul>
<li>webpack.base.conf.js  entry output module loaders</li>
</ul>

<h3 id="webpack编译后图片名为什么会改变">webpack编译后图片名为什么会改变</h3>

<h2 id="浏览器及安全">浏览器及安全</h2>

<h3 id="浏览器中支持最大的请求并发数">浏览器中支持最大的请求并发数</h3>

<p>chrome中是6</p>

<h3 id="阻止冒泡">阻止冒泡</h3>

<ul>
<li>stopPropagation<br /></li>
<li>cancelBubble</li>
</ul>

<h3 id="常见的浏览器安全问题">常见的浏览器安全问题</h3>

<ul>
<li>XSS 跨站脚本攻击</li>
</ul>

<blockquote>
<p>XSS 的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。</p>
</blockquote>

<ul>
<li>CSRF 跨站请求伪造攻击</li>
</ul>

<blockquote>
<p>1.浏览器登录信任网站A</p>

<p>2.通过验证，在浏览器中产生cookie</p>

<p>3.用户在没有登出A的情况下，访问危险网站B</p>

<p>4.B要求访问A网站，并发一个请求</p>

<p>5.根据B的要求，浏览器待着cookie访问A</p>
</blockquote>

<ul>
<li>SQL注入</li>
<li>命令行注入</li>
<li>DDos攻击</li>
</ul>

<blockquote>
<p>原理就是利用大量的请求造成资源过载，导致服务不可用</p>
</blockquote>

<ul>
<li>流量劫持

<ul>
<li>DNS劫持
<br /></li>
</ul></li>
</ul>

<blockquote>
<p>&ldquo;你打了一辆车想去商场吃饭，结果你打的车是小作坊派来的，直接给你拉到小作坊去了&rdquo;</p>
</blockquote>

<ul>
<li>HTTP劫持
<br /></li>
</ul>

<blockquote>
<p>&ldquo;你打了一辆车想去商场吃饭，结果司机跟你一路给你递小作坊的广告&rdquo;</p>
</blockquote>

<h3 id="chrome跨标签通信">chrome跨标签通信</h3>

<ul>
<li>获取句柄 postMessage</li>
<li>localStorage</li>
<li>cookie</li>
<li>SharedWorker</li>
</ul>

<h3 id="跨域">跨域</h3>

<ul>
<li>jsonp</li>
<li>CORS</li>
<li>WebSocket</li>
<li>Nginx代理</li>
<li>Node中间件代理 <code>http-proxy-middleware</code> <code>proxy-middleware</code></li>
</ul>

<h3 id="输入网址回车之后浏览器做了什么">输入网址回车之后浏览器做了什么</h3>

<p>以chrome为例：</p>

<ul>
<li>输入地址
会从历史记录，书签等地方智能提示补全url。查找缓存。</li>
<li>NDS解析</li>
<li>TCP请求</li>
<li>浏览器向服务器发送一个 HTTP 请求</li>
<li>服务器的永久重定向相应(如果有的话)</li>
<li>浏览器跟踪重定向地址</li>
<li>服务器处理请求</li>
<li>服务器返回一个 HTTP 响应</li>

<li><p>浏览器显示HTML</p></li>

<li><p>浏览器发送请求获取嵌入在 HTML 中的资源(图片，CSS，JS，音频，视频)</p></li>
</ul>

<p><a href="https://xianyulaodi.github.io/2017/03/22/%E8%80%81%E7%94%9F%E5%B8%B8%E8%B0%88-%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/">传送门-老生常谈-从输入url到页面展示到底发生了什么</a></p>

<h3 id="进程和线程">进程和线程</h3>

<ul>
<li>进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）</li>
<li>线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</li>
<li>进程是一个工厂，拥有独立的资源（独立的一块内存），进程之间相互独立，工厂中有一个或者多个工人（一个进程由一个或者多个线程组成）。</li>
<li>线程是工厂中的工人，工人共享空间（同一进程下的各个线程之间共享程序的内存空间）</li>
</ul>

<h3 id="chrome是多进程吗-为什么是多进程而不是多线程-包括哪些进程">Chrome是多进程吗，为什么是多进程而不是多线程，包括哪些进程</h3>

<ul>
<li>是多进程的。一个网页相当一个进程</li>
</ul>

<p>包括以下四个进程：</p>

<ul>
<li>Browser进程:浏览器的主进程（负责协调、主控），只有一个</li>
</ul>

<blockquote>
<p>负责浏览器界面显示，与用户交互。如前进，后退等
负责各个页面的管理，创建和销毁其他进程
将Renderer进程得到的内存中的Bitmap，绘制到用户界面上
网络资源的管理，下载等</p>
</blockquote>

<ul>
<li>第三方插件进程</li>
</ul>

<blockquote>
<p>每种类型的插件对应一个进程，仅当使用该插件时才创建看上面的图片中的“扩展程序”就是了</p>
</blockquote>

<ul>
<li><p>GPU进程:最多一个，用于3D绘制等</p></li>

<li><p>浏览器渲染进程（浏览器内核）:重点</p></li>
</ul>

<blockquote>
<p>Renderer进程，内部是多线程的
页面渲染，脚本执行，事件处理等</p>
</blockquote>

<h3 id="浏览器多进程的优势">浏览器多进程的优势</h3>

<ul>
<li>单个tab奔溃不会影响整个浏览器</li>
<li>避免第三方插件影响浏览器</li>
<li>多进程充分利用多核优势</li>
</ul>

<h3 id="chrome-渲染-render-进程包含哪些线程">Chrome 渲染(render)进程包含哪些线程</h3>

<ul>
<li>GUI渲染线程</li>
</ul>

<blockquote>
<p>负责渲染浏览器界面，解析HTML、CSS
当界面需要重绘（Repaint）或由于某种操作引发回流(Reflow)时，该线程就会执行
GUI渲染线程与JS引擎线程是互斥的，因为JS可以操作DOM元素， 从而影响到GUI的渲染结果，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行</p>
</blockquote>

<ul>
<li>JS引擎线程</li>
</ul>

<blockquote>
<p>JS内核（例如V8引擎），负责处理Javascript脚本程序
JS引擎一直等待着任务队列中任务的到来，然后加以处理
GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行时间过长，页面渲染就不连贯，造成页面渲染加载阻塞</p>
</blockquote>

<ul>
<li>事件触发线程</li>
</ul>

<blockquote>
<p>由于JS引擎这个单线程的家伙自己都忙不过来，所以需要浏览器另开一个线程协助它
待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</p>
</blockquote>

<ul>
<li>定时触发器线程</li>
</ul>

<blockquote>
<p>setInterval与setTimeout所在线程
JS引擎阻塞状态下计时不准确，所以由浏览器另开线程单独计时
计时完毕后，添加到事件队列中，等待JS引擎空闲后执行
W3C规定，setTimeout中低于4ms的时间间隔算为4ms</p>
</blockquote>

<ul>
<li>异步HTTP请求线程</li>
</ul>

<blockquote>
<p>如果请求有回调事件，异步线程就产生状态变更事件，将这个回调再放入事件队列中，等JS引擎空闲后执行</p>
</blockquote>

<p><a href="https://github.com/amandakelake/blog/issues/55">传送门-浏览器工作原理：从输入URL到页面加载完成</a></p>

<h3 id="chrome是如何实现settimout的">Chrome是如何实现setTimout的</h3>

<p><strong>todo</strong></p>

<h3 id="如何监控前端性能">如何监控前端性能</h3>

<p><strong>todo</strong></p>

<h3 id="前端性能优化">前端性能优化</h3>

<p><strong>todo</strong></p>

<h3 id="浏览器缓存机制">浏览器缓存机制</h3>

<ul>
<li>强制缓存</li>
<li>协商缓存</li>
<li>先判断是否命中强缓存，如果命中，则不请求服务器，直接从缓存中返回数据；</li>
<li>如果未命中，则向服务器发送一个请求，再判断是否命中协商缓存，如果命中，更新缓存，然后缓存中返回数据</li>
<li>如果均未命中，则向服务器发送请求，服务器返回数据。</li>
</ul>

<h2 id="网络相关">网络相关</h2>

<h3 id="http状态码">Http状态码</h3>

<ul>
<li>1**   信息类</li>
<li>2**   成功</li>
<li>3**   重定向类    301永久重定向 302临时重定向</li>
<li>4**   客户端出错</li>
<li>5**   服务器出错</li>
<li>200成功/204无内容</li>
<li>301永久重定向/302临时重定向/304未修改</li>
<li>401未授权/403禁止访问/404未找到/405请求方式不对</li>
<li>500服务器内部错误/502错误网关/503服务不可用/504服务器超时</li>
</ul>

<h3 id="http常见请求方法以及简单描述">Http常见请求方法以及简单描述</h3>

<p><code>get</code> <code>post</code> <code>head</code> <code>options</code> <code>delete</code> <code>put</code></p>

<h3 id="http-header中都有哪些信息">Http header中都有哪些信息</h3>

<p><code>Accept</code>，<code>Connection</code>，<code>Content-Type</code>，<code>Expires</code>，<code>Server</code>，<code>Etag</code>，<code>Last-Modified</code>，<code>Server</code>，<code>Date</code>，<code>Cache-Control</code>，<code>User-Agent</code>等。</p>

<h3 id="http和https的区别">Http和Https的区别</h3>

<p>Http主要有三点不足。</p>

<ul>
<li>通信使用明文，未加密。导致内容可能会被窃听。</li>
<li>不验证通讯方的身份。有可能遭遇伪装。</li>
<li>无法证明报文的完整性。有可能已遭篡改。</li>
</ul>

<p>Https的出现也是为了解决上述问题。因此：
Http+加密+认证+完整新保护 = Https。
Https是身披SSL外壳的Http。SSL协议在Http和Tcp协议之间。</p>

<h3 id="tcp三次握手过程">TCP三次握手过程</h3>

<p><img src="https://blog-pics.pek3b.qingstor.com/006tNc79ly1g2w0tmm5q9j30rs0a8gpa.jpg" alt="" /></p>

<ul>
<li>第一次握手。client发送一个<strong>SYN(J)</strong>包给server，等待server的ACK回复，进入<code>SYN-SENT</code>状态。</li>
<li>第二次握手。server接收到SYN(seq=J)包后就返回一个<strong>ACK(J+1)</strong>包以及一个自己的<strong>SYN(K)</strong>包，然后等待client的ACK回复，server进入<code>SYN-RECIVED</code>状态。</li>
<li>第三次握手。client接收到server发回的ACK(J+1)包后，进入<code>ESTABLISHED</code>状态。然后根据server发来的SYN(K)包，返回给等待中的server一个<strong>ACK(K+1)</strong>包。等待中的server收到ACK回复，也把自己的状态设置为<code>ESTABLISHED</code>。</li>
</ul>

<h3 id="为什么要三次握手">为什么要三次握手</h3>

<p>为了确保通讯双方都有收发信息的能力。</p>

<h3 id="tcp四次挥手">TCP四次挥手</h3>

<p><img src="https://blog-pics.pek3b.qingstor.com/006tNc79ly1g2w0vh8dq6j30rs0cwq6e.jpg" alt="" /></p>

<ul>
<li>第一次挥手。client发送一个<strong>FIN(M)</strong>包，此时client进入<code>FIN-WAIT-1</code>状态，这表明client已经没有数据要发送了。</li>
<li>第二次挥手。server收到了client发来的FIN(M)包后，向client发回一个<strong>ACK(M+1)</strong>包，此时server进入<code>CLOSE-WAIT</code>状态，client进入<code>FIN-WAIT-2</code>状态。</li>
<li>第三次挥手。server向client发送<strong>FIN(N)</strong>包，请求关闭连接，同时server进入<code>LAST-ACK</code>状态。</li>
<li>第四次挥手。client收到server发送的FIN(N)包，进入<code>TIME-WAIT</code>状态。向server发送<strong>ACK(N+1)</strong>包，server收到client的ACK(N+1)包以后，进入<code>CLOSE</code>状态；client等待一段时间还没有得到回复后判断server已正式关闭，进入<code>CLOSE</code>状态。</li>
</ul>

<h3 id="为什么tcp建立连接是三次而关闭连接要多一次">为什么TCP建立连接是三次而关闭连接要多一次</h3>

<p>因为server的ACK和FIN是分开发送了，因此关闭多了一次。
client发送一个FIN包，表示client已经没有数据要发送了。但是此时server可能还会有未发送的数据，因此server也要发送一个FIN包。</p>

<h3 id="https认证过程">Https认证过程</h3>

<ul>
<li>浏览器发送一个连接请求给安全服务器。</li>
<li>服务器将自己的证书，以及同证书相关的信息发送给客户浏览器。</li>
<li>客户浏览器检查服务器送过来的证书是否是由自己信赖的 CA 中心所签发的。如果是，就继续执行协议；如果不是，客户浏览器就给客户一个警告消息：警告客户这个证书不是可以信赖的，询问客户是否需要继续。</li>
<li>接着客户浏览器比较证书里的消息，例如域名和公钥，与服务器刚刚发送的相关消息是否一致，如果是一致的，客户浏览器认可这个服务器的合法身份。</li>
<li>服务器要求客户发送客户自己的证书。收到后，服务器验证客户的证书，如果没有通过验证，拒绝连接；如果通过验证，服务器获得用户的公钥。</li>
<li>客户浏览器告诉服务器自己所能够支持的通讯对称密码方案。</li>
<li>服务器从客户发送过来的密码方案中，选择一种加密程度最高的密码方案，用客户的公钥加过密后通知浏览器。</li>
<li>浏览器针对这个密码方案，选择一个通话密钥，接着用服务器的公钥加过密后发送给服务器。</li>
<li>服务器接收到浏览器送过来的消息，用自己的私钥解密，获得通话密钥。</li>
<li>服务器、浏览器接下来的通讯都是用对称密码方案，对称密钥是加过密的。</li>
</ul>

<h3 id="http2相比http1多了什么">HTTP2相比HTTP1多了什么</h3>

<ul>
<li><p><strong>新的二进制格式</strong>（Binary Format），HTTP1.x的解析是基于文本。
基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</p></li>

<li><p><strong>多路复用</strong>（MultiPlexing）
即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</p></li>

<li><p><strong>header压缩</strong>
如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</p></li>

<li><p><strong>服务端推送</strong>（server push）
同SPDY一样，HTTP2.0也具有server push功能。</p></li>
</ul>

<h3 id="http2的多路复用和http-1-1的keep-alive有什么区别">HTTP2的多路复用和HTTP 1.1的keep-alive有什么区别</h3>

<ul>
<li><p>HTTP/1.0 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；</p></li>

<li><p>HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；</p></li>

<li><p>HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行。</p></li>
</ul>

<h3 id="cookie">cookie</h3>

<ul>
<li>expires   过期时间</li>
<li>domain    域名</li>
<li>path  路径</li>
<li>security  安全情况下才传输给服务器 https</li>
<li>httponly  js是否可以操作</li>
<li>如何防止js访问cookie，如何限制只能在https中才能访问cookie(set-cookie相关字段)</li>
</ul>

<h3 id="websocket是如何建立连接的">websocket是如何建立连接的</h3>

<h2 id="算法">算法</h2>

<h3 id="递归的复杂度">递归的复杂度</h3>

<h3 id="快排的时间复杂度和空间复杂度">快排的时间复杂度和空间复杂度</h3>

<h3 id="冒泡排序">冒泡排序</h3>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">a</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">){</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">j</span><span class="o">&lt;</span><span class="nx">a</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="nx">j</span><span class="o">++</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span><span class="o">&gt;</span><span class="nx">a</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]){</span>
      <span class="p">[</span><span class="nx">a</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span><span class="nx">a</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">a</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="nx">a</span><span class="p">[</span><span class="nx">j</span><span class="p">]];</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="给个数组和n-找到数组里的三个数相加是n-复杂度要求o-n-2-logn">给个数组和n，找到数组里的三个数相加是n，复杂度要求O(n^2*logn)</h3>

<h3 id="对数组-2-3-3-2-5-进行多重相邻去重-第一次去重后结果-2-2-5-然后得到-5-复杂度要求o-n">对数组[2, 3, 3, 2, 5]进行多重相邻去重(第一次去重后结果[2, 2, 5]，然后得到[ 5 ])，复杂度要求O(n)</h3>

<h3 id="给一个二叉树-每个节点有value-找到是否存在一条路径-从根路径到叶节点的value相加为n">给一个二叉树，每个节点有value，找到是否存在一条路径，从根路径到叶节点的value相加为n</h3>

<h3 id="给一个二叉树-找到深度为n的一层-这一层的节点是所有层中最多的一层">给一个二叉树，找到深度为n的一层，这一层的节点是所有层中最多的一层</h3>

<h3 id="二叉树广度优先遍历">二叉树广度优先遍历</h3>

<h3 id="给一个二维数组-写一个函数-回字形走法-走过的节点不能再走-走到不能走为止">给一个二维数组，写一个函数，回字形走法，走过的节点不能再走，走到不能走为止</h3>

<h3 id="给一个二维数组-如-0-0-0-1-0-0-0-1-0-1不能经过0能经过-给一个起点和一个终点-找到一条到终点的路径">给一个二维数组，如[[0, 0, 0], [1, 0, 0], [0, 1, 0]]，1不能经过0能经过，给一个起点和一个终点，找到一条到终点的路径</h3>

<h3 id="反转链表">反转链表</h3>

<h3 id="数组类">数组类</h3>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="cm">/*
</span><span class="cm">一个数组arr，不新建变量，过滤掉arr中大于5的，并输出arr
</span><span class="cm">*/</span>
<span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="nx">len</span><span class="o">=</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">len</span><span class="p">;){</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">5</span><span class="p">){</span>
    <span class="nx">arr</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span><span class="p">{</span>
    <span class="nx">i</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="其他">其他</h2>

<h3 id="项目优化的点">项目优化的点</h3>

<ul>
<li>html标签语义化</li>
<li>高效的css</li>
<li>图片压缩，尽可能不用图片</li>
<li>js等代码优化</li>
<li>减少http请求</li>
<li>打包后的代码压缩</li>
<li>PWA</li>
<li>webpack按需加载</li>
<li>cdn</li>
<li>骨架屏</li>
</ul>

<h3 id="项目中做过比较复杂的东西如何解决">项目中做过比较复杂的东西如何解决</h3>

<h3 id="mysql">MySQL</h3>

<h3 id="鸡兔同笼-70脚-20头">鸡兔同笼 70脚 20头</h3>

<ul>
<li>20只动物都收起两只脚，这个时候，就剩下了30只脚</li>
<li>30只脚全是兔子的，这个时候每只兔子只有2只脚，所以有15个兔子</li>
</ul>

<h3 id="两个村庄-a村庄一定生两个不管男女-b村庄生出第一个男孩就不生了-这俩村庄的男女比例">两个村庄 A村庄一定生两个不管男女，B村庄生出第一个男孩就不生了 这俩村庄的男女比例</h3>

<h3 id="推荐几个链接">推荐几个链接</h3>

<p><a href="https://juejin.im/post/5c9edb066fb9a05e267026dc">传送门-【前端面试】同学，你会手写代码吗？</a></p>

<p><a href="https://juejin.im/post/5c9c3989e51d454e3a3902b6">传送门-「中高级前端面试」JavaScript手写代码无敌秘籍</a></p>

<p><a href="https://juejin.im/post/5c71434a6fb9a049fa10633c">传送门-前端笔试之手写代码(一)</a></p>

<p>小米 百度 猿辅导 瓜子 VIPKide 爱奇艺 阿里 滴滴 美团</p>
]]></content>
		</item>
		
		<item>
			<title>diff算法</title>
			<link>https://caychance.github.io/posts/diff%E7%AE%97%E6%B3%95/</link>
			<pubDate>Tue, 02 Apr 2019 19:08:09 +0000</pubDate>
			
			<guid>https://caychance.github.io/posts/diff%E7%AE%97%E6%B3%95/</guid>
			<description>Virtual DOM 因为如果在项目中大量的操作dom会很影响性能，所以Vue和React都尝试使用虚拟dom（virtual dom）。虚拟dom的本质其实就是用一个对象去描述整个dom结构，包括：当前dom的tag标签，data，children子节点，text文本，elm，key等等等，属性很多，就不一一列举了。
virtual dom真的比DOM操作效率高吗？不一定，那使用virtual dom的优势是什么呢？
使用虚拟dom的优势：
 不用手动频繁操作dom 框架跨平台 可以更好的实现SSR，同构渲染 组件的高度抽象化  总之，大大的提高了我们的工作效率。
export default class VNode { tag: string | void; data: VNodeData | void; children: ?Array&amp;lt;VNode&amp;gt;; text: string | void; elm: Node | void; ns: string | void; context: Component | void; // rendered in this component&amp;#39;s scope  key: string | number | void; componentOptions: VNodeComponentOptions | void; componentInstance: Component | void; // component instance  parent: VNode | void; // component placeholder node  // strictly internal  raw: boolean; // contains raw HTML?</description>
			<content type="html"><![CDATA[

<hr />

<h3 id="virtual-dom">Virtual DOM</h3>

<p>因为如果在项目中大量的操作dom会很影响性能，所以Vue和React都尝试使用虚拟dom（virtual dom）。虚拟dom的本质其实就是用一个对象去描述整个dom结构，包括：当前dom的tag标签，data，children子节点，text文本，elm，key等等等，属性很多，就不一一列举了。</p>

<p>virtual dom真的比DOM操作效率高吗？不一定，那使用virtual dom的优势是什么呢？</p>

<p>使用虚拟dom的优势：</p>

<ol>
<li>不用手动频繁操作dom</li>
<li>框架跨平台</li>
<li>可以更好的实现SSR，同构渲染</li>
<li>组件的高度抽象化</li>
</ol>

<p>总之，<strong>大大的提高了我们的工作效率。</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="k">export</span> <span class="k">default</span> <span class="k">class</span> <span class="nx">VNode</span> <span class="p">{</span>
  <span class="nx">tag</span><span class="o">:</span> <span class="nx">string</span> <span class="o">|</span> <span class="k">void</span><span class="p">;</span>
  <span class="nx">data</span><span class="o">:</span> <span class="nx">VNodeData</span> <span class="o">|</span> <span class="k">void</span><span class="p">;</span>
  <span class="nx">children</span><span class="o">:</span> <span class="o">?</span><span class="nb">Array</span><span class="o">&lt;</span><span class="nx">VNode</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="nx">text</span><span class="o">:</span> <span class="nx">string</span> <span class="o">|</span> <span class="k">void</span><span class="p">;</span>
  <span class="nx">elm</span><span class="o">:</span> <span class="nx">Node</span> <span class="o">|</span> <span class="k">void</span><span class="p">;</span>
  <span class="nx">ns</span><span class="o">:</span> <span class="nx">string</span> <span class="o">|</span> <span class="k">void</span><span class="p">;</span>
  <span class="nx">context</span><span class="o">:</span> <span class="nx">Component</span> <span class="o">|</span> <span class="k">void</span><span class="p">;</span> <span class="c1">// rendered in this component&#39;s scope
</span><span class="c1"></span>  <span class="nx">key</span><span class="o">:</span> <span class="nx">string</span> <span class="o">|</span> <span class="nx">number</span> <span class="o">|</span> <span class="k">void</span><span class="p">;</span>
  <span class="nx">componentOptions</span><span class="o">:</span> <span class="nx">VNodeComponentOptions</span> <span class="o">|</span> <span class="k">void</span><span class="p">;</span>
  <span class="nx">componentInstance</span><span class="o">:</span> <span class="nx">Component</span> <span class="o">|</span> <span class="k">void</span><span class="p">;</span> <span class="c1">// component instance
</span><span class="c1"></span>  <span class="nx">parent</span><span class="o">:</span> <span class="nx">VNode</span> <span class="o">|</span> <span class="k">void</span><span class="p">;</span> <span class="c1">// component placeholder node
</span><span class="c1"></span>
  <span class="c1">// strictly internal
</span><span class="c1"></span>  <span class="nx">raw</span><span class="o">:</span> <span class="kr">boolean</span><span class="p">;</span> <span class="c1">// contains raw HTML? (server only)
</span><span class="c1"></span>  <span class="nx">isStatic</span><span class="o">:</span> <span class="kr">boolean</span><span class="p">;</span> <span class="c1">// hoisted static node
</span><span class="c1"></span>  <span class="nx">isRootInsert</span><span class="o">:</span> <span class="kr">boolean</span><span class="p">;</span> <span class="c1">// necessary for enter transition check
</span><span class="c1"></span>  <span class="nx">isComment</span><span class="o">:</span> <span class="kr">boolean</span><span class="p">;</span> <span class="c1">// empty comment placeholder?
</span><span class="c1"></span>  <span class="nx">isCloned</span><span class="o">:</span> <span class="kr">boolean</span><span class="p">;</span> <span class="c1">// is a cloned node?
</span><span class="c1"></span>  <span class="nx">isOnce</span><span class="o">:</span> <span class="kr">boolean</span><span class="p">;</span> <span class="c1">// is a v-once node?
</span><span class="c1"></span>  <span class="nx">asyncFactory</span><span class="o">:</span> <span class="nb">Function</span> <span class="o">|</span> <span class="k">void</span><span class="p">;</span> <span class="c1">// async component factory function
</span><span class="c1"></span>  <span class="nx">asyncMeta</span><span class="o">:</span> <span class="nb">Object</span> <span class="o">|</span> <span class="k">void</span><span class="p">;</span>
  <span class="nx">isAsyncPlaceholder</span><span class="o">:</span> <span class="kr">boolean</span><span class="p">;</span>
  <span class="nx">ssrContext</span><span class="o">:</span> <span class="nb">Object</span> <span class="o">|</span> <span class="k">void</span><span class="p">;</span>
  <span class="nx">fnContext</span><span class="o">:</span> <span class="nx">Component</span> <span class="o">|</span> <span class="k">void</span><span class="p">;</span> <span class="c1">// real context vm for functional nodes
</span><span class="c1"></span>  <span class="nx">fnOptions</span><span class="o">:</span> <span class="o">?</span><span class="nx">ComponentOptions</span><span class="p">;</span> <span class="c1">// for SSR caching
</span><span class="c1"></span>  <span class="nx">devtoolsMeta</span><span class="o">:</span> <span class="o">?</span><span class="nb">Object</span><span class="p">;</span> <span class="c1">// used to store functional render context for devtools
</span><span class="c1"></span>  <span class="nx">fnScopeId</span><span class="o">:</span> <span class="o">?</span><span class="nx">string</span><span class="p">;</span> <span class="c1">// functional scope id support
</span><span class="c1"></span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="diff算法">diff算法</h3>

<ul>
<li>Vue的virtual dom的算法是基于Snabbdom库。</li>
<li>VNode只会同层级比较，不会跨层级比较，因此复杂度为O(n)。</li>
<li>重点是<code>patch</code>方法。</li>
</ul>

<h3 id="patch方法">patch方法</h3>

<p>注释：vnode：新的虚拟节点 oldVnode：旧的虚拟节点</p>

<ol>
<li>vnode不存在但是oldVnode存在，需要销毁oldVnode</li>
<li>oldVnode不存在但是vnode存在，创建新节点</li>
<li>oldVnode和vnode都存在
3.1 oldVnode和vnode是同一个节点 执行<code>patchVnode</code>方法
3.2 vnode创建真实dom并替换oldVnode.elm</li>
</ol>

<h3 id="patchvnode方法">patchVnode方法</h3>

<ol>
<li>oldVnode和vnode完全一致，则不需要做任何事情</li>
<li>vnode是文本节点或注释节点，但是vnode.text != oldVnode.text时，只需要更新vnode.elm的文本内容就可以</li>
<li>oldVnode和vnode都是静态节点，且具有相同的key，当vnode是克隆节点或是v-once指令控制的节点时，只需要把oldVnode.elm和oldVnode.child都复制到vnode上即可</li>
<li>vnode不是文本节点或注释节点
<br>4.1 如果oldVnode和vnode都有子节点，且2方的子节点不完全一致，就执行<code>updateChildren</code>方法
<br>4.2 只有oldVnode有子节点，那就把这些节点都删除
<br>4.3 如果只有vnode有子节点，那就创建这些子节点
<br>4.4 如果oldVnode和vnode都没有子节点，但是oldVnode是文本节点或注释节点，就把vnode.elm的文本设置为空字符串</li>
</ol>

<h3 id="updatechildren方法">updateChildren方法</h3>

<ol>
<li>oldStartIdx&gt;oldEndIdx
<br>oldCh已经遍历完了，但是newCh还没有，把newStartIdx-newEndIdx之间的vnode都是新增的，把这些vnode添加到oldCh末尾</li>
<li>newStartIdx&gt;newEndIdx
<br>newCh已经遍历完了，但是oldCh还没有，把oldCh中oldStartIdx-oldEndIdx之间的vnode删除</li>
<li>oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx
<br>一直循环判断
<br>3.1 oldVnode第一个child不存在，oldStart索引右移
<br>3.2 oldVnode最后一个child不存在，oldEnd索引左移
<br>3.3 oldStartVnode和newStartVnode是同一个节点，<code>patchVnode</code>两个节点，索引右移
<br>3.4 oldEndVnode和newEndVnode是同一个节点，<code>patchVnode</code>两个节点，索引左移
<br>3.5 oldStartVnode和newEndVnode是同一个节点，移动oldStartVnode到oldEndVnode节点后面
<br>3.6 oldEndVnode和newStartVnode是同一个节点，移动oldEndVnode到oldStartVnode前面
<br>3.7 oldChildren中寻找跟newStartVnode具有相同key的节点，如果找不到相同key的节点，说明newStartVnode是一个新节点，就创建一个，然后把newStartVnode设置为下一个节点
<br>3.8 如果找到了相同key的节点，比较两个节点是否属于同一个节点，如果属于同一节点，就<code>patchVnode</code>，否则新创建节点</li>
</ol>

<h3 id="什么要设置key">什么要设置key</h3>

<p>如果不设置key的话，newCh和oldCh只会头尾两端比较，并且交叉比较。
如果设置key的话，除了上述的比较外，还会从用key生成的对象oldKeyToIdx中查找匹配的节点，所以为节点设置key可以更高效的利用dom。</p>

<h3 id="疑问">疑问</h3>

<p>virtual dom是vue 2.0以后增加的，那么2.0之前vue这一块是怎么处理的呢？</p>

<h3 id="参考链接">参考链接</h3>

<p><a href="https://www.zhihu.com/question/271485214">参考链接-Vue采用虚拟DOM的目的是什么?</a></p>

<p><a href="https://github.com/vuejs/vue/blob/dev/src/core/vdom/patch.js">参考链接-Vue中virtual dom算法源码</a></p>
]]></content>
		</item>
		
		<item>
			<title>Vuex笔记</title>
			<link>https://caychance.github.io/posts/vuex%E7%AC%94%E8%AE%B0/</link>
			<pubDate>Thu, 28 Mar 2019 16:21:30 +0000</pubDate>
			
			<guid>https://caychance.github.io/posts/vuex%E7%AC%94%E8%AE%B0/</guid>
			<description>Vuex概述 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。
简单来说，就是存储页面中的各种数据。
为什么要用Vuex Vuex的使用并不是必要的。
Vue.js中，数据之间都是在组件之间进行传递的，但是当你的应用变的很大或者很复杂的时候，会有两个问题。
1、当组件嵌套很深的时候，数据的传递，修改，其实都不太方便，很容易导致出错。
2、这些状态可能会在任何组件中被修改，不方便统一管理。尤其是多人合作开发的时候。
Vuex也是为了解决这两个问题而生的。
当然，有人可能会想到使用一个全局对象，再去上层封装了一些数据存取的接口来解决。Vuex和单纯的全局对象有以下2点不同：
 Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若store中的状态发生变化，那么相应的组件也会相应地得到高效更新。
 不能直接改变store中的状态。改变store中的状态的唯一途径就是显式地提交(commit)mutation。这样使得我们可以方便地跟踪每一个状态的变化。
  Vuex详细介绍 Vuex中有五个核心的概念：
 State
 用于存储数据
 Getter
 可理解为store的（computed）计算属性
Getter可接受state和getter两个参数。
 Mutation
 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。
mutation 都是同步事务
 Action
 Action类似mutation。
区别有两点：1.Action可以包含异步操作；2.Action 提交的是 mutation，而不是直接变更状态。
 Module
 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。Vuex 允许我们将 store 分割成模块（module,每个模块拥有自己的state、mutation、action、getter以及嵌套子模块。
  总结  每一个 Vuex 应用的核心就是store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态(state)。 想修改state只能提交（commit）mutation。 mutation中只能进行同步操作。 异步操作可以分发（dispatch）action，当然，action的实质还是提交（commit）mutation。  一句话总结 Vuex的数据流向： State 渲染到Vue Components,分发(Dispatch) Actions,提交(Commit) Mutations，修改(Mutate) State。</description>
			<content type="html"><![CDATA[

<hr />

<h3 id="vuex概述">Vuex概述</h3>

<p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理</strong>模式。</p>

<p>简单来说，就是存储页面中的各种数据。</p>

<h3 id="为什么要用vuex">为什么要用Vuex</h3>

<p>Vuex的使用并不是必要的。</p>

<p>Vue.js中，数据之间都是在组件之间进行传递的，但是当你的应用变的很大或者很复杂的时候，会有两个问题。</p>

<p>1、当组件嵌套很深的时候，数据的传递，修改，其实都不太方便，很容易导致出错。</p>

<p>2、这些状态可能会在任何组件中被修改，不方便统一管理。尤其是多人合作开发的时候。</p>

<p>Vuex也是为了解决这两个问题而生的。</p>

<p>当然，有人可能会想到使用一个全局对象，再去上层封装了一些数据存取的接口来解决。Vuex和单纯的全局对象有以下2点不同：</p>

<ul>
<li><p>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若store中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p></li>

<li><p>不能直接改变store中的状态。改变store中的状态的唯一途径就是显式地提交(commit)mutation。这样使得我们可以方便地跟踪每一个状态的变化。</p></li>
</ul>

<h3 id="vuex详细介绍">Vuex详细介绍</h3>

<p>Vuex中有五个核心的概念：</p>

<ul>
<li><p>State</p>

<blockquote>
<p>用于存储数据</p>
</blockquote></li>

<li><p>Getter</p>

<blockquote>
<p>可理解为store的（computed）计算属性</p>

<p>Getter可接受state和getter两个参数。</p>
</blockquote></li>

<li><p>Mutation</p>

<blockquote>
<p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。</p>

<p>mutation 都是同步事务</p>
</blockquote></li>

<li><p>Action</p>

<blockquote>
<p>Action类似mutation。</p>

<p>区别有两点：1.Action可以包含异步操作；2.Action 提交的是 mutation，而不是直接变更状态。</p>
</blockquote></li>

<li><p>Module</p>

<blockquote>
<p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。Vuex 允许我们将 store 分割成模块（module,每个模块拥有自己的state、mutation、action、getter以及嵌套子模块。</p>
</blockquote></li>
</ul>

<h3 id="总结">总结</h3>

<ul>
<li>每一个 Vuex 应用的核心就是store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态(state)。</li>
<li>想修改state只能提交（commit）mutation。</li>
<li>mutation中只能进行同步操作。</li>
<li>异步操作可以分发（dispatch）action，当然，action的实质还是提交（commit）mutation。</li>
</ul>

<p><img src="https://blog-pics.pek3b.qingstor.com/006tKfTcly1g1io1c6idkj30jh0fbwef.jpg" alt="" /></p>

<h3 id="一句话总结">一句话总结</h3>

<p>Vuex的数据流向：
State 渲染到Vue Components,分发(Dispatch) Actions,提交(Commit) Mutations，修改(Mutate) State。</p>
]]></content>
		</item>
		
		<item>
			<title>Vue原理解析笔记</title>
			<link>https://caychance.github.io/posts/vue%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0/</link>
			<pubDate>Wed, 27 Mar 2019 19:09:06 +0000</pubDate>
			
			<guid>https://caychance.github.io/posts/vue%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0/</guid>
			<description>把数据渲染到页面发生了什么？
new Vue() init初始化 作用： 合并配置、初始化生命周期、初始化事件中心、初始化渲染、data、 props、 methods、 computed 与 watcher 等
 通过 Object.defineProperty 设置 setter 与 getter 函数，用来实现「响应式」以及「依赖收集」 如果有el属性，就调用vm.$mount方法挂载vm。(PS:vm就是Vue的实例)  响应式，依赖收集，派发更新  响应式对象，核心就是利用 Object.defineProperty 给数据添加了 getter 和 setter，目的就是为了在我们访问数据以及写数据的时候能自动执行一些逻辑：getter 做的事情是依赖收集，setter 做的事情是派发更新
 收集依赖的目的是为了当这些响应式数据发生变化，触发它们的 setter 的时候，能知道应该通知哪些订阅者去做相应的逻辑处理
 当数据发生变化的时候，触发 setter 逻辑，把在依赖过程中订阅的的所有观察者，也就是 watcher，都触发它们的 update 过程
 当 render function 被渲染的时候，因为会读取所需对象的值，所以会触发 getter 函数进行「依赖收集」，「依赖收集」的目的是将观察者 Watcher 对象存放到当前闭包中的订阅者 Dep 的 subs 中。形成如下所示的这样一个关系。
 在修改对象的值的时候，会触发对应的 setter， setter 通知之前「依赖收集」得到的 Dep 中的每一个 Watcher，告诉它们自己的值改变了，需要重新渲染视图。这时候这些 Watcher 就会开始调用 update 来更新视图。
  //响应式 function defineReactive (obj,key,val) { let dep = new Dep(); Object.</description>
			<content type="html"><![CDATA[

<hr />

<p>把数据渲染到页面发生了什么？</p>

<h3 id="new-vue">new Vue()</h3>

<h3 id="init初始化">init初始化</h3>

<p><strong>作用：</strong> 合并配置、初始化生命周期、初始化事件中心、初始化渲染、data、 props、 methods、 computed 与 watcher 等</p>

<ul>
<li>通过 Object.defineProperty 设置 setter 与 getter 函数，用来实现「响应式」以及「依赖收集」</li>
<li>如果有el属性，就调用vm.$mount方法挂载vm。(PS:vm就是Vue的实例)</li>
</ul>

<h3 id="响应式-依赖收集-派发更新">响应式，依赖收集，派发更新</h3>

<ul>
<li><p>响应式对象，核心就是利用 Object.defineProperty 给数据添加了 getter 和 setter，目的就是为了在我们访问数据以及写数据的时候能自动执行一些逻辑：getter 做的事情是依赖收集，setter 做的事情是派发更新</p></li>

<li><p>收集依赖的目的是为了当这些响应式数据发生变化，触发它们的 setter 的时候，能知道应该通知哪些订阅者去做相应的逻辑处理</p></li>

<li><p>当数据发生变化的时候，触发 setter 逻辑，把在依赖过程中订阅的的所有观察者，也就是 watcher，都触发它们的 update 过程</p></li>

<li><p>当 render function 被渲染的时候，因为会读取所需对象的值，所以会触发 getter 函数进行「依赖收集」，「依赖收集」的目的是将观察者 Watcher 对象存放到当前闭包中的订阅者 Dep 的 subs 中。形成如下所示的这样一个关系。</p></li>

<li><p>在修改对象的值的时候，会触发对应的 setter， setter 通知之前「依赖收集」得到的 Dep 中的每一个 Watcher，告诉它们自己的值改变了，需要重新渲染视图。这时候这些 Watcher 就会开始调用 update 来更新视图。</p></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">//响应式
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">defineReactive</span> <span class="p">(</span><span class="nx">obj</span><span class="p">,</span><span class="nx">key</span><span class="p">,</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">dep</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Dep</span><span class="p">();</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">get</span><span class="p">(){</span>
      <span class="c1">// 依赖收集
</span><span class="c1"></span>      <span class="nx">dep</span><span class="p">.</span><span class="nx">depend</span><span class="p">();</span>
      <span class="k">return</span> <span class="nx">val</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="nx">set</span><span class="p">(</span><span class="nx">newVal</span><span class="p">){</span>
      <span class="nx">val</span> <span class="o">=</span> <span class="nx">newVal</span><span class="p">;</span>
      <span class="c1">// 派发更新；数据变化通知所有订阅者
</span><span class="c1"></span>      <span class="nx">dep</span><span class="p">.</span><span class="nx">notify</span><span class="p">()</span>
    <span class="p">}</span>
  <span class="p">})</span>
<span class="p">}</span>
<span class="c1">// Dep是整个getter依赖收集的核心
</span><span class="c1"></span><span class="k">class</span> <span class="nx">Dep</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">(){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">subs</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="p">},</span>
  <span class="c1">//增加订阅者
</span><span class="c1"></span>  <span class="nx">addSub</span><span class="p">(</span><span class="nx">sub</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">subs</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">sub</span><span class="p">);</span>
  <span class="p">},</span>
  <span class="c1">//判断是否增加订阅者
</span><span class="c1"></span>  <span class="nx">depend</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">Dep</span><span class="p">.</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">addSub</span><span class="p">(</span><span class="nx">Dep</span><span class="p">.</span><span class="nx">target</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">},</span>

  <span class="c1">//通知订阅者更新
</span><span class="c1"></span>  <span class="nx">notify</span><span class="p">(){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">subs</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">sub</span><span class="p">)</span> <span class="p">=&gt;{</span>
      <span class="nx">sub</span><span class="p">.</span><span class="nx">update</span><span class="p">()</span>
    <span class="p">})</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="nx">Dep</span><span class="p">.</span><span class="nx">target</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</code></pre></div>
<h3 id="mount挂载组件">$mount挂载组件</h3>

<p><strong>作用：</strong> 挂载的目标就是把模板渲染成最终的 DOM</p>

<ul>
<li>限制el，Vue不能挂载在body或者html这样的根节点上。</li>
<li>如果<strong>没有render方法，会把el或template字符串转换成render方法</strong>。(PS:把模板template/el编译生成render,详见compile步骤)</li>
<li>$mount 方法实际上会去调用 mountComponent</li>
<li>mountComponent 核心就是先实例化一个渲染Watcher</li>
<li>mountComponent 的回调函数中会调用 updateComponent 方法</li>
<li>updateComponent 方法中调用 vm._render 方法先生成虚拟 Node，最终调用 vm._update 更新 DOM。</li>
<li>核心方法 <strong>vm._render</strong>和<strong>vm._update</strong></li>
<li>Watcher 在这里起到两个作用，一个是初始化的时候会执行回调函数，另一个是当 vm 实例中的监测的数据发生变化的时候执行回调函数。</li>
</ul>

<h3 id="compile编译">compile编译</h3>

<p>(PS:compile编译步骤不一定是必有的。如果没有使用template，统一都用的render，那么就会跳过此步骤。)
<strong>作用：</strong> 把模板template解析为AST，优化AST，把优化后的AST转换成可执行的代码。(PS:抽象语法树)</p>

<ul>
<li>parse
<strong>作用：</strong> 把 template 模板字符串转换成 AST 树</li>
<li>optimize
<strong>作用：</strong> 优化语法树
1.把一些 AST 节点优化成静态节点(1.标记静态节点;2.标记静态根)
2.目的：如果是静态节点则它们生成 DOM 永远不需要改变，这对运行时对模板的更新起到极大的优化作用。</li>
<li>generate
<strong>作用：</strong> 把优化后的 AST 树转换成可执行的代码，即生成render function。
<br /></li>
</ul>

<h3 id="render渲染函数">render渲染函数</h3>

<p><strong>作用：</strong> 把实例渲染成一个虚拟DOM。(VNode)</p>

<ul>
<li>vm._render 最终是通过执行 createElement 方法并返回的是 vnode</li>
<li>vm.$createElement 方法定义是在执行 initRender 方法的时候</li>
<li>除了 vm.$createElement 方法，还有一个 vm._c 方法</li>
<li>vm._c 被模板编译成的 render 函数使用</li>
<li>vm.$createElement 是用户手写 render 方法使用的</li>
<li>利用 createElement 方法创建 VNode
&gt; createElement 创建 VNode 的过程，每个 VNode 有 children，children 每个元素也是一个 VNode，这样就形成了一个 VNode Tree，它很好的描述了我们的 DOM Tree。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="k">export</span> <span class="kd">function</span> <span class="nx">initRender</span> <span class="p">(</span><span class="nx">vm</span><span class="o">:</span> <span class="nx">Component</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span>  <span class="c1">// bind the createElement fn to this instance
</span><span class="c1"></span>  <span class="c1">// so that we get proper render context inside it.
</span><span class="c1"></span>  <span class="c1">// args order: tag, data, children, normalizationType, alwaysNormalize
</span><span class="c1"></span>  <span class="c1">// internal version is used by render functions compiled from templates
</span><span class="c1"></span>  <span class="nx">vm</span><span class="p">.</span><span class="nx">_c</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">createElement</span><span class="p">(</span><span class="nx">vm</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">d</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
  <span class="c1">// normalization is always applied for the public version, used in
</span><span class="c1"></span>  <span class="c1">// user-written render functions.
</span><span class="c1"></span>  <span class="nx">vm</span><span class="p">.</span><span class="nx">$createElement</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">createElement</span><span class="p">(</span><span class="nx">vm</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">d</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="update方法">update方法</h3>

<p><strong>作用：</strong> 把VNode渲染成真实的DOM</p>

<ul>
<li>Virtual DOM映射到真实的dom，需要经历VNode的create,diff,patch等过程。</li>
<li>被调用的时机有两个。1首次渲染；2数据更新的时候</li>
<li>_update 的核心就是调用 <code>vm.__patch__</code> 方法，这个方法实际上在不同的平台上的定义是不一样的。</li>
<li>在浏览器端渲染中，指向patch方法；在服务端渲染中，没有真实的浏览器DOM环境，所以不需要把VNode转成DOM，因此是一个空函数。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// install platform patch function
</span><span class="c1"></span><span class="nx">Vue</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">__patch__</span> <span class="o">=</span> <span class="nx">inBrowser</span> <span class="o">?</span> <span class="nx">patch</span> <span class="o">:</span> <span class="nx">noop</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">Vue</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">_update</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">vnode</span><span class="o">:</span> <span class="nx">VNode</span><span class="p">,</span> <span class="nx">hydrating</span><span class="o">?:</span> <span class="kr">boolean</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span>  <span class="c1">// Vue.prototype.__patch__ is injected in entry points
</span><span class="c1"></span>  <span class="c1">// based on the rendering backend used.
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">prevVnode</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// initial render
</span><span class="c1"></span>    <span class="nx">vm</span><span class="p">.</span><span class="nx">$el</span> <span class="o">=</span> <span class="nx">vm</span><span class="p">.</span><span class="nx">__patch__</span><span class="p">(</span><span class="nx">vm</span><span class="p">.</span><span class="nx">$el</span><span class="p">,</span> <span class="nx">vnode</span><span class="p">,</span> <span class="nx">hydrating</span><span class="p">,</span> <span class="kc">false</span> <span class="cm">/* removeOnly */</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// updates
</span><span class="c1"></span>    <span class="nx">vm</span><span class="p">.</span><span class="nx">$el</span> <span class="o">=</span> <span class="nx">vm</span><span class="p">.</span><span class="nx">__patch__</span><span class="p">(</span><span class="nx">prevVnode</span><span class="p">,</span> <span class="nx">vnode</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="patch方法">patch方法</h3>

<ul>
<li>patch</li>
<li>patchVnode</li>
<li>updateChildren
<a href="https://caychance.github.io/2019/04/03/diff%E7%AE%97%E6%B3%95/#patch%E6%96%B9%E6%B3%95">参考diff算法</a></li>
</ul>

<h3 id="小结">小结</h3>

<ol>
<li>new Vue()</li>
<li>init初始化 （合并配置，初始化生命周期，事件中心，渲染，data、 props、 methods、 computed 与 watcher等）

<ul>
<li>通过 Object.defineProperty 设置 setter 与 getter 函数</li>
<li>如果有el属性，就调用vm.$mount方法挂载vue实例。</li>
</ul></li>
<li>响应式，依赖收集，派发更新

<ul>
<li>响应式对象，核心就是利用 Object.defineProperty 给数据添加了 getter 和 setter，目的就是为了在我们访问数据以及写数据的时候能自动执行一些逻辑：getter 做的事情是依赖收集，setter 做的事情是派发更新</li>
<li>收集依赖的目的是为了当这些响应式数据发生变化，触发它们的 setter 的时候，能知道应该通知哪些订阅者去做相应的逻辑处理</li>
<li>当数据发生变化的时候，触发 setter 逻辑，把在依赖过程中订阅的的所有观察者，也就是 watcher，都触发它们的 update 过程</li>
</ul></li>
<li>mount挂载组件 （挂载的目标就是把模板渲染成最终的 DOM）</li>
<li>compile编译 （compile编译步骤不一定是必有的。如果没有使用template，统一都用的render，会跳过此步骤。)

<ul>
<li>parse 把模板template解析为AST</li>
<li>optimize 优化AST，标记静态根，静态节点</li>
<li>genarate 把优化后的AST转换成可执行的代码，生成render function</li>
</ul></li>
<li>render渲染函数 （把实例渲染成一个虚拟DOM）</li>
<li>update方法 （把虚拟DOM渲染成真实的DOM）</li>
<li>patch方法

<ul>
<li>patch</li>
<li>patchVnode</li>
<li>updateChildren</li>
</ul></li>
</ol>

<p>new Vue() =&gt; init =&gt; mount =&gt; compile =&gt; render =&gt; VNode =&gt; update =&gt; patch =&gt; dom</p>

<p><img src="https://blog-pics.pek3b.qingstor.com/006tNc79ly1g2v2c39ruvj311e0rudpq.jpg" alt="" /></p>

<!-- ## 响应式原理
Vue.js 是采用 Object.defineProperty 的 getter 和 setter，并结合观察者模式来实现数据绑定的。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。getter 做的事情是依赖收集，setter 做的事情是派发更新 -->

<h3 id="参考">参考</h3>

<p><a href="https://ustbhuangyi.github.io/vue-analysis/">参考链接-Vue.js 技术揭秘</a></p>

<p><a href="https://juejin.im/book/5a36661851882538e2259c0f/section/5a37bbb35188257d167a4d64">参考链接-剖析 Vue.js 内部运行机制</a></p>
]]></content>
		</item>
		
		<item>
			<title>为什么要用框架</title>
			<link>https://caychance.github.io/posts/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E6%A1%86%E6%9E%B6/</link>
			<pubDate>Fri, 22 Mar 2019 23:14:00 +0000</pubDate>
			
			<guid>https://caychance.github.io/posts/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E6%A1%86%E6%9E%B6/</guid>
			<description>一直在用Vue，但是也没有想过框架的出现是为了解决什么痛点？
实现一个点赞功能 首先，实现一个简单的点赞功能，不考虑使用任何框架。
&amp;lt;body&amp;gt; &amp;lt;div class=&amp;#39;wrapper&amp;#39;&amp;gt; &amp;lt;button class=&amp;#39;like-btn&amp;#39;&amp;gt; &amp;lt;span class=&amp;#39;like-text&amp;#39;&amp;gt;点赞&amp;lt;/span&amp;gt; &amp;lt;span&amp;gt;👍&amp;lt;/span&amp;gt; &amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; // 实现一个简单的点赞按钮，点击按钮的同时按钮的文字会变换。demo1难以复用  const button = document.querySelector(&amp;#39;.like-btn&amp;#39;) const buttonText = button.querySelector(&amp;#39;.like-text&amp;#39;) let isLiked = false button.addEventListener(&amp;#39;click&amp;#39;, () =&amp;gt; { isLiked = !isLiked if (isLiked) { buttonText.innerHTML = &amp;#39;取消&amp;#39; } else { buttonText.innerHTML = &amp;#39;点赞&amp;#39; } }, false) &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; 以上代码实现了点赞的功能，但是有一个问题——难以复用。
结构复用 经过改造，我们也仅仅只能复用html部分，并且没有添加事件
&amp;lt;body&amp;gt; &amp;lt;div class=&amp;#39;wrapper&amp;#39;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; // 仅仅可以复用html部分，没有添加事件  class LikeButton { render(){ return ` &amp;lt;button id=&amp;#39;like-btn&amp;#39;&amp;gt; &amp;lt;span class=&amp;#39;like-text&amp;#39;&amp;gt;赞&amp;lt;/span&amp;gt; &amp;lt;span&amp;gt;👍&amp;lt;/span&amp;gt; &amp;lt;/button&amp;gt; ` } } const wrapper = document.</description>
			<content type="html"><![CDATA[

<hr />

<p>一直在用Vue，但是也没有想过框架的出现是为了解决什么痛点？</p>

<h3 id="实现一个点赞功能">实现一个点赞功能</h3>

<p>首先，实现一个简单的点赞功能，不考虑使用任何框架。</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#39;wrapper&#39;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">button</span> <span class="na">class</span><span class="o">=</span><span class="s">&#39;like-btn&#39;</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">span</span> <span class="na">class</span><span class="o">=</span><span class="s">&#39;like-text&#39;</span><span class="p">&gt;</span>点赞<span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span>👍<span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
    <span class="c1">// 实现一个简单的点赞按钮，点击按钮的同时按钮的文字会变换。demo1难以复用
</span><span class="c1"></span>    <span class="k">const</span> <span class="nx">button</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;.like-btn&#39;</span><span class="p">)</span>
    <span class="k">const</span> <span class="nx">buttonText</span> <span class="o">=</span> <span class="nx">button</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;.like-text&#39;</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nx">isLiked</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="nx">button</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">,</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="nx">isLiked</span> <span class="o">=</span> <span class="o">!</span><span class="nx">isLiked</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">isLiked</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">buttonText</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="s1">&#39;取消&#39;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">buttonText</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="s1">&#39;点赞&#39;</span>
      <span class="p">}</span>
    <span class="p">},</span> <span class="kc">false</span><span class="p">)</span>
  <span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span></code></pre></div>
<p>以上代码实现了点赞的功能，但是有一个问题——难以复用。</p>

<h3 id="结构复用">结构复用</h3>

<p>经过改造，我们也仅仅只能复用html部分，并且没有添加事件</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#39;wrapper&#39;</span><span class="p">&gt;&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
    <span class="c1">// 仅仅可以复用html部分，没有添加事件
</span><span class="c1"></span>    <span class="k">class</span> <span class="nx">LikeButton</span> <span class="p">{</span>
      <span class="nx">render</span><span class="p">(){</span>
        <span class="k">return</span> <span class="sb">`
</span><span class="sb">          &lt;button id=&#39;like-btn&#39;&gt;
</span><span class="sb">            &lt;span class=&#39;like-text&#39;&gt;赞&lt;/span&gt;
</span><span class="sb">            &lt;span&gt;👍&lt;/span&gt;
</span><span class="sb">          &lt;/button&gt;
</span><span class="sb">        `</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="nx">wrapper</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;.wrapper&#39;</span><span class="p">)</span>
    <span class="k">const</span> <span class="nx">likeButton1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">LikeButton</span><span class="p">()</span>
    <span class="nx">wrapper</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">likeButton1</span><span class="p">.</span><span class="nx">render</span><span class="p">()</span>

    <span class="k">const</span> <span class="nx">likeButton2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">LikeButton</span><span class="p">()</span>
    <span class="nx">wrapper</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">+=</span> <span class="nx">likeButton2</span><span class="p">.</span><span class="nx">render</span><span class="p">()</span>
  <span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span></code></pre></div>
<h3 id="添加事件">添加事件</h3>

<p>虽然添加了click事件，但是只能输出固定的click。我们需要点击按钮，改变文字</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#39;wrapper&#39;</span><span class="p">&gt;&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
    <span class="c1">// 添加了click事件，但是只能打印固定的click
</span><span class="c1"></span>    <span class="c1">// ::String =&gt; ::Document
</span><span class="c1"></span>    <span class="k">const</span> <span class="nx">createDOMFromString</span> <span class="o">=</span> <span class="p">(</span><span class="nx">domString</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="k">const</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">)</span>
      <span class="nx">div</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">domString</span>
      <span class="k">return</span> <span class="nx">div</span>
    <span class="p">}</span>

    <span class="k">class</span> <span class="nx">LikeButton</span> <span class="p">{</span>
      <span class="nx">render</span><span class="p">(){</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">el</span> <span class="o">=</span> <span class="nx">createDOMFromString</span><span class="p">(</span><span class="sb">`
</span><span class="sb">          &lt;button class=&#39;like-button&#39;&gt;
</span><span class="sb">            &lt;span class=&#39;like-text&#39;&gt;点赞&lt;/span&gt;
</span><span class="sb">            &lt;span&gt;👍&lt;/span&gt;
</span><span class="sb">          &lt;/button&gt;
</span><span class="sb">        `</span><span class="p">)</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">el</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">,</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">),</span> <span class="kc">false</span><span class="p">)</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">el</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="nx">wrapper</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;.wrapper&#39;</span><span class="p">)</span>

    <span class="k">const</span> <span class="nx">likeButton1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">LikeButton</span><span class="p">()</span>
    <span class="nx">wrapper</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">likeButton1</span><span class="p">.</span><span class="nx">render</span><span class="p">())</span>

    <span class="k">const</span> <span class="nx">likeButton2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">LikeButton</span><span class="p">()</span>
    <span class="nx">wrapper</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">likeButton2</span><span class="p">.</span><span class="nx">render</span><span class="p">())</span>
  <span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span></code></pre></div>
<h3 id="修改文字">修改文字</h3>

<p>点击按钮，会修改文字，但是changeLikeText方法频繁的操作dom，影响性能</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#39;wrapper&#39;</span><span class="p">&gt;&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
    <span class="c1">// 点击按钮会执行changeLikeText方法，但是changeLikeText方法里面在不停的操作dom，影响性能
</span><span class="c1"></span>    <span class="c1">// ::String =&gt; ::Document
</span><span class="c1"></span>    <span class="k">const</span> <span class="nx">createDOMFromString</span> <span class="o">=</span> <span class="p">(</span><span class="nx">domString</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="k">const</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">)</span>
      <span class="nx">div</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">domString</span>
      <span class="k">return</span> <span class="nx">div</span>
    <span class="p">}</span>

    <span class="k">class</span> <span class="nx">LikeButton</span> <span class="p">{</span>
      <span class="nx">constructor</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">isLiked</span><span class="o">:</span> <span class="kc">false</span> <span class="p">}</span>
      <span class="p">}</span>

      <span class="nx">changeLikeText</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">const</span> <span class="nx">likeText</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">el</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;.like-text&#39;</span><span class="p">)</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">isLiked</span> <span class="o">=</span> <span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">isLiked</span>
        <span class="nx">likeText</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">isLiked</span> <span class="o">?</span> <span class="s1">&#39;取消&#39;</span> <span class="o">:</span> <span class="s1">&#39;点赞&#39;</span>
      <span class="p">}</span>

      <span class="nx">render</span><span class="p">(){</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">el</span> <span class="o">=</span> <span class="nx">createDOMFromString</span><span class="p">(</span><span class="sb">`
</span><span class="sb">          &lt;button class=&#39;like-button&#39;&gt;
</span><span class="sb">            &lt;span class=&#39;like-text&#39;&gt;点赞&lt;/span&gt;
</span><span class="sb">            &lt;span&gt;👍&lt;/span&gt;
</span><span class="sb">          &lt;/button&gt;
</span><span class="sb">        `</span><span class="p">)</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">el</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">changeLikeText</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">),</span> <span class="kc">false</span><span class="p">)</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">el</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="nx">wrapper</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;.wrapper&#39;</span><span class="p">)</span>

    <span class="k">const</span> <span class="nx">likeButton1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">LikeButton</span><span class="p">()</span>
    <span class="nx">wrapper</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">likeButton1</span><span class="p">.</span><span class="nx">render</span><span class="p">())</span>

    <span class="k">const</span> <span class="nx">likeButton2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">LikeButton</span><span class="p">()</span>
    <span class="nx">wrapper</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">likeButton2</span><span class="p">.</span><span class="nx">render</span><span class="p">())</span>
  <span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span></code></pre></div>
<h3 id="性能优化">性能优化</h3>

<p>到这一步骤，基本已经大体形成，我们可以做更进一步的优化。</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#39;wrapper&#39;</span><span class="p">&gt;&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
    <span class="c1">// 点击按钮执行changeLikeText方法，该方法值会调用setState方法，setState方法会重新给satate赋值，并且修改虚拟html。最终只会操作一次dom
</span><span class="c1"></span>    <span class="c1">// ::String =&gt; ::Document
</span><span class="c1"></span>    <span class="k">const</span> <span class="nx">createDOMFromString</span> <span class="o">=</span> <span class="p">(</span><span class="nx">domString</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="k">const</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">)</span>
      <span class="nx">div</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">domString</span>
      <span class="k">return</span> <span class="nx">div</span>
    <span class="p">}</span>

    <span class="k">class</span> <span class="nx">LikeButton</span> <span class="p">{</span>
      <span class="nx">constructor</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">isLiked</span><span class="o">:</span> <span class="kc">false</span> <span class="p">}</span>
      <span class="p">}</span>

      <span class="nx">setState</span> <span class="p">(</span><span class="nx">state</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">const</span> <span class="nx">oldEl</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">el</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="nx">state</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">el</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">render</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">onStateChange</span><span class="p">)</span> <span class="k">this</span><span class="p">.</span><span class="nx">onStateChange</span><span class="p">(</span><span class="nx">oldEl</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">el</span><span class="p">)</span>
      <span class="p">}</span>

      <span class="nx">changeLikeText</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span>
          <span class="nx">isLiked</span><span class="o">:</span> <span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">isLiked</span>
        <span class="p">})</span>
      <span class="p">}</span>

      <span class="nx">render</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">el</span> <span class="o">=</span> <span class="nx">createDOMFromString</span><span class="p">(</span><span class="sb">`
</span><span class="sb">          &lt;button class=&#39;like-btn&#39;&gt;
</span><span class="sb">            &lt;span class=&#39;like-text&#39;&gt;</span><span class="si">${</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">isLiked</span> <span class="o">?</span> <span class="s1">&#39;取消&#39;</span> <span class="o">:</span> <span class="s1">&#39;点赞&#39;</span><span class="si">}</span><span class="sb">&lt;/span&gt;
</span><span class="sb">            &lt;span&gt;👍&lt;/span&gt;
</span><span class="sb">          &lt;/button&gt;
</span><span class="sb">        `</span><span class="p">)</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">el</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">changeLikeText</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">),</span> <span class="kc">false</span><span class="p">)</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">el</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="nx">wrapper</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;.wrapper&#39;</span><span class="p">)</span>

    <span class="k">const</span> <span class="nx">likeButton</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">LikeButton</span><span class="p">()</span>
    <span class="nx">wrapper</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">likeButton</span><span class="p">.</span><span class="nx">render</span><span class="p">())</span> <span class="c1">// 第一次插入 DOM 元素
</span><span class="c1"></span>    <span class="nx">likeButton</span><span class="p">.</span><span class="nx">onStateChange</span> <span class="o">=</span> <span class="p">(</span><span class="nx">oldEl</span><span class="p">,</span> <span class="nx">newEl</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="nx">wrapper</span><span class="p">.</span><span class="nx">insertBefore</span><span class="p">(</span><span class="nx">newEl</span><span class="p">,</span> <span class="nx">oldEl</span><span class="p">)</span> <span class="c1">// 插入新的元素
</span><span class="c1"></span>      <span class="nx">wrapper</span><span class="p">.</span><span class="nx">removeChild</span><span class="p">(</span><span class="nx">oldEl</span><span class="p">)</span> <span class="c1">// 删除旧的元素
</span><span class="c1"></span>    <span class="p">}</span>
  <span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span></code></pre></div>
<h3 id="进一步优化">进一步优化</h3>

<p>setState和_renderDOM封装成Component类，便于其他组件使用</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#39;wrapper&#39;</span><span class="p">&gt;&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
    <span class="c1">// 把setState和_renderDOM方法进行抽离，修改dom的操作封装成方法
</span><span class="c1"></span>    <span class="c1">// ::String =&gt; ::Document
</span><span class="c1"></span>    <span class="k">const</span> <span class="nx">createDOMFromString</span> <span class="o">=</span> <span class="p">(</span><span class="nx">domString</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="k">const</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">)</span>
      <span class="nx">div</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">domString</span>
      <span class="k">return</span> <span class="nx">div</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="nx">mount</span> <span class="o">=</span> <span class="p">(</span><span class="nx">component</span><span class="p">,</span> <span class="nx">wrapper</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="nx">wrapper</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">component</span><span class="p">.</span><span class="nx">_renderDOM</span><span class="p">())</span>
      <span class="nx">component</span><span class="p">.</span><span class="nx">onStateChange</span> <span class="o">=</span> <span class="p">(</span><span class="nx">oldEl</span><span class="p">,</span> <span class="nx">newEl</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">wrapper</span><span class="p">.</span><span class="nx">insertBefore</span><span class="p">(</span><span class="nx">newEl</span><span class="p">,</span> <span class="nx">oldEl</span><span class="p">)</span>
        <span class="nx">wrapper</span><span class="p">.</span><span class="nx">removeChild</span><span class="p">(</span><span class="nx">oldEl</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">class</span> <span class="nx">Component</span> <span class="p">{</span>
      <span class="nx">setState</span> <span class="p">(</span><span class="nx">state</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">const</span> <span class="nx">oldEl</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">el</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="nx">state</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">_renderDOM</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">onStateChange</span><span class="p">)</span> <span class="k">this</span><span class="p">.</span><span class="nx">onStateChange</span><span class="p">(</span><span class="nx">oldEl</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">el</span><span class="p">)</span>
      <span class="p">}</span>

      <span class="nx">_renderDOM</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">el</span> <span class="o">=</span> <span class="nx">createDOMFromString</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">render</span><span class="p">())</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">onClick</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">el</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">onClick</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">),</span> <span class="kc">false</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">el</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">class</span> <span class="nx">LikeButton</span> <span class="k">extends</span> <span class="nx">Component</span> <span class="p">{</span>
      <span class="nx">constructor</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="p">()</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">isLiked</span><span class="o">:</span> <span class="kc">false</span> <span class="p">}</span>
      <span class="p">}</span>

      <span class="nx">onClick</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span>
          <span class="nx">isLiked</span><span class="o">:</span> <span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">isLiked</span>
        <span class="p">})</span>
      <span class="p">}</span>

      <span class="nx">render</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="sb">`
</span><span class="sb">          &lt;button class=&#39;like-btn&#39;&gt;
</span><span class="sb">            &lt;span class=&#39;like-text&#39;&gt;</span><span class="si">${</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">isLiked</span> <span class="o">?</span> <span class="s1">&#39;取消&#39;</span> <span class="o">:</span> <span class="s1">&#39;点赞&#39;</span><span class="si">}</span><span class="sb">&lt;/span&gt;
</span><span class="sb">            &lt;span&gt;👍&lt;/span&gt;
</span><span class="sb">          &lt;/button&gt;
</span><span class="sb">        `</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="nx">wrapper</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;.wrapper&#39;</span><span class="p">)</span>

    <span class="nx">mount</span><span class="p">(</span><span class="k">new</span> <span class="nx">LikeButton</span><span class="p">(),</span> <span class="nx">wrapper</span><span class="p">)</span>
  <span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span></code></pre></div>
<h3 id="自定义配置">自定义配置</h3>

<p>组件可通过props传参来自定义配置</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#39;wrapper&#39;</span><span class="p">&gt;&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
    <span class="c1">// 组件可以自定义配置 通过props
</span><span class="c1"></span>    <span class="c1">// ::String =&gt; ::Document
</span><span class="c1"></span>    <span class="k">const</span> <span class="nx">createDOMFromString</span> <span class="o">=</span> <span class="p">(</span><span class="nx">domString</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="k">const</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">)</span>
      <span class="nx">div</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">domString</span>
      <span class="k">return</span> <span class="nx">div</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="nx">mount</span> <span class="o">=</span> <span class="p">(</span><span class="nx">component</span><span class="p">,</span> <span class="nx">wrapper</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="nx">wrapper</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">component</span><span class="p">.</span><span class="nx">_renderDOM</span><span class="p">())</span>
      <span class="nx">component</span><span class="p">.</span><span class="nx">onStateChange</span> <span class="o">=</span> <span class="p">(</span><span class="nx">oldEl</span><span class="p">,</span> <span class="nx">newEl</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">wrapper</span><span class="p">.</span><span class="nx">insertBefore</span><span class="p">(</span><span class="nx">newEl</span><span class="p">,</span> <span class="nx">oldEl</span><span class="p">)</span>
        <span class="nx">wrapper</span><span class="p">.</span><span class="nx">removeChild</span><span class="p">(</span><span class="nx">oldEl</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">class</span> <span class="nx">Component</span> <span class="p">{</span>
      <span class="nx">constructor</span> <span class="p">(</span><span class="nx">props</span> <span class="o">=</span> <span class="p">{})</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">props</span> <span class="o">=</span> <span class="nx">props</span>
      <span class="p">}</span>

      <span class="nx">setState</span> <span class="p">(</span><span class="nx">state</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">const</span> <span class="nx">oldEl</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">el</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="nx">state</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">_renderDOM</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">onStateChange</span><span class="p">)</span> <span class="k">this</span><span class="p">.</span><span class="nx">onStateChange</span><span class="p">(</span><span class="nx">oldEl</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">el</span><span class="p">)</span>
      <span class="p">}</span>

      <span class="nx">_renderDOM</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">el</span> <span class="o">=</span> <span class="nx">createDOMFromString</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">render</span><span class="p">())</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">onClick</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">el</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">onClick</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">),</span> <span class="kc">false</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">el</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">class</span> <span class="nx">LikeButton</span> <span class="k">extends</span> <span class="nx">Component</span> <span class="p">{</span>
      <span class="nx">constructor</span> <span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">isLiked</span><span class="o">:</span> <span class="kc">false</span> <span class="p">}</span>
      <span class="p">}</span>

      <span class="nx">onClick</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span>
          <span class="nx">isLiked</span><span class="o">:</span> <span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">isLiked</span>
        <span class="p">})</span>
      <span class="p">}</span>

      <span class="nx">render</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="sb">`
</span><span class="sb">          &lt;button class=&#39;like-btn&#39; style=&#34;background-color: </span><span class="si">${</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">bgColor</span><span class="si">}</span><span class="sb">&#34;&gt;
</span><span class="sb">            &lt;span class=&#39;like-text&#39;&gt;
</span><span class="sb">              </span><span class="si">${</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">isLiked</span> <span class="o">?</span> <span class="s1">&#39;取消&#39;</span> <span class="o">:</span> <span class="s1">&#39;点赞&#39;</span><span class="si">}</span><span class="sb">
</span><span class="sb">            &lt;/span&gt;
</span><span class="sb">            &lt;span&gt;👍&lt;/span&gt;
</span><span class="sb">          &lt;/button&gt;
</span><span class="sb">        `</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">class</span> <span class="nx">RedBlueButton</span> <span class="k">extends</span> <span class="nx">Component</span> <span class="p">{</span>
      <span class="nx">constructor</span> <span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
          <span class="nx">color</span><span class="o">:</span> <span class="s1">&#39;red&#39;</span>
        <span class="p">}</span>
      <span class="p">}</span>

      <span class="nx">onClick</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span>
          <span class="nx">color</span><span class="o">:</span> <span class="s1">&#39;blue&#39;</span>
        <span class="p">})</span>
      <span class="p">}</span>

      <span class="nx">render</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="sb">`
</span><span class="sb">          &lt;div style=&#39;color: </span><span class="si">${</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">color</span><span class="si">}</span><span class="sb">;&#39;&gt;</span><span class="si">${</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">color</span><span class="si">}</span><span class="sb">&lt;/div&gt;
</span><span class="sb">        `</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="nx">wrapper</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;.wrapper&#39;</span><span class="p">)</span>

    <span class="nx">mount</span><span class="p">(</span><span class="k">new</span> <span class="nx">LikeButton</span><span class="p">({</span> <span class="nx">bgColor</span><span class="o">:</span> <span class="s1">&#39;red&#39;</span> <span class="p">}),</span> <span class="nx">wrapper</span><span class="p">)</span>
  <span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span></code></pre></div>
<p>这样子循序渐进的看下来，就能体会到一个框架的诞生的个中缘由——并不是平白无故做出来的，而是为了解决一些问题，然后一点一点的优化，最终诞生的。</p>
]]></content>
		</item>
		
		<item>
			<title>JSX in Vue</title>
			<link>https://caychance.github.io/posts/jsx-in-vue/</link>
			<pubDate>Fri, 08 Mar 2019 23:53:26 +0000</pubDate>
			
			<guid>https://caychance.github.io/posts/jsx-in-vue/</guid>
			<description> 使用Vue的template遇到的问题 前几天接了一个需求-APP首页配置化。大体思路就是，后台做一个页面，这个页面上提供了N个模板，然后运营人员可以动态的添加模板，并且给每个模板进行不同的配置。比如，轮播图模板，轮播图模板可以配置一个标题，以及描述，模板可以配置多张图片，图片可以调整顺序，点击图片跳转的链接等。
我们第一期提供了10个模板。
&amp;lt;template&amp;gt; &amp;lt;template v-if=&amp;#34;templateCode===&amp;#39;SCOELL_IMG_01&amp;#39;&amp;#34;&amp;gt; &amp;lt;c-scroll-img&amp;gt;&amp;lt;/c-scroll-img&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;template v-if=&amp;#34;templateCode===&amp;#39;TWO_IMG_01&amp;#39;&amp;#34;&amp;gt; &amp;lt;c-two-img&amp;gt;&amp;lt;/c-two-img&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;template v-if=&amp;#34;templateCode===&amp;#39;TWO_IMG_02&amp;#39;&amp;#34;&amp;gt; &amp;lt;c-two-img&amp;gt;&amp;lt;/c-two-img&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;template v-if=&amp;#34;templateCode===&amp;#39;THREE_IMG_01&amp;#39;&amp;#34;&amp;gt; &amp;lt;c-three-img&amp;gt;&amp;lt;/c-three-img&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;template v-if=&amp;#34;templateCode===&amp;#39;THREE_IMG_02&amp;#39;&amp;#34;&amp;gt; &amp;lt;c-three-img&amp;gt;&amp;lt;/c-three-img&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;/template&amp;gt; 我举例说明，先写5个说明一下问题。有一个比较严重的问题，就是v-if用的太多了。这里面不能嵌入js，如果以后提供20个模板甚至更多呢？template这种方式肯定会写的很痛苦！
可以尝试使用JSX解决 所以，我们可以试试用另一种方式去写组件-JSX，在Vue中使用JSX。JSX是React的核心组成部分。Vue2.0以后才开始支持JSX的。
JSX介绍 JSX其实就是使用JavaScript去表示dom元素结构。
所谓的 JSX 其实就是 JavaScript 对象。
 JSX 是 JavaScript 语言的一种语法扩展，长得像 HTML，但并不是 HTML。 React.js 可以用 JSX 来描述你的组件长什么样的。 JSX 在编译的时候会变成相应的 JavaScript 对象描述。 react-dom 负责把这个用来描述 UI 信息的 JavaScript 对象变成 DOM 元素，并且渲染到页面上。  从 JSX 到页面到底经过了什么样的过程
JSX基本语法 在Vue中使用JSX首先需要保证Vue的版本大于2.0，然后官方的jsx包,这个包支持的是Babel 7+； 如果是Babel 6，则需要安装babel-plugin-transform-vue-jsx包。
然后根据文档安装完以后。
JSX VS Template  JSX其实就是JavaScript对象，Template是Vue组件中render方法的输入。 JSX特别利于理解，相比较Template而言。（虽然写惯了Template，JSX的语法还需要慢慢适应。） Tempplate对初学者比较友好。  </description>
			<content type="html"><![CDATA[

<hr />

<h3 id="使用vue的template遇到的问题">使用Vue的template遇到的问题</h3>

<p>前几天接了一个需求-APP首页配置化。大体思路就是，后台做一个页面，这个页面上提供了N个模板，然后运营人员可以动态的添加模板，并且给每个模板进行不同的配置。比如，轮播图模板，轮播图模板可以配置一个标题，以及描述，模板可以配置多张图片，图片可以调整顺序，点击图片跳转的链接等。</p>

<p>我们第一期提供了10个模板。</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">template</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">template</span> <span class="na">v-if</span><span class="o">=</span><span class="s">&#34;templateCode===&#39;SCOELL_IMG_01&#39;&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">c-scroll-img</span><span class="p">&gt;&lt;/</span><span class="nt">c-scroll-img</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">template</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">template</span> <span class="na">v-if</span><span class="o">=</span><span class="s">&#34;templateCode===&#39;TWO_IMG_01&#39;&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">c-two-img</span><span class="p">&gt;&lt;/</span><span class="nt">c-two-img</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">template</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">template</span> <span class="na">v-if</span><span class="o">=</span><span class="s">&#34;templateCode===&#39;TWO_IMG_02&#39;&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">c-two-img</span><span class="p">&gt;&lt;/</span><span class="nt">c-two-img</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">template</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">template</span> <span class="na">v-if</span><span class="o">=</span><span class="s">&#34;templateCode===&#39;THREE_IMG_01&#39;&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">c-three-img</span><span class="p">&gt;&lt;/</span><span class="nt">c-three-img</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">template</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">template</span> <span class="na">v-if</span><span class="o">=</span><span class="s">&#34;templateCode===&#39;THREE_IMG_02&#39;&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">c-three-img</span><span class="p">&gt;&lt;/</span><span class="nt">c-three-img</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">template</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">template</span><span class="p">&gt;</span></code></pre></div>
<p>我举例说明，先写5个说明一下问题。有一个比较严重的问题，就是<code>v-if</code>用的太多了。这里面不能嵌入js，如果以后提供20个模板甚至更多呢？template这种方式肯定会写的很痛苦！</p>

<h3 id="可以尝试使用jsx解决">可以尝试使用JSX解决</h3>

<p>所以，我们可以试试用另一种方式去写组件-JSX，在Vue中使用JSX。JSX是React的核心组成部分。Vue2.0以后才开始支持JSX的。</p>

<h3 id="jsx介绍">JSX介绍</h3>

<p>JSX其实就是使用JavaScript去表示dom元素结构。</p>

<p><strong>所谓的 JSX 其实就是 JavaScript 对象。</strong></p>

<ol>
<li>JSX 是 JavaScript 语言的一种语法扩展，长得像 HTML，但并不是 HTML。</li>
<li>React.js 可以用 JSX 来描述你的组件长什么样的。</li>
<li>JSX 在编译的时候会变成相应的 JavaScript 对象描述。</li>
<li>react-dom 负责把这个用来描述 UI 信息的 JavaScript 对象变成 DOM 元素，并且渲染到页面上。</li>
</ol>

<p>从 JSX 到页面到底经过了什么样的过程</p>

<p><img src="https://blog-pics.pek3b.qingstor.com/006tKfTcly1g11dfngojkj30hm075aaq.jpg" alt="" /></p>

<h4 id="jsx基本语法">JSX基本语法</h4>

<p>在Vue中使用JSX首先需要保证Vue的版本大于2.0，然后官方的<a href="https://github.com/vuejs/jsx">jsx</a>包,这个包支持的是Babel 7+；
如果是Babel 6，则需要安装<a href="https://github.com/vuejs/babel-plugin-transform-vue-jsx">babel-plugin-transform-vue-jsx</a>包。</p>

<p>然后根据文档安装完以后。</p>

<h3 id="jsx-vs-template">JSX VS Template</h3>

<ol>
<li>JSX其实就是JavaScript对象，Template是Vue组件中render方法的输入。</li>
<li>JSX特别利于理解，相比较Template而言。（虽然写惯了Template，JSX的语法还需要慢慢适应。）</li>
<li>Tempplate对初学者比较友好。</li>
</ol>
]]></content>
		</item>
		
		<item>
			<title>docker学习笔记</title>
			<link>https://caychance.github.io/posts/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
			<pubDate>Wed, 06 Mar 2019 19:26:50 +0000</pubDate>
			
			<guid>https://caychance.github.io/posts/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
			<description>引子-环境配置的难题 软件开发最大的麻烦事之一就是环境配置。解决的思路就是软件带环境安装，即安装的时候，把原始环境一模一样的复制过来。
初始的尝试解决方案-虚拟机 虚拟机就是带环境安装的一种解决方案。
缺点:
 资源占用多 虚拟机会独占一部分内存和硬盘空间。
 冗余步骤多 虚拟机是完整的操作系统，一些系统级别的操作步骤，无法跳过。
 启动慢 启动虚拟机的时间和启动操作系统的时间一样长。
  另一种解决方案-Linux容器 由于以上缺点，Linux有另一种虚拟化技术:Linux容器。
Linux容器不是模拟一个完整的操作系统，而且对进程进行隔离。
或者说在正常的进程外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的。
由于容器是进程级别的，相比虚拟机有以下优势:
 启动快 启动进程肯定比启动操作系统快太多了。
 资源占用少 容器只占用需要的资源。另外，多个容器可以共享资源。
 体积小 容器只要包含用到的组件即可。
  结论:容器有点类似轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。
噔噔噔～主角登场-Docker是个啥 Docker属于Linux容器的一种封装，提供简单易用的容器使用接口。
Docker将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。(有了 Docker，妈妈再也不用担心环境问题。)
此外，容器还可以进行版本管理、复制、分享、修改，类似代码的管理。
Docker的用途 Docker 的主要用途，目前有三大类。
 提供一次性的环境。 比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。
 提供弹性的云服务。 因为 Docker 容器可以随开随关，很适合动态扩容和缩容。
 组建微服务架构。 通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。
  咦？Docker中的image是个啥 Docker把应用程序及其依赖，打包在image文件里面。
我们通过image文件，可以生成Docker容器。
image文件可以看作是容器的模板。Docker根据image文件生成容器的实例。同一个image文件，可以生成多个同时运行的容器实例。
image是二进制文件。image文件可以继承别的image文件，一般来讲，尽量使用别人制作好的docker，或者基于别人的image文件进行加工。
容器文件又是个啥？ image文件能够生成的容器实例，这个容器实例本身也是一个文件，称为容器文件。
所以说，一旦容器生成，会同时有两个文件:image文件和容器文件。
关闭容器，并不会删除容器文件，只是容器停止运行而已。
我也想做一个Docker容器，肿么办？ step1: 编写Dockerfile 在项目的根目录下，新建一个文本文件.dockerignore和Dockerfile。前者是docker打包要忽略的路径;后者是docker打包的代码
FROMnode:8.4COPY . /appWORKDIR/appRUN npm install --registry=https://registry.</description>
			<content type="html"><![CDATA[

<hr />

<h3 id="引子-环境配置的难题">引子-环境配置的难题</h3>

<p>软件开发最大的麻烦事之一就是环境配置。解决的思路就是软件带环境安装，即安装的时候，把原始环境一模一样的复制过来。</p>

<h3 id="初始的尝试解决方案-虚拟机">初始的尝试解决方案-虚拟机</h3>

<p>虚拟机就是带环境安装的一种解决方案。</p>

<p>缺点:</p>

<ol>
<li><p>资源占用多
虚拟机会独占一部分内存和硬盘空间。</p></li>

<li><p>冗余步骤多
虚拟机是完整的操作系统，一些系统级别的操作步骤，无法跳过。</p></li>

<li><p>启动慢
启动虚拟机的时间和启动操作系统的时间一样长。</p></li>
</ol>

<h3 id="另一种解决方案-linux容器">另一种解决方案-Linux容器</h3>

<p>由于以上缺点，Linux有另一种虚拟化技术:Linux容器。</p>

<p><strong>Linux容器不是模拟一个完整的操作系统，而且对进程进行隔离。</strong></p>

<p>或者说在正常的进程外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的。</p>

<p>由于容器是进程级别的，相比虚拟机有以下优势:</p>

<ol>
<li><p>启动快
<br>启动进程肯定比启动操作系统快太多了。</p></li>

<li><p>资源占用少
<br>容器只占用需要的资源。另外，多个容器可以共享资源。</p></li>

<li><p>体积小
<br>容器只要包含用到的组件即可。</p></li>
</ol>

<p>结论:容器有点类似轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。</p>

<h3 id="噔噔噔-主角登场-docker是个啥">噔噔噔～主角登场-Docker是个啥</h3>

<p><strong>Docker属于Linux容器的一种封装，提供简单易用的容器使用接口。</strong></p>

<p>Docker将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。(有了 Docker，妈妈再也不用担心环境问题。)</p>

<p>此外，容器还可以进行版本管理、复制、分享、修改，类似代码的管理。</p>

<h3 id="docker的用途">Docker的用途</h3>

<p>Docker 的主要用途，目前有三大类。</p>

<ol>
<li><p>提供一次性的环境。
<br>比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p></li>

<li><p>提供弹性的云服务。
<br>因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</p></li>

<li><p>组建微服务架构。
<br>通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p></li>
</ol>

<h3 id="咦-docker中的image是个啥">咦？Docker中的image是个啥</h3>

<p><strong>Docker把应用程序及其依赖，打包在image文件里面。</strong></p>

<p>我们通过image文件，可以生成Docker容器。</p>

<p>image文件可以看作是容器的模板。Docker根据image文件生成容器的实例。同一个image文件，可以生成多个同时运行的容器实例。</p>

<p>image是二进制文件。image文件可以继承别的image文件，一般来讲，尽量使用别人制作好的docker，或者基于别人的image文件进行加工。</p>

<h3 id="容器文件又是个啥">容器文件又是个啥？</h3>

<p>image文件能够生成的容器实例，这个容器实例本身也是一个文件，称为容器文件。</p>

<p>所以说，一旦容器生成，会同时有两个文件:image文件和容器文件。</p>

<p>关闭容器，并不会删除容器文件，只是容器停止运行而已。</p>

<h3 id="我也想做一个docker容器-肿么办">我也想做一个Docker容器，肿么办？</h3>

<p>step1: 编写Dockerfile
在项目的根目录下，新建一个文本文件.dockerignore和Dockerfile。前者是docker打包要忽略的路径;后者是docker打包的代码</p>
<div class="highlight"><pre class="chroma"><code class="language-docker" data-lang="docker"><span class="k">FROM</span><span class="s"> node:8.4</span><span class="err">
</span><span class="err"></span>COPY . /app<span class="err">
</span><span class="err"></span><span class="k">WORKDIR</span><span class="s"> /app</span><span class="err">
</span><span class="err"></span><span class="k">RUN</span> npm install --registry<span class="o">=</span>https://registry.npm.taobao.org<span class="err">
</span><span class="err"></span><span class="k">EXPOSE</span><span class="s"> 3000</span></code></pre></div>
<p>step2: 创建image文件
在dockerfile文件的基础上使用docker image build 命令创建image文件。</p>

<p>step3: 生成容器
docker container run 命令会从image文件生成容器。</p>

<h3 id="docker常用命令">docker常用命令</h3>

<h4 id="版本相关">版本相关</h4>

<pre><code>docker version //docker客户端和服务端的版本号
docker info //docker更加详尽的信息
</code></pre>

<h4 id="image相关">image相关</h4>

<pre><code>docker image ls //列出所有的docker image
docker image rm [imageId] //删除指定image
docker image build -t koa-demo . //创建 image 文件
docker image prune //清除所有image
</code></pre>

<h4 id="运行一个image并启动容器">运行一个image并启动容器</h4>

<pre><code>docker image pull library/hello-world //将image文件从仓库抓取到本地
docker container run hello-world //运行image文件生成容器，每运行一次，就会新建一个容器。
docker container start [containerID] //重复使用容器
docker container kill [containID] //终止指定容器运行  相当于向容器里面的主进程发出 SIGKILL 信号
docker container stop [containID] //终止指定容器运行  相当于向容器里面的主进程发出 SIGTERM 信号
这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。
</code></pre>

<h4 id="container相关">container相关</h4>

<pre><code>docker container ls //列出正在运行的容器
docker container ls -a //列出所有的容器，包括终止运行的容器
docker container kill [containID] //终止指定容器运行
docker container rm [containerID] //删除指定容器文件
docker container prune //清除所有container
docker system prune //清除所有
</code></pre>

<h4 id="发布image">发布image</h4>

<pre><code>docker login //登录
docker image tag [imageName] [username]/[repository]:[tag] // 为本地的 image 标注用户名和版本。docker image tag koa-demos:0.0.1 cc/koa-demos:0.0.1
docker image build -t [username]/[repository]:[tag] . //重新构建image文件
docker image push [username]/[repository]:[tag] //发布image文件
</code></pre>

<p>以上都是简单介绍。</p>

<p><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">参考链接-阮老师的教程</a></p>
]]></content>
		</item>
		
		<item>
			<title>原型与原型链</title>
			<link>https://caychance.github.io/posts/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</link>
			<pubDate>Tue, 26 Feb 2019 17:10:20 +0000</pubDate>
			
			<guid>https://caychance.github.io/posts/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</guid>
			<description>原型  每个函数都有一个特殊的属性叫作原型（prototype） 每个实例对象（object）都有一个私有属性（称之为__proto__）指向它的原型对象（prototype） 该原型对象也有一个自己的原型对象(__proto__) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。  构造函数，原型和实例三者之间的关系
function Father(){}; var f = new Father(); Father.prototype === f.__proto__ //true Father.prototype.constructor === Father //true  原型链  原型链的最顶端是null 所有的原型的_proto_都是Object的原型 所有的构造函数的_proto_都是Function的原型 Function的_proto_和prototype都是Function的原型  Object.prototype.__proto__ //null 1 Function.prototype === Function.__proto__ //true 4 Object.__proto__.__proto__ === Object.prototype //true Function.__proto__.__proto__ === Object.prototype //true function Father(){} Father.__proto__ === Function.prototype //true 3 Father.prototype.__proto__ === Object.prototype //true 2 String.__proto__ === Function.prototype //true 3 String.prototype.__proto__ === Object.prototype //true 2  后记 理解，每个函数（构造函数，或者普通函数）都有一个属性叫做原型（prototype）, 每个实例对象都有一个私有属性（__proto__），每个实例对象之间的__proto__指向就是原型链。</description>
			<content type="html"><![CDATA[

<hr />

<h3 id="原型">原型</h3>

<ul>
<li>每个函数都有一个特殊的属性叫作原型（<code>prototype</code>）</li>
<li>每个实例对象（<code>object</code>）都有一个私有属性（称之为<code>__proto__</code>）指向它的原型对象（<code>prototype</code>）</li>
<li>该原型对象也有一个自己的原型对象(<code>__proto__</code>) ，层层向上直到一个对象的原型对象为 <code>null</code>。根据定义，<code>null</code> 没有原型，并作为这个原型链中的最后一个环节。</li>
</ul>

<p>构造函数，原型和实例三者之间的关系</p>

<p><img src="https://blog-pics.pek3b.qingstor.com/prototypechain.png" alt="" /></p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">Father</span><span class="p">(){};</span>

<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Father</span><span class="p">();</span>
<span class="nx">Father</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">===</span> <span class="nx">f</span><span class="p">.</span><span class="nx">__proto__</span> <span class="c1">//true
</span><span class="c1"></span><span class="nx">Father</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nx">Father</span> <span class="c1">//true
</span></code></pre></div>
<h3 id="原型链">原型链</h3>

<p><img src='https://blog-pics.pek3b.qingstor.com/006tKfTcly1g0l17qcp6vj30zk0pugn7.jpg' style="
    height: 500px;
"/></p>

<ul>
<li>原型链的最顶端是<code>null</code></li>
<li>所有的原型的<code>_proto_</code>都是Object的原型</li>
<li>所有的构造函数的<code>_proto_</code>都是Function的原型</li>
<li>Function的<code>_proto_</code>和<code>prototype</code>都是Function的原型</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">__proto__</span> <span class="c1">//null 1
</span><span class="c1"></span><span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">===</span> <span class="nb">Function</span><span class="p">.</span><span class="nx">__proto__</span> <span class="c1">//true 4
</span><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">//true
</span><span class="c1"></span><span class="nb">Function</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">//true
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">Father</span><span class="p">(){}</span>
<span class="nx">Father</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">//true 3
</span><span class="c1"></span><span class="nx">Father</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">//true 2
</span><span class="c1"></span><span class="nb">String</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">//true 3
</span><span class="c1"></span><span class="nb">String</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span> <span class="c1">//true 2
</span></code></pre></div>
<h3 id="后记">后记</h3>

<p>理解，每个函数（构造函数，或者普通函数）都有一个属性叫做原型（prototype）,
每个实例对象都有一个私有属性（<code>__proto__</code>），每个实例对象之间的<code>__proto__</code>指向就是原型链。</p>

<p>最后贴一张更全的图</p>

<p><img src='https://blog-pics.pek3b.qingstor.com/006tKfTcly1g0l0c6dx6cj30u011c7ci.jpg' style="
    height: 600px;
"/></p>
]]></content>
		</item>
		
		<item>
			<title>MongoDB基础入门</title>
			<link>https://caychance.github.io/posts/mongodb%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</link>
			<pubDate>Fri, 01 Feb 2019 10:23:29 +0000</pubDate>
			
			<guid>https://caychance.github.io/posts/mongodb%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</guid>
			<description>MongoDB基础入门（基础篇） 最新心血来潮，准备在网上学习一下Vue+Node+MongoDB。之前接触过MySQL，但是MongoDB跟MySQL还是有区别的。话不多说：
基本概念    SQL术语/概念 MongoDB术语/概念 解释/说明     database database 数据库   table collection 数据库表/集合   row document 数据记录行/文档   column field 数据字段/域   index index 索引   table joins  表连接,MongoDB不支持   primary key primary key 主键,MongoDB自动将_id字段设置为主键    数据库  一个mongodb中可以建立多个数据库。
 每个数据库里面有多个表（也叫做集合）。
 表里面存储的数据格式就是一个json，这也是区别于SQL的地方。
  下载安装 这一步就省略了，自己Google去吧。我在mac下用的homebrew
连接数据库 在命令行中输入mongo就会连接到数据库
数据库相关 show dbs 查看所有数据库</description>
			<content type="html"><![CDATA[

<hr />

<h2 id="mongodb基础入门-基础篇">MongoDB基础入门（基础篇）</h2>

<p>最新心血来潮，准备在网上学习一下Vue+Node+MongoDB。之前接触过MySQL，但是MongoDB跟MySQL还是有区别的。话不多说：</p>

<h3 id="基本概念">基本概念</h3>

<table>
<thead>
<tr>
<th>SQL术语/概念</th>
<th>MongoDB术语/概念</th>
<th>解释/说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>database</td>
<td>database</td>
<td>数据库</td>
</tr>

<tr>
<td>table</td>
<td>collection</td>
<td>数据库表/集合</td>
</tr>

<tr>
<td>row</td>
<td>document</td>
<td>数据记录行/文档</td>
</tr>

<tr>
<td>column</td>
<td>field</td>
<td>数据字段/域</td>
</tr>

<tr>
<td>index</td>
<td>index</td>
<td>索引</td>
</tr>

<tr>
<td>table joins</td>
<td></td>
<td>表连接,MongoDB不支持</td>
</tr>

<tr>
<td>primary key</td>
<td>primary key</td>
<td>主键,MongoDB自动将_id字段设置为主键</td>
</tr>
</tbody>
</table>

<h3 id="数据库">数据库</h3>

<ol>
<li><p>一个mongodb中可以建立多个数据库。</p></li>

<li><p>每个数据库里面有多个表（也叫做集合）。</p></li>

<li><p>表里面存储的数据格式就是一个json，这也是区别于SQL的地方。</p></li>
</ol>

<h3 id="下载安装">下载安装</h3>

<p>这一步就省略了，自己Google去吧。我在mac下用的homebrew</p>

<h3 id="连接数据库">连接数据库</h3>

<p>在命令行中输入mongo就会连接到数据库</p>

<h3 id="数据库相关">数据库相关</h3>

<p><code>show dbs</code>           查看所有数据库</p>

<p><code>use DATABASE_NAME</code>  创建数据库或者切换到该数据库</p>

<p><code>db.dropDatabase()</code>  删除数据库</p>

<h3 id="集合相关">集合相关</h3>

<p><code>show tables</code>                           查看已有表</p>

<p><code>show collections</code>                      查看已有集合</p>

<p><code>db.createCollection(name, options)</code>    创建集合</p>

<p><code>db.COLLECTION_NAME.drop()</code>             删除集合</p>

<p><strong>PS：show tables 和 show collections 的区别，网上还么有搜到，但是实际操作了一下，发现两者是一样的。</strong></p>

<p>直接在COLLECTION_NAME集合中插入数据的时候，会自动创建COLLECTION_NAME集合
<code>db.COLLECTION_NAME.insert({&quot;name&quot; : &quot;Chance&quot;})</code></p>

<p><strong>情况1：如果没有新建一个数据库的话，会默认在test数据库中新建一个COLLECTION_NAME集合（表）</strong></p>

<p><strong>情况2：在该命令之前新建了一个数据库的话，会在该数据库下新建一个COLLECTION_NAME集合（表）</strong></p>

<h3 id="增删改查">增删改查</h3>

<p>增删改查的操作是基于集合来的，所有统一的格式都是db.COLLECTION_NAME.***</p>

<p>增</p>

<pre><code>db.COLLECTION_NAME.insert(document)
</code></pre>

<pre><code>db.COLLECTION_NAME.save(document) 
</code></pre>

<p>删</p>

<pre><code>db.COLLECTION_NAME.remove(
   &lt;query&gt;,
   {
     justOne: &lt;boolean&gt;,
     writeConcern: &lt;document&gt;
   }
)
</code></pre>

<p>改</p>

<pre><code>db.COLLECTION_NAME.update(
   &lt;query&gt;,
   &lt;update&gt;,
   {
     upsert: &lt;boolean&gt;,
     multi: &lt;boolean&gt;,
     writeConcern: &lt;document&gt;
   }
)
</code></pre>

<pre><code>db.COLLECTION_NAME.save(
   &lt;document&gt;,
   {
     writeConcern: &lt;document&gt;
   }
)
</code></pre>

<p>查</p>

<pre><code>db.COLLECTION_NAME.find(query, projection)
</code></pre>

<h3 id="常用命令">常用命令</h3>

<table>
<thead>
<tr>
<th>命令</th>
<th>解释/说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>show dbs</td>
<td>查看所有数据库</td>
</tr>

<tr>
<td>db</td>
<td>显示当前数据库对象或集合</td>
</tr>

<tr>
<td>use DATABASE_NAME</td>
<td>如果数据库不存在，则创建数据库，否则切换到指定数据库。</td>
</tr>

<tr>
<td>show tables</td>
<td>查看该数据库下的所有表</td>
</tr>

<tr>
<td>show collections</td>
<td>查看该数据库下的所有集合</td>
</tr>

<tr>
<td>db.dropDatabase()</td>
<td>删除数据库</td>
</tr>

<tr>
<td>db.COLLECTION_NAME.insert({&ldquo;name&rdquo;:&ldquo;Chance&rdquo;})</td>
<td>创建集合并向其中插入一些数据</td>
</tr>

<tr>
<td>db.createCollection(name, options)</td>
<td>创建集合</td>
</tr>

<tr>
<td>db.COLLECTION_NAME.drop()</td>
<td>删除当前集合</td>
</tr>

<tr>
<td>db.COLLECTION_NAME.insert(document)</td>
<td>增</td>
</tr>

<tr>
<td>db.COLLECTION_NAME.remove()</td>
<td>删</td>
</tr>

<tr>
<td>db.COLLECTION_NAME.update()</td>
<td>改</td>
</tr>

<tr>
<td>db.COLLECTION_NAME.insert(document)</td>
<td>查</td>
</tr>
</tbody>
</table>

<h3 id="写在最后">写在最后</h3>

<p>正常情况下，node中不会直接使用mongo的语法，会使用mongoose</p>

<p><a href="https://mongoosejs.com/">参考链接-mongoose官网</a></p>

<p><a href="https://www.bilibili.com/video/av41033371">参考链接-mongoose教程</a></p>
]]></content>
		</item>
		
		<item>
			<title>Vue项目的整体认识</title>
			<link>https://caychance.github.io/posts/vue%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%95%B4%E4%BD%93%E8%AE%A4%E8%AF%86/</link>
			<pubDate>Fri, 25 Jan 2019 21:08:20 +0000</pubDate>
			
			<guid>https://caychance.github.io/posts/vue%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%95%B4%E4%BD%93%E8%AE%A4%E8%AF%86/</guid>
			<description>引子 其实从16年11月28日进公司实习至今，已经两年多了。刚去公司的时候，我们当时前端就3个人，那会也是第一次接触Vue的。刚接触的感觉，就是，这玩意，这么神奇。然后平时做需求也是，能把需求做了就行。至今还记得第一次前后端联调，第一次项目上线。
虽然很早就接触了，但是我们项目的很多东西，我都没有认真的静下来去看。导致很多东西都是一知半解的。直到自己有一天幡然醒悟。
我们的项目是我们前端小组长搭建的一个脚手架,包括vue cli+webpack配置+node(express)。使用 node 代替 NGINX 提供请求代理、WebViewJavaScriptbridge 与客户端交互、Vue 全家桶作为开发框架，并且用 express 搭建了 mock 框架。
正题 首先，Vue没有什么神奇的，最后上线的东西就是一个dist文件，里面一个入口文件index.html+一个static文件，static文件里面是打包后的图片，css和js。
以本地开发为例，npm run dev 以后，正常情况下会启动一个本地服务，然后当用户访问localhost:8080/login，本地服务器会返回打包后的index.html文件，index文件里面引入了main.js即js代码的主入口文件。
这部分是Vue项目中的node服务器处理的，这也是node服务器的第一个作用，方便本地调试。服务器会把收到的请求转到index.html。具体可参考作用1。
main.js文件里面其实会实例化一个Vue对象，并挂载在某个dom元素下。实例化的Vue对象里面有Vue Router和Vuex。Vuex按需要来决定要不要引用。Vue Router会在你访问某个路径的时候，比对当前的location.pathname和Vue Router中的某一个path是否可以匹配上，能够匹配上的话，会渲染对应的组件页面。
以上就是对Vue整个项目的一个认识。Vue项目中用到了node，说一下node的作用吧。
作用1 服务器会把收到的请求转到index.html。（PS：test环境和production环境是这样处理的。）
app.use(function (req, res) { res.sendFile(webpackConfig.output.path + &amp;#39;/index.html&amp;#39;, { headers: { &amp;#39;Content-Type&amp;#39;: &amp;#39;text/html; charset=UTF-8&amp;#39; } }); });  其中，dev环境下使用webpack-dev-middleware中间件来做。这么做的其中一个好处是，不在磁盘中存储文件，而是直接生成在内存中。
var devMiddleware = require(&amp;#39;webpack-dev-middleware&amp;#39;)(compiler, { publicPath: webpackConfig.output.publicPath, stats: { colors: true, chunks: false } }) // serve webpack bundle output app.use(devMiddleware)  作用2 使用中间件代理解决跨域问题，我们用了一个proxy-middleware的中间件。</description>
			<content type="html"><![CDATA[

<hr />

<h3 id="引子">引子</h3>

<p>其实从16年11月28日进公司实习至今，已经两年多了。刚去公司的时候，我们当时前端就3个人，那会也是第一次接触Vue的。刚接触的感觉，就是，这玩意，这么神奇。然后平时做需求也是，能把需求做了就行。至今还记得第一次前后端联调，第一次项目上线。</p>

<p>虽然很早就接触了，但是我们项目的很多东西，我都没有认真的静下来去看。导致很多东西都是一知半解的。直到自己有一天幡然醒悟。</p>

<p>我们的项目是我们前端小组长搭建的一个脚手架,包括vue cli+webpack配置+node(express)。使用 node 代替 NGINX 提供请求代理、WebViewJavaScriptbridge 与客户端交互、Vue 全家桶作为开发框架，并且用 express 搭建了 mock 框架。</p>

<h3 id="正题">正题</h3>

<p>首先，Vue没有什么神奇的，最后上线的东西就是一个dist文件，里面一个入口文件index.html+一个static文件，static文件里面是打包后的图片，css和js。</p>

<p><img src="https://blog-pics.pek3b.qingstor.com/006tNc79ly1fzj6d8fhqvj30hk0k40ue.jpg" alt="" /></p>

<p>以本地开发为例，<code>npm run dev</code> 以后，正常情况下会启动一个本地服务，然后当用户访问<code>localhost:8080/login</code>，本地服务器会返回打包后的<code>index.html</code>文件，index文件里面引入了main.js即js代码的主入口文件。</p>

<p>这部分是Vue项目中的node服务器处理的，这也是node服务器的第一个作用，方便本地调试。服务器会把收到的请求转到index.html。具体可参考作用1。</p>

<p>main.js文件里面其实会实例化一个Vue对象，并挂载在某个dom元素下。实例化的Vue对象里面有Vue Router和Vuex。Vuex按需要来决定要不要引用。Vue Router会在你访问某个路径的时候，比对当前的location.pathname和Vue Router中的某一个path是否可以匹配上，能够匹配上的话，会渲染对应的组件页面。</p>

<p>以上就是对Vue整个项目的一个认识。Vue项目中用到了node，说一下node的作用吧。</p>

<h4 id="作用1">作用1</h4>

<p>服务器会把收到的请求转到index.html。（PS：test环境和production环境是这样处理的。）</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">sendFile</span><span class="p">(</span><span class="nx">webpackConfig</span><span class="p">.</span><span class="nx">output</span><span class="p">.</span><span class="nx">path</span> <span class="o">+</span> <span class="s1">&#39;/index.html&#39;</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">headers</span><span class="o">:</span> <span class="p">{</span>
      <span class="s1">&#39;Content-Type&#39;</span><span class="o">:</span> <span class="s1">&#39;text/html; charset=UTF-8&#39;</span>
    <span class="p">}</span>
  <span class="p">});</span>
<span class="p">});</span>
</code></pre></div>
<p>其中，dev环境下使用webpack-dev-middleware中间件来做。这么做的其中一个好处是，不在磁盘中存储文件，而是直接生成在内存中。</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">devMiddleware</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;webpack-dev-middleware&#39;</span><span class="p">)(</span><span class="nx">compiler</span><span class="p">,</span> <span class="p">{</span>
  <span class="nx">publicPath</span><span class="o">:</span> <span class="nx">webpackConfig</span><span class="p">.</span><span class="nx">output</span><span class="p">.</span><span class="nx">publicPath</span><span class="p">,</span>
  <span class="nx">stats</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">colors</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="nx">chunks</span><span class="o">:</span> <span class="kc">false</span>
  <span class="p">}</span>
<span class="p">})</span>

<span class="c1">// serve webpack bundle output
</span><span class="c1"></span><span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">devMiddleware</span><span class="p">)</span>
</code></pre></div>
<h4 id="作用2">作用2</h4>

<p>使用中间件代理解决跨域问题，我们用了一个proxy-middleware的中间件。</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// proxy api requests
</span><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">apiMap</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">key</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">const</span> <span class="nx">api</span> <span class="o">=</span> <span class="nx">apiMap</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
  <span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">api</span><span class="p">.</span><span class="nx">path</span><span class="p">,</span> <span class="nx">proxy</span><span class="p">(</span><span class="nx">api</span><span class="p">.</span><span class="nx">proxy</span><span class="p">));</span>
<span class="p">});</span>
</code></pre></div>
<h4 id="作用3">作用3</h4>

<p>请求一些静态资源，或者本地不经过webpack编译的图片。</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// serve pure static assets
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">staticPath</span> <span class="o">=</span> <span class="nx">path</span><span class="p">.</span><span class="nx">posix</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">dev</span><span class="p">.</span><span class="nx">assetsPublicPath</span><span class="p">,</span> <span class="nx">config</span><span class="p">.</span><span class="nx">dev</span><span class="p">.</span><span class="nx">assetsSubDirectory</span><span class="p">);</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">staticPath</span><span class="p">,</span> <span class="nx">express</span><span class="p">.</span><span class="kr">static</span><span class="p">(</span><span class="nx">path</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">,</span> <span class="s1">&#39;../static&#39;</span><span class="p">)))</span>
</code></pre></div>
<h4 id="作用4">作用4</h4>

<p>本地调试的时候mock数据 else部分</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="k">if</span> <span class="p">(</span><span class="nx">argv</span><span class="p">.</span><span class="nx">proxy</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">apiMap</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">key</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">const</span> <span class="nx">api</span> <span class="o">=</span> <span class="nx">apiMap</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
    <span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">api</span><span class="p">.</span><span class="nx">path</span><span class="p">,</span> <span class="nx">proxy</span><span class="p">(</span><span class="nx">api</span><span class="p">.</span><span class="nx">proxy</span><span class="p">));</span>
  <span class="p">});</span>
<span class="p">}</span>
<span class="c1">// mock api requests
</span><span class="c1"></span><span class="k">else</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">mockDir</span> <span class="o">=</span> <span class="nx">path</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">,</span> <span class="s1">&#39;../mock&#39;</span><span class="p">);</span>
  <span class="p">(</span><span class="kd">function</span> <span class="nx">setMock</span><span class="p">(</span><span class="nx">mockDir</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fs</span><span class="p">.</span><span class="nx">readdirSync</span><span class="p">(</span><span class="nx">mockDir</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">file</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">filePath</span> <span class="o">=</span> <span class="nx">path</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">mockDir</span><span class="p">,</span> <span class="nx">file</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">mock</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">fs</span><span class="p">.</span><span class="nx">statSync</span><span class="p">(</span><span class="nx">filePath</span><span class="p">).</span><span class="nx">isDirectory</span><span class="p">())</span> <span class="p">{</span>
        <span class="nx">setMock</span><span class="p">(</span><span class="nx">filePath</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="sr">/\.js$/</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">file</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">mock</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="nx">filePath</span><span class="p">);</span>
          <span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">mock</span><span class="p">.</span><span class="nx">api</span><span class="p">,</span> <span class="nx">mock</span><span class="p">.</span><span class="nx">response</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">});</span>
  <span class="p">})(</span><span class="nx">mockDir</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="后记">后记</h3>

<p>这些话是说给自己的。</p>

<p>首先鼓励的话，从最开始看到项目那一堆代码时的一脸懵逼，到现在基本都明白了。（不说全部都明白了，但是就算有不知道的，也知道去搜索然后了解对应的部分是做什么的）。当然，这个经历的时间有些长，包括自己学习node，koa+express。这个过程也是很美好的，收获也不少。</p>

<p>然后警钟的话，</p>

<p><strong>爱一行，干一行；干一行，爱一行。</strong>最开始虽然说是为了互联网行业的高薪来的，但是起码当时选的是你感兴趣的前端，（PS：这话说得可能就不对，因为真正的程序员眼里是不分前后端的），所以，爱一行，干一行。</p>

<p><strong>时刻保持着对知识的好奇以及极强的求知欲。</strong> 这句话，自己好好反思。</p>

<p>最后，没有最后。加油！！！</p>
]]></content>
		</item>
		
		<item>
			<title>Vuex存储的时候遇到的问题及解决方案</title>
			<link>https://caychance.github.io/posts/vuex%E5%AD%98%E5%82%A8%E7%9A%84%E6%97%B6%E5%80%99%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link>
			<pubDate>Tue, 22 Jan 2019 19:40:06 +0000</pubDate>
			
			<guid>https://caychance.github.io/posts/vuex%E5%AD%98%E5%82%A8%E7%9A%84%E6%97%B6%E5%80%99%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid>
			<description>引子 使用Vuex遇到过两个问题。
 页面刷新或者跳转到第三方再回来，数据是会丢掉的。即Vuex持久化存储问题。 在Vuex中存储一个Falsey值（PS：false,&amp;ldquo;,null,undefined,NaN）的时候，Vuex中存储不了。  解决 第一个问题，网上有很多解决方案。使用vuex-persistedstate。具体看文档，我就不细说了，可以使用localStorage,也可以使用cookie。
第二个问题，其实并不是Vuex本身的问题，而是因为我们项目中统一为每一个state字段生成了mutations方法。
generate方法中的语句state[name] = value || state[name];判断，value为false的时候，确实存不进来。
然后自己重新写了一个
updateToken(state,newToken){ state.token = newToken; } ... const options = { // 多页面共享数据  state: { aaa: &amp;#39;&amp;#39;, bbb:&amp;#39;&amp;#39;, ccc: &amp;#39;&amp;#39;, }, // 数据变更  mutations: { updateToken(state,newToken){ state.token = newToken; } }, } // 生成 mutations 方法 function generate(name) { return function (state, value) { state[name] = value || state[name]; } } // 为每个 state 字段生成对应的 mutations 方法 Object.</description>
			<content type="html"><![CDATA[

<hr />

<h3 id="引子">引子</h3>

<p>使用Vuex遇到过两个问题。</p>

<ol>
<li>页面刷新或者跳转到第三方再回来，数据是会丢掉的。即Vuex持久化存储问题。</li>
<li>在Vuex中存储一个Falsey值（PS：false,&ldquo;,null,undefined,NaN）的时候，Vuex中存储不了。</li>
</ol>

<h3 id="解决">解决</h3>

<p>第一个问题，网上有很多解决方案。使用<a href="https://github.com/robinvdvleuten/vuex-persistedstate">vuex-persistedstate</a>。具体看文档，我就不细说了，可以使用localStorage,也可以使用cookie。</p>

<p>第二个问题，其实并不是Vuex本身的问题，而是因为我们项目中统一为每一个state字段生成了mutations方法。</p>

<p>generate方法中的语句<code>state[name] = value || state[name];</code>判断，value为false的时候，确实存不进来。</p>

<p>然后自己重新写了一个</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">updateToken</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span><span class="nx">newToken</span><span class="p">){</span>
  <span class="nx">state</span><span class="p">.</span><span class="nx">token</span> <span class="o">=</span> <span class="nx">newToken</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="p">...</span>

<span class="k">const</span> <span class="nx">options</span> <span class="o">=</span> <span class="p">{</span>

  <span class="c1">// 多页面共享数据
</span><span class="c1"></span>  <span class="nx">state</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">aaa</span><span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
    <span class="nx">bbb</span><span class="o">:</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
    <span class="nx">ccc</span><span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
  <span class="p">},</span>

  <span class="c1">// 数据变更
</span><span class="c1"></span>  <span class="nx">mutations</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">updateToken</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span><span class="nx">newToken</span><span class="p">){</span>
      <span class="nx">state</span><span class="p">.</span><span class="nx">token</span> <span class="o">=</span> <span class="nx">newToken</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">},</span>
<span class="p">}</span>

<span class="c1">// 生成 mutations 方法
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">generate</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">state</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span> <span class="o">||</span> <span class="nx">state</span><span class="p">[</span><span class="nx">name</span><span class="p">];</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 为每个 state 字段生成对应的 mutations 方法
</span><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">options</span><span class="p">.</span><span class="nx">state</span><span class="p">).</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">key</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">options</span><span class="p">.</span><span class="nx">mutations</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">generate</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
<span class="p">});</span>
<span class="p">...</span>
<span class="k">export</span> <span class="k">default</span> <span class="nx">store</span><span class="p">;</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>find-记一次生产的bug排查</title>
			<link>https://caychance.github.io/posts/find-%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%9F%E4%BA%A7%E7%9A%84bug%E6%8E%92%E6%9F%A5/</link>
			<pubDate>Fri, 18 Jan 2019 21:14:12 +0000</pubDate>
			
			<guid>https://caychance.github.io/posts/find-%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%9F%E4%BA%A7%E7%9A%84bug%E6%8E%92%E6%9F%A5/</guid>
			<description> 前提概要 上线一周，最近的用户量增加了一些，今天下午的时候，群里一直被@，有一部分用户打开产品流程首页的时候白屏。
bug复现 借了用户的账号密码登录以后发现，我手机上是可以打开的。然后看了用户的手机系统是安卓5.0，不是很高的系统。然后找了一个测试的5.0的手机试了一下，还是可以打开的。反映出问题的用户中，vivo的机型比较多。然鹅，我们这边vivo的测试机没有5.0以下版本的。后来接到了一个魅族和小米的手机，分别是5.0和4.4的系统。登录账号，发现bug复现了。
问题定位 1.装了生产的包，打开chrome的调试功能(chrome://inspect/#devices);发现webpack打包以后的main文件里面的1行3000多列出现的报错。去代码中定位了一下，发现了这段代码。
let stepObj = allStep.find((item) =&amp;gt; { return item.routeName === currentName; });  2.chrome模拟打开页面的时候，在控制台输入navigator.userAgent，发现这个浏览器的是chrome 43。chrome43支持find语法吗？
3.去caniuse中搜索find的兼容性，发现chrome44以后的版本才支持find语法。
至此，问题已经定位到了。我们使用了find语法，但是用户的浏览器版本太低不支持。但是我们项目中使用了babel了呀?
问题解决 但是我们项目中使用了babel了呀?
虽然使用了babel，但是没有配置转换find语法。
google搜索babel find然后找到一条Stack Overflow的帖子。解决方法也列出来了。
至此，结束。
后记 当然了，还没有结束呢。
页面可以打开了，但是又出现另一个问题了。等着下周客户端一起检查一下。
心得  遇到bug心态一定要保持好，用我同事的话，你不觉得这样子一步步的去定位bug，跟侦探破案一样刺激吗？（PS：感谢他，以上有很多都是他发现的，受益匪浅）。
 用好google搜索，Stack Overflow,github等这些国外技术社区，真的会收益良多。（PS：百度是真的垃圾，此处略去一万字）
 英语好真的很重要啊。那天看了一篇文章，英语对一个程序员来说重要吗？回答是，如果英语不好不影响你做一个程序员；但是你想学好一门编程语言，那英语实在是太重要了。
  </description>
			<content type="html"><![CDATA[

<hr />

<h3 id="前提概要">前提概要</h3>

<p>上线一周，最近的用户量增加了一些，今天下午的时候，群里一直被@，有一部分用户打开产品流程首页的时候白屏。</p>

<h3 id="bug复现">bug复现</h3>

<p>借了用户的账号密码登录以后发现，我手机上是可以打开的。然后看了用户的手机系统是安卓5.0，不是很高的系统。然后找了一个测试的5.0的手机试了一下，还是可以打开的。反映出问题的用户中，vivo的机型比较多。然鹅，我们这边vivo的测试机没有5.0以下版本的。后来接到了一个魅族和小米的手机，分别是5.0和4.4的系统。登录账号，发现bug复现了。</p>

<h3 id="问题定位">问题定位</h3>

<p>1.装了生产的包，打开chrome的调试功能(chrome://inspect/#devices);发现webpack打包以后的main文件里面的1行3000多列出现的报错。去代码中定位了一下，发现了这段代码。</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">let</span> <span class="nx">stepObj</span> <span class="o">=</span> <span class="nx">allStep</span><span class="p">.</span><span class="nx">find</span><span class="p">((</span><span class="nx">item</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">item</span><span class="p">.</span><span class="nx">routeName</span> <span class="o">===</span> <span class="nx">currentName</span><span class="p">;</span>
<span class="p">});</span>
</code></pre></div>
<p>2.chrome模拟打开页面的时候，在控制台输入<code>navigator.userAgent</code>，发现这个浏览器的是chrome 43。chrome43支持find语法吗？</p>

<p>3.去<a href="https://caniuse.com/#search=find">caniuse</a>中搜索find的兼容性，发现chrome44以后的版本才支持find语法。</p>

<p>至此，问题已经定位到了。我们使用了find语法，但是用户的浏览器版本太低不支持。但是我们项目中使用了babel了呀?</p>

<h3 id="问题解决">问题解决</h3>

<p>但是我们项目中使用了babel了呀?</p>

<p>虽然使用了babel，但是没有配置转换find语法。</p>

<p>google搜索babel find然后找到一条Stack Overflow的<a href="https://stackoverflow.com/questions/32401513/array-find-doesnt-work-with-babel">帖子</a>。解决方法也列出来了。</p>

<p>至此，结束。</p>

<h3 id="后记">后记</h3>

<p>当然了，还没有结束呢。</p>

<p>页面可以打开了，但是又出现另一个问题了。等着下周客户端一起检查一下。</p>

<h3 id="心得">心得</h3>

<ol>
<li><p>遇到bug心态一定要保持好，用我同事的话，你不觉得这样子一步步的去定位bug，跟侦探破案一样刺激吗？（PS：感谢他，以上有很多都是他发现的，受益匪浅）。</p></li>

<li><p>用好google搜索，Stack Overflow,github等这些国外技术社区，真的会收益良多。（PS：百度是真的垃圾，此处略去一万字）</p></li>

<li><p>英语好真的很重要啊。那天看了一篇文章，英语对一个程序员来说重要吗？回答是，如果英语不好不影响你做一个程序员；但是你想学好一门编程语言，那英语实在是太重要了。</p></li>
</ol>
]]></content>
		</item>
		
		<item>
			<title>git学习笔记</title>
			<link>https://caychance.github.io/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
			<pubDate>Wed, 16 Jan 2019 13:52:57 +0000</pubDate>
			
			<guid>https://caychance.github.io/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
			<description>引言 git是14年才接触的，然后也没有系统的学习过。都是平时遇到一点问题，去搜一搜。
安装部分就不说了。
概念  工作区 就是电脑上写代码部分 版本库 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。  常用命令 初始化  mkdir learngit 新建一个文件夹
cd learngit 并进入该文件夹
git init 初始化，把该文件夹变成git可以管理的仓库（会产生一个.git文件）
git add  把文件修改添加到暂存区（Stage）
git commit -m  把暂存区的所有内容提交到当前分支
 查看状态及回退  git status 查看当前仓库状态
git diff 查看详细的修改内容
git diff HEAD &amp;ndash; readme.txt 查看工作区和版本库里面最新版本的区别
git log 查看从最近到最远的提交日志
git log &amp;ndash;pretty=oneline 查看从最近到最远的简洁版提交日志
git log &amp;ndash;graph 查看分支合并图
git reflog 查看历史命令
git reset &amp;ndash;hard HEAD^ 回退到上一个版本
git reset &amp;ndash;hard HEAD^^ 回退到上上一个版本</description>
			<content type="html"><![CDATA[

<hr />

<h3 id="引言">引言</h3>

<p>git是14年才接触的，然后也没有系统的学习过。都是平时遇到一点问题，去搜一搜。</p>

<p>安装部分就不说了。</p>

<h3 id="概念">概念</h3>

<p><img src="https://blog-pics.pek3b.qingstor.com/006tNc79ly1fz9dildkoxj30cq06iaa8.jpg" alt="" /></p>

<ol>
<li>工作区
就是电脑上写代码部分</li>
<li>版本库
Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。</li>
</ol>

<h3 id="常用命令">常用命令</h3>

<h4 id="初始化">初始化</h4>

<blockquote>
<p>mkdir learngit            新建一个文件夹<br>
cd learngit               并进入该文件夹<br>
git init                  初始化，把该文件夹变成git可以管理的仓库（会产生一个.git文件）<br>
git add <file>            把文件修改添加到暂存区（Stage）<br>
git commit -m <message>   把暂存区的所有内容提交到当前分支<br></p>
</blockquote>

<h4 id="查看状态及回退">查看状态及回退</h4>

<blockquote>
<p>git status                  查看当前仓库状态<br>
git diff                    查看详细的修改内容<br>
git diff HEAD &ndash; readme.txt 查看工作区和版本库里面最新版本的区别<br>
git log                     查看从最近到最远的提交日志<br>
git log &ndash;pretty=oneline    查看从最近到最远的简洁版提交日志<br>
git log &ndash;graph             查看分支合并图<br>
git reflog                  查看历史命令<br>
git reset &ndash;hard HEAD^      回退到上一个版本<br>
git reset &ndash;hard HEAD^^     回退到上上一个版本<br>
git reset &ndash;hard HEAD~10    回退到往上10个版本<br>
git reset &ndash;hard commit_id  回退到固定某个版本<br></p>
</blockquote>

<h4 id="放弃修改">放弃修改</h4>

<blockquote>
<p>git checkout &ndash; <file>      丢弃工作区的修改<br>
  git reset HEAD <file>       丢弃暂存区的修改，回到工作区<br>
  git rm <file>               从版本库中删除掉某文件<br></p>
</blockquote>

<h4 id="关联">关联</h4>

<blockquote>
<p>git remote add origin git@server-name:path/repo-name.git  关联一个远程仓库<br>
  git push -u origin <name>   关联后，第一次推送master分支的所有内容<br>
  git push origin <name>      以后的正常提交<br>
  git checkout -b <name>      新建dev分支并切换到dev分支<br>
  相当于
  git branch <name>           新建dev分支<br>
  git checkout <name>         切换到dev分支<br></p>
</blockquote>

<h4 id="合并删除分支">合并删除分支</h4>

<blockquote>
<p>git branch                  查看当前分支<br>
  git merge <name>            合并某个分支到当前分支<br>
  git branch -d <name>        删除分支<br>
  git branch -D <name>        强制删除分支<br></p>
</blockquote>

<h4 id="临时存储">临时存储</h4>

<blockquote>
<p>git stash                   把当前工作现场存储起来<br>
  git stash list              查看已存储<br>
  git stash apply             把已存储的内容恢复，内容不删除<br>
  git stash drop              删除已存储的内容<br>
  git stash pop               恢复内容以后同时删除内容<br></p>
</blockquote>

<h4 id="远程库">远程库</h4>

<blockquote>
<p>git remote                  查看远程库信息<br>
  git remote -v               查看远程库详细信息<br>
  git push origin <name>      把该分支上的所有本地提交推送到远程库<br>
  git checkout -b <name> origin/<name>  在本地创建和远程分支对应的分支,本地和远程分支的名称最好一致<br>
  git branch &ndash;set-upstream <name> origin/<name>  建立本地分支和远程分支的关联<br>
  git pull                    从远程合并<br>
  如果提示no tracking information<br />
  则说明本地分支和远程分支的链接关系没有创建，可以使用
  git branch &ndash;set-upstream-to <name> origin/<name><br></p>
</blockquote>

<h4 id="打标签">打标签</h4>

<blockquote>
<p>标签总是和某个commit挂钩。
  git tag <tagname>           用于新建一个标签，默认为HEAD，也可以指定一个commit id<br>
  git tag <tagname> commit_id 给指定一个commit_id新建一个标签<br>
  git tag                     查看所有标签<br>
  git show <tagname>          查看标签信息<br>
  git tag -d <tagname>        删除一个本地标签<br>
  git push origin <tagname>   推送某个标签到远程（PS：创建的标签都只存储在本地）<br>
  git push origin &ndash;tags      一次性推送全部尚未推送到远程的本地标签<br>
  如果标签已经推送到远程，要删除远程标签就麻烦一点
  git tag -d <tagname>                   删除一个本地标签<br>
  git push origin :refs/tags/<tagname>   删除一个远程标签<br></p>
</blockquote>

<h4 id="小结">小结</h4>

<p>git是Linux之父linus创造的，属于一种分布式版本控制系统。（PS：区别于集中式的版本控制系统）</p>
]]></content>
		</item>
		
		<item>
			<title>BFC</title>
			<link>https://caychance.github.io/posts/bfc/</link>
			<pubDate>Fri, 11 Jan 2019 20:31:59 +0000</pubDate>
			
			<guid>https://caychance.github.io/posts/bfc/</guid>
			<description>BFC是什么 前几天被人问到了BFC，一脸懵逼。赶紧看看，简单总结一下。
概念：  BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于普通流。
 PS:区别于普通流，常见的还有浮动（float），绝对定位（absolute）
具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。
BFC的特性：  同一个BFC中的margin会重叠 浮动的元素会脱离普通文档流，但是BFC却可以包含浮动的元素，即消除浮动。 BFC可以阻止元素被浮动元素覆盖。  如何触发BFC：(PS：满足一下任一条件即可触发)  body根元素 浮动元素：float除none以外的值 绝对定位元素：position 等于absolute或者fixed display等于 inline-block、table-cells、flex overflow等于除了 visible 以外的值 (hidden、auto、scroll) 类似函数作用域。  参考链接-10 分钟理解 BFC 原理</description>
			<content type="html"><![CDATA[

<hr />

<h3 id="bfc是什么">BFC是什么</h3>

<p>前几天被人问到了BFC，一脸懵逼。赶紧看看，简单总结一下。</p>

<h4 id="概念">概念：</h4>

<blockquote>
<p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于普通流。</p>
</blockquote>

<p>PS:区别于普通流，常见的还有浮动（float），绝对定位（absolute）</p>

<p><strong>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。</strong></p>

<h4 id="bfc的特性">BFC的特性：</h4>

<ol>
<li>同一个BFC中的margin会重叠</li>
<li>浮动的元素会脱离普通文档流，但是BFC却可以包含浮动的元素，即消除浮动。</li>
<li>BFC可以阻止元素被浮动元素覆盖。</li>
</ol>

<h4 id="如何触发bfc-ps-满足一下任一条件即可触发">如何触发BFC：(PS：满足一下任一条件即可触发)</h4>

<ol>
<li>body根元素</li>
<li>浮动元素：float除none以外的值</li>
<li>绝对定位元素：position 等于absolute或者fixed</li>
<li>display等于 inline-block、table-cells、flex</li>
<li>overflow等于除了 visible 以外的值 (hidden、auto、scroll)
类似函数作用域。</li>
</ol>

<p><a href="https://zhuanlan.zhihu.com/p/25321647">参考链接-10 分钟理解 BFC 原理</a></p>
]]></content>
		</item>
		
		<item>
			<title>如何使用七牛云</title>
			<link>https://caychance.github.io/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%B8%83%E7%89%9B%E4%BA%91/</link>
			<pubDate>Sat, 05 Jan 2019 23:59:38 +0000</pubDate>
			
			<guid>https://caychance.github.io/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%B8%83%E7%89%9B%E4%BA%91/</guid>
			<description>最近做了一个需求，使用七牛云的sdk来上传图片。 七牛云的文档写的可以更好一点。
html部分
&amp;lt;input ref=&amp;#39;imageUrl&amp;#39; type=&amp;#34;file&amp;#34; @click=&amp;#34;uploadImage(&amp;#39;imageUrl&amp;#39;)&amp;#34;&amp;gt; 这个用的是vue做的，所以会有一个ref标签，直接用原生html写的可以忽略。
//上传图片 uploadImage(ref) { //选中input元素  let input = undefined; if(ref === &amp;#39;imageUrl&amp;#39;){ input = this.$refs[ref]; } else{ input = this.$refs[ref][0]; } //input在onchange的时候触发  input.onchange = ()=&amp;gt;{ let _this = this; //localFileName 文件的本地名，一般是一个绝对地址的路径  let localFileName = input.value; //文件名  let suffix = localFileName.substring(localFileName.lastIndexOf(&amp;#34;.&amp;#34;),localFileName.length);//后缀名  let fileName = localFileName.substring(localFileName.lastIndexOf(&amp;#34;\\&amp;#34;)+1, let file = input.files[0]; //需要先获取上传七牛云的token  axios.get(`${GET_UPLOAD_TOKEN}?fileName=${fileName}`).then((response)=&amp;gt;{ if(response.code === 2000){ //七牛云token  const token = response.</description>
			<content type="html"><![CDATA[<hr />

<p>最近做了一个需求，使用七牛云的sdk来上传图片。  七牛云的文档写的可以更好一点。</p>

<p>html部分</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">input</span> <span class="na">ref</span><span class="o">=</span><span class="s">&#39;imageUrl&#39;</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;file&#34;</span> <span class="err">@</span><span class="na">click</span><span class="o">=</span><span class="s">&#34;uploadImage(&#39;imageUrl&#39;)&#34;</span><span class="p">&gt;</span></code></pre></div>
<p>这个用的是vue做的，所以会有一个ref标签，直接用原生html写的可以忽略。</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">//上传图片
</span><span class="c1"></span><span class="nx">uploadImage</span><span class="p">(</span><span class="nx">ref</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">//选中input元素
</span><span class="c1"></span>  <span class="kd">let</span> <span class="nx">input</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">ref</span> <span class="o">===</span> <span class="s1">&#39;imageUrl&#39;</span><span class="p">){</span>
    <span class="nx">input</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">$refs</span><span class="p">[</span><span class="nx">ref</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">else</span><span class="p">{</span>
    <span class="nx">input</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">$refs</span><span class="p">[</span><span class="nx">ref</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="c1">//input在onchange的时候触发
</span><span class="c1"></span>  <span class="nx">input</span><span class="p">.</span><span class="nx">onchange</span> <span class="o">=</span> <span class="p">()=&gt;{</span>
    <span class="kd">let</span> <span class="nx">_this</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="c1">//localFileName 文件的本地名，一般是一个绝对地址的路径
</span><span class="c1"></span>    <span class="kd">let</span> <span class="nx">localFileName</span> <span class="o">=</span> <span class="nx">input</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
    <span class="c1">//文件名
</span><span class="c1"></span>    <span class="kd">let</span> <span class="nx">suffix</span> <span class="o">=</span> <span class="nx">localFileName</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="nx">localFileName</span><span class="p">.</span><span class="nx">lastIndexOf</span><span class="p">(</span><span class="s2">&#34;.&#34;</span><span class="p">),</span><span class="nx">localFileName</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span><span class="c1">//后缀名
</span><span class="c1"></span>    <span class="kd">let</span> <span class="nx">fileName</span> <span class="o">=</span> <span class="nx">localFileName</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="nx">localFileName</span><span class="p">.</span><span class="nx">lastIndexOf</span><span class="p">(</span><span class="s2">&#34;\\&#34;</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>

    <span class="kd">let</span> <span class="nx">file</span> <span class="o">=</span> <span class="nx">input</span><span class="p">.</span><span class="nx">files</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="c1">//需要先获取上传七牛云的token
</span><span class="c1"></span>    <span class="nx">axios</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="nx">GET_UPLOAD_TOKEN</span><span class="si">}</span><span class="sb">?fileName=</span><span class="si">${</span><span class="nx">fileName</span><span class="si">}</span><span class="sb">`</span><span class="p">).</span><span class="nx">then</span><span class="p">((</span><span class="nx">response</span><span class="p">)=&gt;{</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">response</span><span class="p">.</span><span class="nx">code</span> <span class="o">===</span> <span class="mi">2000</span><span class="p">){</span>
        <span class="c1">//七牛云token
</span><span class="c1"></span>        <span class="k">const</span> <span class="nx">token</span> <span class="o">=</span> <span class="nx">response</span><span class="p">.</span><span class="nx">data</span><span class="p">;</span>
        <span class="k">const</span> <span class="nx">observer</span> <span class="o">=</span> <span class="p">{</span>
          <span class="nx">next</span><span class="p">(</span><span class="nx">response</span><span class="p">){</span>
            <span class="kd">let</span> <span class="nx">process</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">response</span><span class="p">.</span><span class="nx">total</span><span class="p">.</span><span class="nx">percent</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;%&#39;</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="nx">process</span> <span class="o">===</span> <span class="s1">&#39;100%&#39;</span><span class="p">){</span>
              <span class="c1">//这里可以写上传成功的处理逻辑
</span><span class="c1"></span>            <span class="p">}</span>
          <span class="p">},</span>
          <span class="nx">error</span><span class="p">(</span><span class="nx">err</span><span class="p">){</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
          <span class="p">},</span>
          <span class="nx">complete</span><span class="p">(</span><span class="nx">res1</span><span class="p">){</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">res1</span><span class="p">);</span>
          <span class="p">}</span>
        <span class="p">};</span>
        <span class="k">const</span> <span class="nx">key</span> <span class="o">=</span> <span class="nx">fileName</span><span class="p">;</span><span class="c1">//上传文件名
</span><span class="c1"></span>        <span class="k">const</span> <span class="nx">putExtra</span> <span class="o">=</span> <span class="p">{</span>
            <span class="nx">fname</span><span class="o">:</span> <span class="nx">fileName</span><span class="p">,</span>
            <span class="nx">params</span><span class="o">:</span> <span class="p">{},</span>
            <span class="nx">mimeType</span><span class="o">:</span><span class="p">[</span><span class="s2">&#34;image/png&#34;</span><span class="p">,</span> <span class="s2">&#34;image/jpeg&#34;</span><span class="p">,</span> <span class="s2">&#34;image/gif&#34;</span><span class="p">]</span>
        <span class="p">};</span>
        <span class="k">const</span> <span class="nx">config</span> <span class="o">=</span> <span class="p">{</span>
          <span class="nx">useCdnDomain</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
          <span class="nx">region</span><span class="o">:</span> <span class="nx">qiniu</span><span class="p">.</span><span class="nx">region</span><span class="p">.</span><span class="nx">z0</span>
        <span class="p">};</span>

        <span class="kd">let</span> <span class="nx">observable</span> <span class="o">=</span> <span class="nx">qiniu</span><span class="p">.</span><span class="nx">upload</span><span class="p">(</span><span class="nx">file</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">token</span><span class="p">,</span> <span class="nx">putExtra</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
        <span class="nx">observable</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="nx">observer</span><span class="p">)</span> <span class="c1">// 上传开始
</span><span class="c1"></span>      <span class="p">}</span>
    <span class="p">})</span>
  <span class="p">}</span>
<span class="p">},</span> 
</code></pre></div>
<p>以上结束。当然了，七牛云的存储那边也需要设置一下。具体查看文档就好了。其实js部分就是七牛云提供的，html部分，我刚开始很纠结，不知道能不能用form表单的action来操作。</p>

<p><a href="https://developer.qiniu.com/kodo/sdk/1283/javascript">七牛云的文档</a></p>
]]></content>
		</item>
		
		<item>
			<title>js继承方法总结</title>
			<link>https://caychance.github.io/posts/js%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</link>
			<pubDate>Thu, 13 Dec 2018 20:31:20 +0000</pubDate>
			
			<guid>https://caychance.github.io/posts/js%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</guid>
			<description>js继承方法  原型链继承 借用构造函数继承 组合继承 原型式继承 寄生式继承 寄生组合式继承 混入方式继承多个对象 ES6类继承extends 总结  原型链继承 构造函数、原型和实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个原型对象的指针。
 继承的本质就是复制，即重写原型对象，代之以一个新类型的实例。
 function Father() { this.property = true; } Father.prototype.getSuperValue = function() { return this.property; } function Son() { this.sonProperty = false; } // 这里是关键，创建Father的实例，并将该实例赋值给Son.prototype Son.prototype = new Father(); Son.prototype.getSubValue = function() { return this.sonProperty; } var instance = new Son(); console.log(instance.getSuperValue()); // true  原型链方案存在的缺点：
 多个实例对引用类型的操作会被篡改。  function Father(){ this.colors = [&amp;#34;red&amp;#34;, &amp;#34;blue&amp;#34;, &amp;#34;green&amp;#34;]; } function Son(){} Son.</description>
			<content type="html"><![CDATA[

<hr />

<h3 id="js继承方法">js继承方法</h3>

<ul>
<li><a href="#原型链继承">原型链继承</a></li>
<li><a href="#借用构造函数继承">借用构造函数继承</a></li>
<li><a href="#组合继承">组合继承</a></li>
<li><a href="#原型式继承">原型式继承</a></li>
<li><a href="#寄生式继承">寄生式继承</a></li>
<li><a href="#寄生组合式继承">寄生组合式继承</a></li>
<li><a href="#混入方式继承多个对象">混入方式继承多个对象</a></li>
<li><a href="#es6类继承extends">ES6类继承extends</a></li>
<li><a href="#总结">总结</a></li>
</ul>

<h4 id="原型链继承">原型链继承</h4>

<p>构造函数、原型和实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个原型对象的指针。</p>

<blockquote>
<p>继承的本质就是复制，即重写原型对象，代之以一个新类型的实例。</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">Father</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">property</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">Father</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getSuperValue</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">property</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">Son</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">sonProperty</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 这里是关键，创建Father的实例，并将该实例赋值给Son.prototype
</span><span class="c1"></span><span class="nx">Son</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Father</span><span class="p">();</span>
<span class="nx">Son</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getSubValue</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">sonProperty</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Son</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">instance</span><span class="p">.</span><span class="nx">getSuperValue</span><span class="p">());</span> <span class="c1">// true
</span></code></pre></div>
<p><img src="https://blog-pics.pek3b.qingstor.com/es5.png" alt="" /></p>

<p>原型链方案存在的缺点：</p>

<ul>
<li><strong>多个实例对引用类型的操作会被篡改。</strong></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">Father</span><span class="p">(){</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;red&#34;</span><span class="p">,</span> <span class="s2">&#34;blue&#34;</span><span class="p">,</span> <span class="s2">&#34;green&#34;</span><span class="p">];</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">Son</span><span class="p">(){}</span>
<span class="nx">Son</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Father</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">instance1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Son</span><span class="p">();</span>
<span class="nx">instance1</span><span class="p">.</span><span class="nx">colors</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&#34;black&#34;</span><span class="p">);</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">instance1</span><span class="p">.</span><span class="nx">colors</span><span class="p">);</span> <span class="c1">//&#34;red,blue,green,black&#34;
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">instance2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Son</span><span class="p">();</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">instance2</span><span class="p">.</span><span class="nx">colors</span><span class="p">);</span> <span class="c1">//&#34;red,blue,green,black&#34;
</span></code></pre></div>
<h4 id="借用构造函数继承">借用构造函数继承</h4>

<blockquote>
<p>使用父类的构造函数来增强子类实例，等同于复制父类的实例给子类（不使用原型）</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span>  <span class="nx">Father</span><span class="p">(){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">color</span><span class="o">=</span><span class="p">[</span><span class="s2">&#34;red&#34;</span><span class="p">,</span><span class="s2">&#34;green&#34;</span><span class="p">,</span><span class="s2">&#34;blue&#34;</span><span class="p">];</span>
<span class="p">}</span>
<span class="kd">function</span>  <span class="nx">Son</span><span class="p">(){</span>
    <span class="c1">//继承自Father
</span><span class="c1"></span>    <span class="nx">Father</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">instance1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Son</span><span class="p">();</span>
<span class="nx">instance1</span><span class="p">.</span><span class="nx">color</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&#34;black&#34;</span><span class="p">);</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">instance1</span><span class="p">.</span><span class="nx">color</span><span class="p">);</span><span class="c1">//&#34;red,green,blue,black&#34;
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">instance2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Son</span><span class="p">();</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">instance2</span><span class="p">.</span><span class="nx">color</span><span class="p">);</span><span class="c1">//&#34;red,green,blue&#34;
</span></code></pre></div>
<p>核心代码是<code>Father.call(this)</code>，创建子类实例时调用<code>Father</code>构造函数，于是<code>Son</code>的每个实例都会将<code>Father</code>中的属性复制一份。</p>

<p>借用构造函数继承的缺点：</p>

<ul>
<li>只能继承父类的实例属性和方法，不能继承原型属性/方法</li>
<li>无法实现复用，每个子类都有父类实例函数的副本，影响性能</li>
</ul>

<h4 id="组合继承">组合继承</h4>

<blockquote>
<p>组合上述两种方法就是组合继承。用<strong>原型链实现对原型属性和方法的继承</strong>，用<strong>借用构造函数技术来实现实例属性的继承</strong>。</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">Father</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;red&#34;</span><span class="p">,</span> <span class="s2">&#34;blue&#34;</span><span class="p">,</span> <span class="s2">&#34;green&#34;</span><span class="p">];</span>
<span class="p">}</span>
<span class="nx">Father</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
  <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
<span class="p">};</span>
<span class="kd">function</span> <span class="nx">Son</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">){</span>
  <span class="c1">// 继承属性
</span><span class="c1"></span>  <span class="c1">// 第二次调用Father()
</span><span class="c1"></span>  <span class="nx">Father</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">name</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 继承方法
</span><span class="c1">// 构建原型链
</span><span class="c1">// 第一次调用Father()
</span><span class="c1"></span><span class="nx">Son</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Father</span><span class="p">();</span>
<span class="c1">// 重写Son.prototype的constructor属性，指向自己的构造函数Son
</span><span class="c1"></span><span class="nx">Son</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">=</span> <span class="nx">Son</span><span class="p">;</span>
<span class="nx">Son</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayAge</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">age</span><span class="p">);</span>
<span class="p">};</span>
<span class="kd">var</span> <span class="nx">instance1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Son</span><span class="p">(</span><span class="s2">&#34;Nicholas&#34;</span><span class="p">,</span> <span class="mi">29</span><span class="p">);</span>
<span class="nx">instance1</span><span class="p">.</span><span class="nx">colors</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&#34;black&#34;</span><span class="p">);</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">instance1</span><span class="p">.</span><span class="nx">colors</span><span class="p">);</span> <span class="c1">//&#34;red,blue,green,black&#34;
</span><span class="c1"></span><span class="nx">instance1</span><span class="p">.</span><span class="nx">sayName</span><span class="p">();</span> <span class="c1">//&#34;Nicholas&#34;;
</span><span class="c1"></span><span class="nx">instance1</span><span class="p">.</span><span class="nx">sayAge</span><span class="p">();</span> <span class="c1">//29
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">instance2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Son</span><span class="p">(</span><span class="s2">&#34;Greg&#34;</span><span class="p">,</span> <span class="mi">27</span><span class="p">);</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">instance2</span><span class="p">.</span><span class="nx">colors</span><span class="p">);</span> <span class="c1">//&#34;red,blue,green&#34;
</span><span class="c1"></span><span class="nx">instance2</span><span class="p">.</span><span class="nx">sayName</span><span class="p">();</span> <span class="c1">//&#34;Greg&#34;;
</span><span class="c1"></span><span class="nx">instance2</span><span class="p">.</span><span class="nx">sayAge</span><span class="p">();</span> <span class="c1">//27
</span></code></pre></div>
<p>组合继承的缺点：</p>

<ul>
<li>第一次调用Father()：给Son.prototype写入两个属性name，color。</li>
<li>第二次调用Father()：给instance1写入两个属性name，color。</li>
</ul>

<p>实例对象instance1上的两个属性就屏蔽了其原型对象Son.prototype的两个同名属性。所以，组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。</p>

<h4 id="原型式继承">原型式继承</h4>

<blockquote>
<p>利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">object</span><span class="p">(</span><span class="nx">obj</span><span class="p">){</span>
  <span class="kd">function</span> <span class="nx">F</span><span class="p">(){}</span>
  <span class="nx">F</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">;</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nx">F</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>object()对传入其中的对象执行了一次<strong>浅复制</strong>，将构造函数F的原型直接指向传入的对象。</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">name</span><span class="o">:</span> <span class="s2">&#34;Nicholas&#34;</span><span class="p">,</span>
  <span class="nx">friends</span><span class="o">:</span> <span class="p">[</span><span class="s2">&#34;Shelby&#34;</span><span class="p">,</span> <span class="s2">&#34;Court&#34;</span><span class="p">,</span> <span class="s2">&#34;Van&#34;</span><span class="p">]</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">anotherPerson</span> <span class="o">=</span> <span class="nx">object</span><span class="p">(</span><span class="nx">person</span><span class="p">);</span>
<span class="nx">anotherPerson</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s2">&#34;Greg&#34;</span><span class="p">;</span>
<span class="nx">anotherPerson</span><span class="p">.</span><span class="nx">friends</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&#34;Rob&#34;</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">yetAnotherPerson</span> <span class="o">=</span> <span class="nx">object</span><span class="p">(</span><span class="nx">person</span><span class="p">);</span>
<span class="nx">yetAnotherPerson</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s2">&#34;Linda&#34;</span><span class="p">;</span>
<span class="nx">yetAnotherPerson</span><span class="p">.</span><span class="nx">friends</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&#34;Barbie&#34;</span><span class="p">);</span>

<span class="nx">alert</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">friends</span><span class="p">);</span>   <span class="c1">//&#34;Shelby,Court,Van,Rob,Barbie&#34;
</span></code></pre></div>
<p>原型式继承缺点：</p>

<ul>
<li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li>
<li>无法传递参数
另外，ES5中存在Object.create()的方法，能够代替上面的object方法。</li>
</ul>

<h4 id="寄生式继承">寄生式继承</h4>

<blockquote>
<p>核心：在原型式继承的基础上，增强对象，返回构造函数</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">createAnother</span><span class="p">(</span><span class="nx">original</span><span class="p">){</span>
  <span class="kd">var</span> <span class="nx">clone</span> <span class="o">=</span> <span class="nx">object</span><span class="p">(</span><span class="nx">original</span><span class="p">);</span> <span class="c1">// 通过调用 object() 函数创建一个新对象
</span><span class="c1"></span>  <span class="nx">clone</span><span class="p">.</span><span class="nx">sayHi</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>  <span class="c1">// 以某种方式来增强对象
</span><span class="c1"></span>    <span class="nx">alert</span><span class="p">(</span><span class="s2">&#34;hi&#34;</span><span class="p">);</span>
  <span class="p">};</span>
  <span class="k">return</span> <span class="nx">clone</span><span class="p">;</span> <span class="c1">// 返回这个对象
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>
<p>函数的主要作用是为构造函数新增属性和方法，以增强函数</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">name</span><span class="o">:</span> <span class="s2">&#34;Nicholas&#34;</span><span class="p">,</span>
  <span class="nx">friends</span><span class="o">:</span> <span class="p">[</span><span class="s2">&#34;Shelby&#34;</span><span class="p">,</span> <span class="s2">&#34;Court&#34;</span><span class="p">,</span> <span class="s2">&#34;Van&#34;</span><span class="p">]</span>
<span class="p">};</span>
<span class="kd">var</span> <span class="nx">anotherPerson</span> <span class="o">=</span> <span class="nx">createAnother</span><span class="p">(</span><span class="nx">person</span><span class="p">);</span>
<span class="nx">anotherPerson</span><span class="p">.</span><span class="nx">sayHi</span><span class="p">();</span> <span class="c1">//&#34;hi&#34;
</span></code></pre></div>
<p>寄生式继承的缺点（同原型式继承）：</p>

<ul>
<li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li>
<li>无法传递参数</li>
</ul>

<h4 id="寄生组合式继承">寄生组合式继承</h4>

<blockquote>
<p>结合借用构造函数(2)传递参数和寄生模式(5)实现继承</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">inheritPrototype</span><span class="p">(</span><span class="nx">son</span><span class="p">,</span> <span class="nx">father</span><span class="p">){</span>
  <span class="kd">var</span> <span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">father</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span> <span class="c1">// 创建对象，创建父类原型的一个副本
</span><span class="c1"></span>  <span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">=</span> <span class="nx">son</span><span class="p">;</span>                    <span class="c1">// 增强对象，弥补因重写原型而失去的默认的constructor 属性
</span><span class="c1"></span>  <span class="nx">son</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">prototype</span><span class="p">;</span>                      <span class="c1">// 指定对象，将新创建的对象赋值给子类的原型
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// 父类初始化实例属性和原型属性
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">Father</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;red&#34;</span><span class="p">,</span> <span class="s2">&#34;blue&#34;</span><span class="p">,</span> <span class="s2">&#34;green&#34;</span><span class="p">];</span>
<span class="p">}</span>
<span class="nx">Father</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
  <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">Son</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">){</span>
  <span class="nx">Father</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">name</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 将父类原型指向子类
</span><span class="c1"></span><span class="nx">inheritPrototype</span><span class="p">(</span><span class="nx">Son</span><span class="p">,</span> <span class="nx">Father</span><span class="p">);</span>

<span class="c1">// 新增子类原型属性
</span><span class="c1"></span><span class="nx">Son</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayAge</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
  <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">age</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">instance1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Son</span><span class="p">(</span><span class="s2">&#34;xyc&#34;</span><span class="p">,</span> <span class="mi">23</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">instance2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Son</span><span class="p">(</span><span class="s2">&#34;lxy&#34;</span><span class="p">,</span> <span class="mi">23</span><span class="p">);</span>

<span class="nx">instance1</span><span class="p">.</span><span class="nx">colors</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&#34;2&#34;</span><span class="p">);</span> <span class="c1">// [&#34;red&#34;, &#34;blue&#34;, &#34;green&#34;, &#34;2&#34;]
</span><span class="c1"></span><span class="nx">instance1</span><span class="p">.</span><span class="nx">colors</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&#34;3&#34;</span><span class="p">);</span> <span class="c1">// [&#34;red&#34;, &#34;blue&#34;, &#34;green&#34;, &#34;3&#34;]
</span></code></pre></div>
<ul>
<li>这个例子的高效率体现在它只调用了一次<code>Father</code>构造函数，并且因此避免了在<code>Son.prototype</code>上创建不必要的、多余的属性。
于此同时，原型链还能保持不变；因此，还能够正常使用<code>instanceof</code>和<code>isPrototypeOf()</code></li>
<li>这是最成熟的方法，也是现在库实现的方法</li>
</ul>

<h4 id="混入方式继承多个对象">混入方式继承多个对象</h4>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">MyClass</span><span class="p">()</span> <span class="p">{</span>
     <span class="nx">SuperClass</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
     <span class="nx">OtherSuperClass</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 继承一个类
</span><span class="c1"></span><span class="nx">MyClass</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">SuperClass</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
<span class="c1">// 混合其它
</span><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">MyClass</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="nx">OtherSuperClass</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>
<span class="c1">// 重新指定constructor
</span><span class="c1"></span><span class="nx">MyClass</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">=</span> <span class="nx">MyClass</span><span class="p">;</span>

<span class="nx">MyClass</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">myMethod</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
     <span class="c1">// do something
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div>
<p>Object.assign会把 OtherSuperClass原型上的函数拷贝到 MyClass原型上，使 MyClass 的所有实例都可用 OtherSuperClass 的方法。</p>

<h4 id="es6类继承extends">ES6类继承extends</h4>

<p>extends关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中constructor表示构造函数，一个类中只能有一个构造函数，有多个会报出SyntaxError错误,如果没有显式指定构造方法，则会添加默认的 constructor方法，使用例子如下。</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="k">class</span> <span class="nx">Rectangle</span> <span class="p">{</span>
    <span class="c1">// constructor
</span><span class="c1"></span>    <span class="nx">constructor</span><span class="p">(</span><span class="nx">height</span><span class="p">,</span> <span class="nx">width</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">height</span> <span class="o">=</span> <span class="nx">height</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="nx">width</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Getter
</span><span class="c1"></span>    <span class="nx">get</span> <span class="nx">area</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">calcArea</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="c1">// Method
</span><span class="c1"></span>    <span class="nx">calcArea</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">height</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">width</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">const</span> <span class="nx">rectangle</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Rectangle</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">rectangle</span><span class="p">.</span><span class="nx">area</span><span class="p">);</span>
<span class="c1">// 输出 200
</span><span class="c1"></span>
<span class="o">-----------------------------------------------------------------</span>
<span class="c1">// 继承
</span><span class="c1"></span><span class="k">class</span> <span class="nx">Square</span> <span class="k">extends</span> <span class="nx">Rectangle</span> <span class="p">{</span>

  <span class="nx">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">length</span><span class="p">);</span>

    <span class="c1">// 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s1">&#39;Square&#39;</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">get</span> <span class="nx">area</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">height</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">width</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">const</span> <span class="nx">square</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Square</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">square</span><span class="p">.</span><span class="nx">area</span><span class="p">);</span>
<span class="c1">// 输出 100
</span></code></pre></div>
<p>extends继承的核心代码如下，其实现和上述的寄生组合式继承方式一样</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">_inherits</span><span class="p">(</span><span class="nx">son</span><span class="p">,</span> <span class="nx">father</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// 创建对象，创建父类原型的一个副本
</span><span class="c1"></span>    <span class="c1">// 增强对象，弥补因重写原型而失去的默认的constructor 属性
</span><span class="c1"></span>    <span class="c1">// 指定对象，将新创建的对象赋值给子类的原型
</span><span class="c1"></span>    <span class="nx">son</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">father</span> <span class="o">&amp;&amp;</span> <span class="nx">father</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="p">{</span>
        <span class="nx">constructor</span><span class="o">:</span> <span class="p">{</span>
            <span class="nx">value</span><span class="o">:</span> <span class="nx">son</span><span class="p">,</span>
            <span class="nx">enumerable</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
            <span class="nx">writable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
            <span class="nx">configurable</span><span class="o">:</span> <span class="kc">true</span>
        <span class="p">}</span>
    <span class="p">});</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">father</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span>
            <span class="o">?</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">son</span><span class="p">,</span> <span class="nx">father</span><span class="p">)</span>
            <span class="o">:</span> <span class="nx">son</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">father</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="总结">总结</h4>

<p>1、ES5继承和ES6继承的区别</p>

<ul>
<li>ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.call(this)）.</li>
<li>ES6的继承有所不同，实质上是先创建父类的实例对象this，然后再用子类的构造函数修改this。因为子类没有自己的this对象，所以必须先调用父类的super()方法，否则新建实例报错。</li>
</ul>

<p><img src="https://blog-pics.pek3b.qingstor.com/compare.png" alt="" /></p>
]]></content>
		</item>
		
		<item>
			<title>浏览器缓存机制</title>
			<link>https://caychance.github.io/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</link>
			<pubDate>Thu, 06 Dec 2018 16:43:58 +0000</pubDate>
			
			<guid>https://caychance.github.io/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</guid>
			<description>（PS:这篇文章，就是纯粹的纸上谈兵哈，并没有实践过。所以一定要自己动手试试。）
浏览器缓存的基本原理 1）浏览器在加载资源时，根据请求头的expires和cache-control判断是否命中强缓存，是则直接从缓存读取资源，不会发请求到服务器。
2）如果没有命中强缓存，浏览器一定会发送一个请求到服务器，通过last-modified和etag验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回，但是不会返回这个资源的数据，依然是从缓存中读取资源
3）如果前面两者都没有命中，直接从服务器加载资源
浏览器缓存类型： 浏览器的缓存分为两种：强缓存和协商缓存。
强缓存：不会向服务器发送请求，直接从缓存中读取资源。
协商缓存：向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；
区别 共同点：两者都是从客户端缓存中读取资源；区别：强缓存不会向服务器发送请求，协商缓存会向服务器发送请求。
强缓存相关字段 Expires和Cache-Control
1）Expires
Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回。 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效
 Expires: Wed, 11 May 2018 07:20:00 GMT
 2）Cache-Control
Cache-Control 出现于 HTTP / 1.1，优先级高于 Expires ,表示的是相对时间。
相对Expires而言，max-age是距离请求发起的时间的秒数。
 Cache-Control: max-age=315360000
 协商缓存相关字段 协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的。
1）Last-Modified，If-Modified-Since
Last-Modified 表示本地文件最后修改日期，浏览器会在request header加上If-Modified-Since（上次返回的Last-Modified的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来
但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag
2）ETag、If-None-Match
Etag就像一个指纹，资源变化都会导致ETag变化，跟最后修改时间没有关系，ETag可以保证每一个资源是唯一的
If-None-Match的header会将上次返回的Etag发送给服务器，询问该资源的Etag是否有更新，有变动就会发送新的资源回来
3）ETag的优先级比Last-Modified更高
具体为什么要用ETag，主要出于下面几种情况考虑：
 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET； 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)； 某些服务器不能精确的得到文件的最后修改时间。  浏览器缓存机制：强缓存、协商缓存
浏览器的缓存机制小结</description>
			<content type="html"><![CDATA[

<hr />

<p>（PS:这篇文章，就是纯粹的纸上谈兵哈，并没有实践过。所以一定要自己动手试试。）</p>

<h3 id="浏览器缓存的基本原理">浏览器缓存的基本原理</h3>

<p>1）浏览器在加载资源时，根据请求头的<code>expires</code>和<code>cache-control</code>判断是否命中强缓存，是则直接从缓存读取资源，不会发请求到服务器。</p>

<p>2）如果没有命中强缓存，浏览器一定会发送一个请求到服务器，通过<code>last-modified</code>和<code>etag</code>验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回，但是不会返回这个资源的数据，依然是从缓存中读取资源</p>

<p>3）如果前面两者都没有命中，直接从服务器加载资源</p>

<h3 id="浏览器缓存类型">浏览器缓存类型：</h3>

<p>浏览器的缓存分为两种：强缓存和协商缓存。</p>

<p>强缓存：不会向服务器发送请求，直接从缓存中读取资源。</p>

<p>协商缓存：向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；</p>

<h3 id="区别">区别</h3>

<p>共同点：两者都是从客户端缓存中读取资源；区别：强缓存不会向服务器发送请求，协商缓存会向服务器发送请求。</p>

<h3 id="强缓存相关字段">强缓存相关字段</h3>

<p>Expires和Cache-Control</p>

<p>1）Expires</p>

<p>Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回。
Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效</p>

<blockquote>
<p>Expires: Wed, 11 May 2018 07:20:00 GMT</p>
</blockquote>

<p>2）Cache-Control</p>

<p>Cache-Control 出现于 HTTP / 1.1，优先级高于 Expires ,表示的是相对时间。</p>

<p>相对Expires而言，max-age是距离请求发起的时间的秒数。</p>

<blockquote>
<p>Cache-Control: max-age=315360000</p>
</blockquote>

<h3 id="协商缓存相关字段">协商缓存相关字段</h3>

<p>协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的。</p>

<p>1）Last-Modified，If-Modified-Since</p>

<p><code>Last-Modified</code> 表示本地文件最后修改日期，浏览器会在request header加上<code>If-Modified-Since</code>（上次返回的<code>Last-Modified</code>的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来</p>

<p>但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag</p>

<p>2）ETag、If-None-Match</p>

<p><code>Etag</code>就像一个指纹，资源变化都会导致<code>ETag</code>变化，跟最后修改时间没有关系，<code>ETag</code>可以保证每一个资源是唯一的</p>

<p><code>If-None-Match</code>的header会将上次返回的<code>Etag</code>发送给服务器，询问该资源的<code>Etag</code>是否有更新，有变动就会发送新的资源回来</p>

<p>3）ETag的优先级比Last-Modified更高</p>

<p>具体为什么要用<code>ETag</code>，主要出于下面几种情况考虑：</p>

<ul>
<li>一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；</li>
<li>某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；</li>
<li>某些服务器不能精确的得到文件的最后修改时间。</li>
</ul>

<p><a href="https://github.com/amandakelake/blog/issues/41">浏览器缓存机制：强缓存、协商缓存</a></p>

<p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651226262&amp;idx=1&amp;sn=2128db200b88479face67ed8e095757c&amp;chksm=bd4959128a3ed0041b43a5683c75c4b88c7d35fac909a59c14b4e9fc11e8d408680b171d2706&amp;scene=21#wechat_redirect">浏览器的缓存机制小结</a></p>
]]></content>
		</item>
		
		<item>
			<title>js event loop</title>
			<link>https://caychance.github.io/posts/js-event-loop/</link>
			<pubDate>Thu, 06 Dec 2018 15:45:40 +0000</pubDate>
			
			<guid>https://caychance.github.io/posts/js-event-loop/</guid>
			<description>JavaScript是单线程的，这与它的用途有关。
为什么JavaScript是单线程的？ 假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？
任务分类 同步任务和异步任务 因为JavaScript是单线程的，如果加载一个图片，需要很久，那么网页就会阻塞。因此，从广义上来讲任务分为两类：
 同步任务   同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务
  异步任务   异步任务指的是，不进入主线程、而进入&amp;rdquo;任务队列&amp;rdquo;（task queue）的任务，只有&amp;rdquo;任务队列&amp;rdquo;通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。
 执行顺序：
（1）所有同步任务都在主线程上执行，形成一个执行栈。 （2）主线程之外，还存在一个&amp;quot;任务队列&amp;quot;（task queue）。只要异步任务有了运行结果，就在&amp;quot;任务队列&amp;quot;之中放置一个事件。 （3）一旦&amp;quot;执行栈&amp;quot;中的所有同步任务执行完毕，系统就会读取&amp;quot;任务队列&amp;quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 （4）主线程不断重复上面的第三步。  宏任务和微任务 对任务进行更精细的定义的话，也可以分为两类：
 宏任务（macro-task）    包括整体代码script、setTimeout、setInterval、setImmediate、requestAnimationFrame、I/O、UI Rendering
  微任务（micro-task）   new Promise().then(回调)、Process.nextTick、Object.observe、MutationObserver
 浏览器中的Event Loop 执行顺序：
1.当某个宏任务执行完后,会查看是否有微任务队列。 2-1.如果有，先执行微任务队列中的所有任务， 2-2.如果没有，会读取宏任务队列中排在最前的任务， 3.执行宏任务的过程中，遇到微任务，依次加入微任务队列。 4.栈空后，再次读取微任务队列里的任务，依次类推。  Node中的Event Loop Node中的Event Loop不同于浏览器。Node运行机制如下：
 V8引擎解析JavaScript脚本。 解析后的代码，调用Node API。 libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。 V8引擎再将结果返回给用户。  其中libuv引擎中的事件循环分为6个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。
node中的事件循环的顺序：
外部输入数据&amp;ndash;&amp;gt;轮询阶段(poll)&amp;ndash;&amp;gt;检查阶段(check)&amp;ndash;&amp;gt;关闭事件回调阶段(close callback)&amp;ndash;&amp;gt;定时器检测阶段(timer)&amp;ndash;&amp;gt;I/O事件回调阶段(I/O callbacks)&amp;ndash;&amp;gt;闲置阶段(idle, prepare)&amp;ndash;&amp;gt;轮询阶段（按照该顺序反复运行）</description>
			<content type="html"><![CDATA[

<hr />

<p>JavaScript是单线程的，这与它的用途有关。</p>

<h3 id="为什么javascript是单线程的">为什么JavaScript是单线程的？</h3>

<p>假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p>

<h3 id="任务分类">任务分类</h3>

<h4 id="同步任务和异步任务">同步任务和异步任务</h4>

<p>因为JavaScript是单线程的，如果加载一个图片，需要很久，那么网页就会阻塞。因此，从广义上来讲任务分为两类：</p>

<ul>
<li>同步任务</li>
</ul>

<blockquote>
<p>同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务</p>
</blockquote>

<ul>
<li>异步任务</li>
</ul>

<blockquote>
<p>异步任务指的是，不进入主线程、而进入&rdquo;任务队列&rdquo;（task queue）的任务，只有&rdquo;任务队列&rdquo;通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p>
</blockquote>

<p>执行顺序：</p>

<pre><code>（1）所有同步任务都在主线程上执行，形成一个执行栈。
（2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。
（3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
（4）主线程不断重复上面的第三步。
</code></pre>

<p><img src="https://blog-pics.pek3b.qingstor.com/006tKfTcly1g1jrpu6q3ij30g50boq3q.jpg" alt="" /></p>

<h4 id="宏任务和微任务">宏任务和微任务</h4>

<p>对任务进行更精细的定义的话，也可以分为两类：</p>

<ul>
<li>宏任务（macro-task）
<br /></li>
</ul>

<blockquote>
<p>包括整体代码script、setTimeout、setInterval、setImmediate、requestAnimationFrame、I/O、UI Rendering</p>
</blockquote>

<ul>
<li>微任务（micro-task）</li>
</ul>

<blockquote>
<p>new Promise().then(回调)、Process.nextTick、Object.observe、MutationObserver</p>
</blockquote>

<h3 id="浏览器中的event-loop">浏览器中的Event Loop</h3>

<p>执行顺序：</p>

<pre><code>1.当某个宏任务执行完后,会查看是否有微任务队列。
2-1.如果有，先执行微任务队列中的所有任务，
2-2.如果没有，会读取宏任务队列中排在最前的任务，
3.执行宏任务的过程中，遇到微任务，依次加入微任务队列。
4.栈空后，再次读取微任务队列里的任务，依次类推。
</code></pre>

<h3 id="node中的event-loop">Node中的Event Loop</h3>

<p><img src="https://blog-pics.pek3b.qingstor.com/006tKfTcly1g1js5cwo3wj30m808saad.jpg" alt="" /></p>

<p>Node中的Event Loop不同于浏览器。Node运行机制如下：</p>

<ul>
<li>V8引擎解析JavaScript脚本。</li>
<li>解析后的代码，调用Node API。</li>
<li>libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。</li>
<li>V8引擎再将结果返回给用户。</li>
</ul>

<p>其中libuv引擎中的事件循环分为6个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。</p>

<p><img src="https://blog-pics.pek3b.qingstor.com/006tKfTcly1g1js4x78vxj30lg0jm76o.jpg" alt="" /></p>

<p>node中的事件循环的顺序：</p>

<p>外部输入数据&ndash;&gt;轮询阶段(poll)&ndash;&gt;检查阶段(check)&ndash;&gt;关闭事件回调阶段(close callback)&ndash;&gt;定时器检测阶段(timer)&ndash;&gt;I/O事件回调阶段(I/O callbacks)&ndash;&gt;闲置阶段(idle, prepare)&ndash;&gt;轮询阶段（按照该顺序反复运行）</p>

<ul>
<li>timers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调</li>
<li>I/O callbacks阶段：处理一些上一轮循环中的少数未执行的 I/O 回调</li>
<li>idle, prepare 阶段：仅node内部使用</li>
<li>poll 阶段：获取新的I/O事件,适当的条件下node将阻塞在这里</li>
<li>check 阶段：执行 setImmediate() 的回调</li>
<li>close callbacks 阶段：执行 socket 的 close事件回调</li>
</ul>

<h3 id="区别">区别</h3>

<p>浏览器和Node 环境下，microtask 任务队列的执行时机不同</p>

<ul>
<li>浏览器端，microtask 在事件循环的 macrotask 执行完之后执行</li>
<li>Node端，microtask 在事件循环的各个阶段之间执行</li>
<li>Node11版本中，Event Loop运行原理发生了变化，一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就立刻执行微任务队列，这点就跟浏览器端一致。</li>
</ul>

<h3 id="总结">总结</h3>

<p>浏览器端：</p>

<p>先执行宏任务，宏任务执行完以后，执行当前的微任务。然后再依次往后执行，循环。</p>

<p>Node端：</p>

<p>1.Node版本11 同浏览器端</p>

<p>2.Node版本10及以下</p>

<p>按照<code>poll=&gt;check=&gt;close callbacks=&gt;timers=&gt;I/O callbacks=&gt;idle,prepare</code>的顺序执行，微任务会在每个阶段执行完以后执行。</p>
]]></content>
		</item>
		
		<item>
			<title>markdown</title>
			<link>https://caychance.github.io/posts/markdown/</link>
			<pubDate>Wed, 05 Dec 2018 14:13:45 +0000</pubDate>
			
			<guid>https://caychance.github.io/posts/markdown/</guid>
			<description>可直接参考该文章
markdown常用语法 目录  标题 引入代码 外链 引入图片 引用 缩进 斜体 加粗 分割线 待办 目录锚点 引入单句代码 表格  1、标题 井号#后面空一格
# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 2、引入代码
function add(x,y){ return x+y; }  3、外链
[参考链接](https://caychance.github.io/) 参考链接
4、引入图片
![](https://blog-pics.pek3b.qingstor.com/006tNbRwly1fxq7h427d7j30780c7t9o.jpg) 5、引用
&amp;gt;一段引用的话 换行了  一段引用的话 换行了
 6、缩进 三种方法
不带缩进的一行 &amp;amp;nbsp;不断行的空白格或&amp;amp;#160; &amp;amp;ensp;半方大的空白或&amp;amp;#8194; &amp;amp;emsp;全方大的空白或&amp;amp;#8195; 不带缩进的一行 &amp;nbsp;不断行的空白格或&amp;#160; &amp;ensp;半方大的空白或&amp;#8194; &amp;emsp;全方大的空白或&amp;#8195;
7、斜体 两种方法</description>
			<content type="html"><![CDATA[

<hr />

<p><a href="http://xianbai.me/learn-md/index.html">可直接参考该文章</a></p>

<h3 id="markdown常用语法">markdown常用语法</h3>

<h4 id="目录">目录</h4>

<ul>
<li><a href="#1">标题</a></li>
<li><a href="#2">引入代码</a></li>
<li><a href="#3">外链</a></li>
<li><a href="#4">引入图片</a></li>
<li><a href="#5">引用</a></li>
<li><a href="#6">缩进</a></li>
<li><a href="#7">斜体</a></li>
<li><a href="#8">加粗</a></li>
<li><a href="#9">分割线</a></li>
<li><a href="#10">待办</a></li>
<li><a href="#11目录锚点">目录锚点</a></li>
<li><a href="#12引入单句代码">引入单句代码</a></li>
<li><a href="#13表格">表格</a></li>
</ul>

<p><h4 id=1>1、标题</h4>
井号#后面空一格</p>
<div class="highlight"><pre class="chroma"><code class="language-markdown" data-lang="markdown"><span class="gh"># 一级标题
</span><span class="gh"></span><span class="gu">## 二级标题
</span><span class="gu">### 三级标题
</span><span class="gu">#### 四级标题
</span><span class="gu">##### 五级标题
</span><span class="gu"></span>###### 六级标题</code></pre></div>
<h1 id="一级标题">一级标题</h1>

<h2 id="二级标题">二级标题</h2>

<h3 id="三级标题">三级标题</h3>

<h4 id="四级标题">四级标题</h4>

<h5 id="五级标题">五级标题</h5>

<h6 id="六级标题">六级标题</h6>

<p><h4 id=2>2、引入代码</h4></p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">){</span>
  <span class="k">return</span> <span class="nx">x</span><span class="o">+</span><span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><h4 id=3>3、外链</h4></p>
<div class="highlight"><pre class="chroma"><code class="language-markdown" data-lang="markdown">[<span class="nt">参考链接</span>](<span class="na">https://caychance.github.io/</span>)</code></pre></div>
<p><a href="https://caychance.github.io/">参考链接</a></p>

<p><h4 id=4>4、引入图片</h4></p>
<div class="highlight"><pre class="chroma"><code class="language-markdown" data-lang="markdown">![](https://blog-pics.pek3b.qingstor.com/006tNbRwly1fxq7h427d7j30780c7t9o.jpg)</code></pre></div>
<p><img src="https://blog-pics.pek3b.qingstor.com/006tNbRwly1fxq7h427d7j30780c7t9o.jpg" alt="" /></p>

<p><h4 id=5>5、引用</h4></p>
<div class="highlight"><pre class="chroma"><code class="language-markdown" data-lang="markdown">&gt;一段引用的话
换行了</code></pre></div>
<blockquote>
<p>一段引用的话
换行了</p>
</blockquote>

<p><h4 id=6>6、缩进</h4>
三种方法</p>
<div class="highlight"><pre class="chroma"><code class="language-markdown" data-lang="markdown">不带缩进的一行
&amp;nbsp;不断行的空白格或&amp;#160;
&amp;ensp;半方大的空白或&amp;#8194;
&amp;emsp;全方大的空白或&amp;#8195;</code></pre></div>
<p>不带缩进的一行
&nbsp;不断行的空白格或&#160;
&ensp;半方大的空白或&#8194;
&emsp;全方大的空白或&#8195;</p>

<p><h4 id=7>7、斜体</h4>
两种方法</p>
<div class="highlight"><pre class="chroma"><code class="language-markdown" data-lang="markdown">_这是斜体_
*这是斜体*</code></pre></div>
<p><em>这是斜体</em>
<em>这是斜体</em></p>

<p><h4 id=8>8、加粗</h4>
两种方法</p>
<div class="highlight"><pre class="chroma"><code class="language-markdown" data-lang="markdown">__这是斜体__
**这是斜体**</code></pre></div>
<p><strong>这是斜体</strong>
<strong>这是斜体</strong></p>

<p><h4 id=9>9、分割线</h4>
分割线只能标题下使用</p>
<div class="highlight"><pre class="chroma"><code class="language-markdown" data-lang="markdown"><span class="gu">##### 华丽的分割线
</span><span class="gu"></span>---
华丽的分割线</code></pre></div>
<h5 id="华丽的分割线">华丽的分割线</h5>

<hr />

<p>华丽的分割线</p>

<p><h4 id=10>10、待办</h4>
[ ] 前后都要有空格</p>
<div class="highlight"><pre class="chroma"><code class="language-markdown" data-lang="markdown"><span class="k">- [ ]</span> 不勾选
- [x] 勾选</code></pre></div>
<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> 不勾选</label></li>
<li><label><input type="checkbox" checked disabled class="task-list-item"> 勾选</label></li>
</ul>

<h4 id="11目录锚点">11目录锚点</h4>
<div class="highlight"><pre class="chroma"><code class="language-markdown" data-lang="markdown"><span class="k">*</span> [<span class="nt">中国</span>](<span class="na">#中国</span>)
  <span class="k">*</span> [<span class="nt">北京</span>](<span class="na">#北京</span>)
  <span class="k">*</span> [<span class="nt">陕西</span>](<span class="na">#陕西</span>)
    <span class="k">*</span> [<span class="nt">西安</span>](<span class="na">#西安_1</span>)
<span class="k">*</span> [<span class="nt">美国</span>](<span class="na">#美国</span>)
  <span class="k">*</span> [<span class="nt">纽约</span>](<span class="na">#纽约</span>)
<span class="k">*</span> [<span class="nt">俄罗斯</span>](<span class="na">#俄罗斯</span>)
  <span class="k">*</span> [<span class="nt">莫斯科</span>](<span class="na">#莫斯科</span>)
<span class="k">*</span> [<span class="nt">希腊</span>](<span class="na">#希腊</span>)
  * [<span class="nt">有些尴尬</span>](<span class="na">#有些尴尬</span>)</code></pre></div>
<ul>
<li><a href="#中国">中国</a>

<ul>
<li><a href="#北京">北京</a></li>
<li><a href="#陕西">陕西</a></li>
<li><a href="#西安_1">西安</a></li>
</ul></li>
<li><a href="#美国">美国</a>

<ul>
<li><a href="#纽约">纽约</a></li>
</ul></li>
<li><a href="#俄罗斯">俄罗斯</a>

<ul>
<li><a href="#莫斯科">莫斯科</a></li>
</ul></li>
<li><a href="#希腊">希腊</a>

<ul>
<li><a href="#有些尴尬">有些尴尬</a></li>
</ul></li>
</ul>

<p><h4 id=西安_1>西安</h4>
方法一：以标题西安为例。标题加一个id等于目录上西安的锚点西安_1。这种方式锚点中可以有特殊字符。</p>
<div class="highlight"><pre class="chroma"><code class="language-markdown" data-lang="markdown">&lt;h4 id=西安_1&gt;西安&lt;/h4&gt;</code></pre></div>
<h4 id="纽约">纽约</h4>

<p>方法二：以纽约为例。markdown的标题会自动加上锚点。例如下面的锚点自动就是纽约。不过这种方式设置的锚点中不能设置特殊字符。打开开发者模式查看一下元素就明白了。</p>
<div class="highlight"><pre class="chroma"><code class="language-markdown" data-lang="markdown">#### 纽约</code></pre></div>
<h4 id="12引入单句代码">12引入单句代码</h4>
<div class="highlight"><pre class="chroma"><code class="language-markdown" data-lang="markdown">使用`hexo server`启动服务，使用`hexo g`和`hexo d`发布</code></pre></div>
<p>使用<code>hexo server</code>启动服务，使用<code>hexo g</code>和<code>hexo d</code>发布</p>

<h4 id="13表格">13表格</h4>
<div class="highlight"><pre class="chroma"><code class="language-markdown" data-lang="markdown">|参数名|类型|描述|
|:---|:---:|---:|
|左对齐|居中|右对齐|</code></pre></div>
<table>
<thead>
<tr>
<th align="left">参数名</th>
<th align="center">类型</th>
<th align="right">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">左对齐</td>
<td align="center">居中</td>
<td align="right">右对齐</td>
</tr>
</tbody>
</table>
]]></content>
		</item>
		
		<item>
			<title>github没有记录你的contributions?</title>
			<link>https://caychance.github.io/posts/github%E6%B2%A1%E6%9C%89%E8%AE%B0%E5%BD%95%E4%BD%A0%E7%9A%84contributions/</link>
			<pubDate>Tue, 04 Dec 2018 10:51:31 +0000</pubDate>
			
			<guid>https://caychance.github.io/posts/github%E6%B2%A1%E6%9C%89%E8%AE%B0%E5%BD%95%E4%BD%A0%E7%9A%84contributions/</guid>
			<description>github是怎么计算contributions的呢？  贡献的计算 Issues and pull请求 如果issues和pull请求是在独立库中打开而不是分叉（fork），它们将显示在您的贡献图上。
Commits 如果commits符合以下所有的条件，那么会在您的贡献图上有所显示。
 用于提交的电子邮件地址与您的GitHub帐户相关联。 在独立的库中进行提交的，而不是分支（fork）。 提交内容如下：  &amp;emsp;在库的默认分支。（通常是master分支）。
&amp;emsp;在gh-pages分支中（对于具有Project Pages站点的库）。
 参考</description>
			<content type="html"><![CDATA[

<hr />

<h3 id="github是怎么计算contributions的呢">github是怎么计算contributions的呢？</h3>

<blockquote>
<h3 id="贡献的计算">贡献的计算</h3>

<h4 id="issues-and-pull请求">Issues and pull请求</h4>

<p>如果issues和pull请求是在独立库中打开而不是分叉（fork），它们将显示在您的贡献图上。</p>

<h4 id="commits">Commits</h4>

<p>如果commits符合以下所有的条件，那么会在您的贡献图上有所显示。</p>

<ol>
<li>用于提交的电子邮件地址与您的GitHub帐户相关联。</li>
<li>在独立的库中进行提交的，而不是分支（fork）。</li>
<li>提交内容如下：</li>
</ol>

<p>&emsp;在库的默认分支。（通常是master分支）。</p>

<p>&emsp;在gh-pages分支中（对于具有Project Pages站点的库）。</p>
</blockquote>

<p><a href="https://help.github.com/articles/why-are-my-contributions-not-showing-up-on-my-profile/">参考</a></p>
]]></content>
		</item>
		
		<item>
			<title>服务端渲染vs客户端渲染</title>
			<link>https://caychance.github.io/posts/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93vs%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93/</link>
			<pubDate>Sun, 02 Dec 2018 22:25:08 +0000</pubDate>
			
			<guid>https://caychance.github.io/posts/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93vs%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93/</guid>
			<description>前几天被人问到了nuxt是啥东西，我就知道这东西是vue的一个衍生品，别的就不知道了。然后吓得我回去赶紧翻开了nuxt的文档。
 Nuxt.js 是一个基于Vue.js 的轻量级应用框架，可用来创建服务端渲染(SSR) 应用，也可充当静态站点引擎生成静态站点应用，具有优雅的代码结构分层和热加载等balabala
 提到了一个词——服务端渲染，服务端渲染SSR（Server-Side Rendering）是什么？与之相对的是客户端渲染CSR（Client-Side Rendering）。 单从字面来理解，服务端渲染，就是服务端来渲染；客户端渲染则是客户端渲染。（这话听着像句废话）
什么是服务端渲染和客户端渲染 服务端渲染（后端渲染） 简单来说就是在服务器上把数据和模板拼接好以后发送给客户端显示。
客户端渲染（前端渲染） html 仅仅作为静态文件，客户端在请求时，服务端不做任何处理，直接以原文件的形式返回给客户端，然后客户端根据 html 上的 JavaScript，生成 DOM 插入 html。
现在常用的SPA单页应用模式，就是典型的前端渲染。
两者的本质区别 两者本地的区别就是谁来完成html文件的完整拼接。如果在后端完成，然后返回给前端，那么就是服务端渲染；否则就是客户端渲染。
服务端渲染的优缺点 优点： &amp;emsp;1.不占用客户端资源，前端耗时少
&amp;emsp;2.有利于SEO
缺点： &amp;emsp;1.占用服务端资源。如果请求量较多，会对服务器造成一定压力。
&amp;emsp;2.不利于前后端分离，开发效率较低。
客户端渲染的优缺点 优点： &amp;emsp;1.前后端分离。
&amp;emsp;2.体验更好，接近于原生app。
缺点： &amp;emsp;1.前端响应较慢，首屏加载缓慢。
&amp;emsp;2.不利于SEO。
SEO 后端渲染html叫吐或者喷，爬虫可以看到完整的呈现源码 前端模板渲染html叫填，爬虫看不到完整的呈现源码
如何选择 不谈业务场景而盲目选择使用何种渲染方式都是耍流氓。比如企业级网站，主要功能是展示而没有复杂的交互，并且需要良好的SEO，则这时我们就需要使用服务器端渲染；而类似后台管理页面，交互性比较强，不需要seo的考虑，那么就可以使用客户端渲染。
另外，具体使用何种渲染方法并不是绝对的，比如现在一些网站采用了首屏服务器端渲染，即对于用户最开始打开的那个页面采用的是服务器端渲染，这样就保证了渲染速度，而其他的页面采用客户端渲染，这样就完成了前后端分离。
写在最后  2016 年 10 月 25 日，zeit.co 背后的团队对外发布了 Next.js，一个 React 的服务端渲染应用框架。几小时后，与 Next.js 异曲同工，一个基于 Vue.js 的服务端渲染应用框架应运而生，我们称之为：Nuxt.js。
 随着Next.js和Nuxt.js的发布，以前是 Back-end（或者说 Full-stack）工程师负责 SSR，但是现在是 Front-end 工程师负责 SSR 了啊。</description>
			<content type="html"><![CDATA[

<hr />

<p>前几天被人问到了nuxt是啥东西，我就知道这东西是vue的一个衍生品，别的就不知道了。然后吓得我回去赶紧翻开了nuxt的文档。</p>

<blockquote>
<p>Nuxt.js 是一个基于Vue.js 的轻量级应用框架，可用来创建服务端渲染(SSR) 应用，也可充当静态站点引擎生成静态站点应用，具有优雅的代码结构分层和热加载等balabala</p>
</blockquote>

<p>提到了一个词——服务端渲染，服务端渲染SSR（Server-Side Rendering）是什么？与之相对的是客户端渲染CSR（Client-Side Rendering）。
单从字面来理解，服务端渲染，就是服务端来渲染；客户端渲染则是客户端渲染。（这话听着像句废话）</p>

<h3 id="什么是服务端渲染和客户端渲染">什么是服务端渲染和客户端渲染</h3>

<p>服务端渲染（后端渲染） 简单来说就是在服务器上把数据和模板拼接好以后发送给客户端显示。</p>

<p>客户端渲染（前端渲染） html 仅仅作为静态文件，客户端在请求时，服务端不做任何处理，直接以原文件的形式返回给客户端，然后客户端根据 html 上的 JavaScript，生成 DOM 插入 html。</p>

<p>现在常用的SPA单页应用模式，就是典型的前端渲染。</p>

<h3 id="两者的本质区别">两者的本质区别</h3>

<p>两者本地的区别就是<strong>谁来完成html文件的完整拼接</strong>。如果在后端完成，然后返回给前端，那么就是服务端渲染；否则就是客户端渲染。</p>

<h3 id="服务端渲染的优缺点">服务端渲染的优缺点</h3>

<h4 id="优点">优点：</h4>

<p>&emsp;1.不占用客户端资源，前端耗时少</p>

<p>&emsp;2.有利于SEO</p>

<h4 id="缺点">缺点：</h4>

<p>&emsp;1.占用服务端资源。如果请求量较多，会对服务器造成一定压力。</p>

<p>&emsp;2.不利于前后端分离，开发效率较低。</p>

<h3 id="客户端渲染的优缺点">客户端渲染的优缺点</h3>

<h4 id="优点-1">优点：</h4>

<p>&emsp;1.前后端分离。</p>

<p>&emsp;2.体验更好，接近于原生app。</p>

<h4 id="缺点-1">缺点：</h4>

<p>&emsp;1.前端响应较慢，首屏加载缓慢。</p>

<p>&emsp;2.不利于SEO。</p>

<h4 id="seo">SEO</h4>

<p>后端渲染html叫吐或者喷，爬虫可以看到完整的呈现源码
前端模板渲染html叫填，爬虫看不到完整的呈现源码</p>

<p><img src="https://blog-pics.pek3b.qingstor.com/006tNbRwly1fxuug2d9gwj316o0gcmy8.jpg" alt="" /></p>

<h3 id="如何选择">如何选择</h3>

<p>不谈业务场景而盲目选择使用何种渲染方式都是耍流氓。比如企业级网站，主要功能是展示而没有复杂的交互，并且需要良好的SEO，则这时我们就需要使用服务器端渲染；而类似后台管理页面，交互性比较强，不需要seo的考虑，那么就可以使用客户端渲染。</p>

<p>另外，具体使用何种渲染方法并不是绝对的，比如现在一些网站采用了首屏服务器端渲染，即对于用户最开始打开的那个页面采用的是服务器端渲染，这样就保证了渲染速度，而其他的页面采用客户端渲染，这样就完成了前后端分离。</p>

<h3 id="写在最后">写在最后</h3>

<blockquote>
<p>2016 年 10 月 25 日，zeit.co 背后的团队对外发布了 Next.js，一个 React 的服务端渲染应用框架。几小时后，与 Next.js 异曲同工，一个基于 Vue.js 的服务端渲染应用框架应运而生，我们称之为：Nuxt.js。</p>
</blockquote>

<p>随着Next.js和Nuxt.js的发布，<strong>以前是 Back-end（或者说 Full-stack）工程师负责 SSR，但是现在是 Front-end 工程师负责 SSR 了啊。</strong></p>

<p>参考文章：</p>

<p><a href="https://www.cnblogs.com/zhuzhenwei918/p/8795945.html">服务器端渲染和客户端渲染</a></p>

<p><a href="https://www.jianshu.com/p/3e62641eb381">也谈服务端渲染（SSR）</a></p>

<p><a href="https://jkchao.cn/article/5a11155fb520d115154c8fa1">服务端渲染 vs 客户端渲染</a></p>

<p><a href="https://www.zhihu.com/question/59578433">为什么现在又流行服务端渲染html？-知乎</a></p>

<p><a href="https://blog.csdn.net/b9q8e64lo6mm/article/details/79418969">为什么现在又流行服务器端渲染html？</a></p>
]]></content>
		</item>
		
		<item>
			<title>跨域</title>
			<link>https://caychance.github.io/posts/%E8%B7%A8%E5%9F%9F/</link>
			<pubDate>Sun, 02 Dec 2018 22:20:50 +0000</pubDate>
			
			<guid>https://caychance.github.io/posts/%E8%B7%A8%E5%9F%9F/</guid>
			<description>由来 同源策略是浏览器安全的基石。同源指的是： - 协议相同 - 域名相同 - 端口号相同
如果非同源，有三种行为受限制：
 Cookie、LocalStorage 和 IndexDB 无法读取。 DOM无法获得。 AJAX 请求不能发送。  同源策略的限制下，浏览器可以访问到后台服务器的数据，后台服务器也会正常返回数据，只是被浏览器给拦截了。
常见的跨域方案  jsonp
 只能发送get请求，不安全。兼容性好
 CORS
 就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。
服务端设置Access-Control-Allow-Origin即可
主流跨域解决方案
 postMessage
 不是使用 Ajax 的数据通信，更多是在两个页面之间的通信。例如A、B两个页面之间。
 WebSocket
 WebSocket是一种网络通信协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯。
 nginx代理跨域
 Node中间件代理跨域
 Vue脚手架的dev环境已经默认配置好
http-proxy-middleware
proxy-middleware
  代理来解决跨域 后两种方法都属于使用代理来解决跨域的方案。 原理是：两个服务器之间是不受同源策略限制的。</description>
			<content type="html"><![CDATA[

<hr />

<h3 id="由来">由来</h3>

<p>同源策略是浏览器安全的基石。同源指的是：
- 协议相同
- 域名相同
- 端口号相同</p>

<p>如果非同源，有三种行为受限制：</p>

<ul>
<li>Cookie、LocalStorage 和 IndexDB 无法读取。</li>
<li>DOM无法获得。</li>
<li>AJAX 请求不能发送。</li>
</ul>

<p><strong>同源策略的限制下，浏览器可以访问到后台服务器的数据，后台服务器也会正常返回数据，只是被浏览器给拦截了。</strong></p>

<h3 id="常见的跨域方案">常见的跨域方案</h3>

<ol>
<li><p>jsonp</p>

<blockquote>
<p>只能发送get请求，不安全。兼容性好</p>
</blockquote></li>

<li><p>CORS</p>

<blockquote>
<p>就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。</p>

<p>服务端设置Access-Control-Allow-Origin即可</p>

<p>主流跨域解决方案</p>
</blockquote></li>

<li><p>postMessage</p>

<blockquote>
<p>不是使用 Ajax 的数据通信，更多是在两个页面之间的通信。例如A、B两个页面之间。</p>
</blockquote></li>

<li><p>WebSocket</p>

<blockquote>
<p>WebSocket是一种网络通信协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯。</p>
</blockquote></li>

<li><p>nginx代理跨域</p></li>

<li><p>Node中间件代理跨域</p>

<blockquote>
<p>Vue脚手架的dev环境已经默认配置好</p>

<p>http-proxy-middleware</p>

<p>proxy-middleware</p>
</blockquote></li>
</ol>

<h3 id="代理来解决跨域">代理来解决跨域</h3>

<p>后两种方法都属于使用代理来解决跨域的方案。
原理是：<strong>两个服务器之间是不受同源策略限制的。</strong></p>
]]></content>
		</item>
		
		<item>
			<title>label标签语义化</title>
			<link>https://caychance.github.io/posts/label%E6%A0%87%E7%AD%BE%E8%AF%AD%E4%B9%89%E5%8C%96/</link>
			<pubDate>Fri, 30 Nov 2018 16:17:03 +0000</pubDate>
			
			<guid>https://caychance.github.io/posts/label%E6%A0%87%E7%AD%BE%E8%AF%AD%E4%B9%89%E5%8C%96/</guid>
			<description>今天做一个问卷调研的需求的时候，如下图。用户点击A选项的文字的时候被选中，而不是只能点击A前面的圆圈的时候。
html部分，需要使用input+label标签，其中label的for属性和input的id属性使用同一个变量。如下图：
&amp;lt;input type=&amp;#34;radio&amp;#34; :id=&amp;#34;subItem&amp;#34; class=&amp;#34;checkbox&amp;#34; v-model=&amp;#34;answers[index]&amp;#34;&amp;gt; &amp;lt;label :for=&amp;#34;subItem&amp;#34;&amp;gt;{{subItem}}&amp;lt;/label&amp;gt; 刚开始用的p标签，一直不好使。后来解决了以后，去搜了一下label标签的语义化
  标签为 input 元素定义标注（标记）。 label 元素不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性。 如果您在 label 元素内点击文本，就会触发此控件。 就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。  标签的 for 属性应当与相关元素的 id 属性相同。
 </description>
			<content type="html"><![CDATA[<hr />

<p>今天做一个问卷调研的需求的时候，如下图。用户点击A选项的文字的时候被选中，而不是只能点击A前面的圆圈的时候。</p>

<p><img src="https://blog-pics.pek3b.qingstor.com/006tNbRwly1fxq5xd2ppyj30j20dyjtt.jpg" alt="" /></p>

<p>html部分，需要使用input+label标签，其中label的for属性和input的id属性使用同一个变量。如下图：</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;radio&#34;</span> <span class="na">:id</span><span class="o">=</span><span class="s">&#34;subItem&#34;</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;checkbox&#34;</span> <span class="na">v-model</span><span class="o">=</span><span class="s">&#34;answers[index]&#34;</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">label</span> <span class="na">:for</span><span class="o">=</span><span class="s">&#34;subItem&#34;</span><span class="p">&gt;</span>{{subItem}}<span class="p">&lt;/</span><span class="nt">label</span><span class="p">&gt;</span></code></pre></div>
<p>刚开始用的p标签，一直不好使。后来解决了以后，去搜了一下label标签的语义化</p>

<blockquote>
<p><label> 标签为 input 元素定义标注（标记）。
label 元素不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性。
如果您在 label 元素内点击文本，就会触发此控件。
就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。
<label> 标签的 for 属性应当与相关元素的 id 属性相同。</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>函数参数的解构赋值和函数参数的默认值</title>
			<link>https://caychance.github.io/posts/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E5%92%8C%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC/</link>
			<pubDate>Fri, 30 Nov 2018 10:58:47 +0000</pubDate>
			
			<guid>https://caychance.github.io/posts/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E5%92%8C%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC/</guid>
			<description>昨天在二刷阮一峰es6的时候，看到了一个思考题。
// 写法一 function m1({x = 0, y = 0} = {}) { return [x, y]; } // 写法二 function m2({x, y} = { x: 0, y: 0 }) { return [x, y]; }  以上两种写法的差异在哪里？
写法一中m1函数的入参是一个对象（默认值为一个空对象），该对象有两个属性，x（默认值为0）和y（默认值为0）。
写法二中m2函数的入参是一个对象（默认值为一个对象，对象x和y属性都为0）。
// 函数没有参数的情况 m1() // [0, 0] m2() // [0, 0]  // x 和 y 都有值的情况 m1({x: 3, y: 8}) // [3, 8] m2({x: 3, y: 8}) // [3, 8]  // x 有值，y 无值的情况 m1({x: 3}) // [3, 0] m2({x: 3}) // [3, undefined]  // x 和 y 都无值的情况 m1({}) // [0, 0]; m2({}) // [undefined, undefined]  m1({z: 3}) // [0, 0] m2({z: 3}) // [undefined, undefined]  参考链接-阮一峰es6</description>
			<content type="html"><![CDATA[<hr />

<p>昨天在二刷阮一峰es6的时候，看到了一个思考题。</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// 写法一
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">m1</span><span class="p">({</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">}</span> <span class="o">=</span> <span class="p">{})</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">// 写法二
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">m2</span><span class="p">({</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">x</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">0</span> <span class="p">})</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div>
<p>以上两种写法的差异在哪里？</p>

<p>写法一中m1函数的入参是一个对象（默认值为一个空对象），该对象有两个属性，x（默认值为0）和y（默认值为0）。</p>

<p>写法二中m2函数的入参是一个对象（默认值为一个对象，对象x和y属性都为0）。</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// 函数没有参数的情况
</span><span class="c1"></span><span class="nx">m1</span><span class="p">()</span> <span class="c1">// [0, 0]
</span><span class="c1"></span><span class="nx">m2</span><span class="p">()</span> <span class="c1">// [0, 0]
</span><span class="c1"></span>
<span class="c1">// x 和 y 都有值的情况
</span><span class="c1"></span><span class="nx">m1</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">8</span><span class="p">})</span> <span class="c1">// [3, 8]
</span><span class="c1"></span><span class="nx">m2</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">8</span><span class="p">})</span> <span class="c1">// [3, 8]
</span><span class="c1"></span>
<span class="c1">// x 有值，y 无值的情况
</span><span class="c1"></span><span class="nx">m1</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span> <span class="mi">3</span><span class="p">})</span> <span class="c1">// [3, 0]
</span><span class="c1"></span><span class="nx">m2</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span> <span class="mi">3</span><span class="p">})</span> <span class="c1">// [3, undefined]
</span><span class="c1"></span>
<span class="c1">// x 和 y 都无值的情况
</span><span class="c1"></span><span class="nx">m1</span><span class="p">({})</span> <span class="c1">// [0, 0];
</span><span class="c1"></span><span class="nx">m2</span><span class="p">({})</span> <span class="c1">// [undefined, undefined]
</span><span class="c1"></span>
<span class="nx">m1</span><span class="p">({</span><span class="nx">z</span><span class="o">:</span> <span class="mi">3</span><span class="p">})</span> <span class="c1">// [0, 0]
</span><span class="c1"></span><span class="nx">m2</span><span class="p">({</span><span class="nx">z</span><span class="o">:</span> <span class="mi">3</span><span class="p">})</span> <span class="c1">// [undefined, undefined]
</span></code></pre></div>
<p><a href="http://es6.ruanyifeng.com/#docs/function">参考链接-阮一峰es6</a></p>
]]></content>
		</item>
		
		<item>
			<title>flex布局</title>
			<link>https://caychance.github.io/posts/flex%E5%B8%83%E5%B1%80/</link>
			<pubDate>Wed, 28 Nov 2018 17:06:01 +0000</pubDate>
			
			<guid>https://caychance.github.io/posts/flex%E5%B8%83%E5%B1%80/</guid>
			<description> flex的一个兼容问题 flex布局中的justify-content: space-evenly;在部分安卓手机上是不支持这个属性的。
justify-content: space-evenly 解决方案 可以使用space-around或者space-between配合margin一起使用达到space-evenly的效果
justify-content: space-aroundjustify-content: space-between</description>
			<content type="html"><![CDATA[

<hr />

<h3 id="flex的一个兼容问题">flex的一个兼容问题</h3>

<p>flex布局中的justify-content: space-evenly;在部分安卓手机上是不支持这个属性的。</p>
<div class="highlight"><pre class="chroma"><code class="language-css" data-lang="css"><span class="nt">justify-content</span><span class="o">:</span> <span class="nt">space-evenly</span></code></pre></div>
<h3 id="解决方案">解决方案</h3>

<p>可以使用space-around或者space-between配合margin一起使用达到space-evenly的效果</p>
<div class="highlight"><pre class="chroma"><code class="language-css" data-lang="css"><span class="nt">justify-content</span><span class="o">:</span> <span class="nt">space-around</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-css" data-lang="css"><span class="nt">justify-content</span><span class="o">:</span> <span class="nt">space-between</span></code></pre></div>]]></content>
		</item>
		
		<item>
			<title>异步编程的前世今生</title>
			<link>https://caychance.github.io/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A/</link>
			<pubDate>Tue, 27 Nov 2018 18:20:25 +0000</pubDate>
			
			<guid>https://caychance.github.io/posts/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A/</guid>
			<description>问题起源  因为JS只有一根线程，因此异步编程对JS很重要。  目的  异步编程的语法目标，就是怎样让它更像同步编程。  很久很久以前 异步编程的方法有四种：
 回调函数； 事件监听； 发布/订阅； Promise对象。  回调函数的故事：  概念 JS对异步编程的实现就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。 局限性 回调函数本身没有问题，但是多个回调函数嵌套的时候就会有问题。会导致代码横向发展，而不是纵向发展。称之为回调地狱。 解决之道 为了解决该问题，Promise诞生了，它不是新的语法功能，而是一种新的写法，允许将回调函数的横向加载改为纵向加载。 改进的地方 Promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。 新面临的问题 然后，Promise也面临一个巨大的问题，代码冗余，原来的任务被Promise包装一下，一眼看去都是一堆then，语义变的不清楚。   协程的故事  概念 传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做&amp;rdquo;协程&amp;rdquo;（coroutine），意思是多个线程互相协作，完成异步任务。
 本质 协程的终极奥义就在于yield命令，它表示执行到此处，执行权将交给其他协程。即yield命令是异步两个阶段的分界线。
 协程在ES6中的衍生及其特点 于是乎，Generator函数诞生了。它是协程在ES6中的实现，其最大特点就是可以交出函数的执行权，即暂停执行。整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用 yield 语句注明。
 Generator的另外两个特性 Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。
 函数体内外数据交换 next 方法返回值的 value 属性，是 Generator 函数向外输出数据；next 方法还可以接受参数，这是向 Generator 函数体内输入数据。
 错误处理机制 Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。
 Generator函数的局限：
 不能自动执行
 程序的执行权移出以后，需要再次交换回来。</description>
			<content type="html"><![CDATA[

<hr />

<h3 id="问题起源">问题起源</h3>

<ul>
<li>因为JS只有一根线程，因此异步编程对JS很重要。</li>
</ul>

<h3 id="目的">目的</h3>

<ul>
<li>异步编程的语法目标，就是怎样让它更像同步编程。</li>
</ul>

<h3 id="很久很久以前">很久很久以前</h3>

<p>异步编程的方法有四种：</p>

<ul>
<li>回调函数；</li>
<li>事件监听；</li>
<li>发布/订阅；</li>
<li>Promise对象。</li>
</ul>

<h3 id="回调函数的故事">回调函数的故事：</h3>

<ul>
<li>概念
<br>JS对异步编程的实现就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。</li>
<li>局限性
<br>回调函数本身没有问题，但是多个回调函数嵌套的时候就会有问题。会导致代码横向发展，而不是纵向发展。称之为回调地狱。</li>
<li>解决之道
<br>为了解决该问题，Promise诞生了，它不是新的语法功能，而是一种新的写法，允许将回调函数的横向加载改为纵向加载。</li>
<li>改进的地方
<br>Promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。</li>
<li>新面临的问题
<br>然后，Promise也面临一个巨大的问题，代码冗余，原来的任务被Promise包装一下，一眼看去都是一堆then，语义变的不清楚。
<br /></li>
</ul>

<h3 id="协程的故事">协程的故事</h3>

<ul>
<li><p>概念
<br>传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做&rdquo;协程&rdquo;（coroutine），意思是多个线程互相协作，完成异步任务。</p></li>

<li><p>本质
<br>协程的终极奥义就在于yield命令，它表示执行到此处，执行权将交给其他协程。即yield命令是异步两个阶段的分界线。</p></li>

<li><p>协程在ES6中的衍生及其特点
<br>于是乎，Generator函数诞生了。它是协程在ES6中的实现，其最大特点就是可以交出函数的执行权，即暂停执行。整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用 yield 语句注明。</p></li>

<li><p>Generator的另外两个特性
<br>Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。</p></li>

<li><p>函数体内外数据交换
<br>next 方法返回值的 value 属性，是 Generator 函数向外输出数据；next 方法还可以接受参数，这是向 Generator 函数体内输入数据。</p></li>

<li><p>错误处理机制
<br>Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。</p></li>

<li><p>Generator函数的局限：</p>

<ul>
<li><p>不能自动执行</p></li>

<li><p>程序的执行权移出以后，需要再次交换回来。</p></li>
</ul></li>
</ul>

<p>综上所述：Generator 函数就是一个异步操作的容器。它的自动执行需要一种机制（即自动执行器），当异步操作有了结果，能够自动交回执行权</p>

<ul>
<li><p>两种解决之道<br />
由于Generator函数中的yield 命令用于将程序的执行权移出 Generator 函数，那么就需要一种方法，将执行权再交还给 Generator 函数。</p>

<ul>
<li><p>基于Thunk函数的自动执行器：回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。</p></li>

<li><p>基于Promise对象的自动执行器：Promise 对象。将异步操作包装成 Promise 对象，用 then 方法交回执行权。</p></li>
</ul></li>

<li><p>co函数库，用于Generator函数的自动执行。</p>

<p>它可以使你不用编写Generator函数的执行器。其原理就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个库。使用 co 的前提条件是，Generator 函数的 yield 命令后面，只能是 Thunk 函数或 Promise 对象。</p></li>
</ul>

<h3 id="异步编程的终极解决之道-async函数">异步编程的终极解决之道：async函数</h3>

<ul>
<li><p>概念
<br>一句话，async函数就是Generator函数的语法糖。</p></li>

<li><p>改进点
<br>async函数对Generator函数的改进体现在以下几点：</p>

<ul>
<li><p>内置执行器
<br>Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。</p></li>

<li><p>更好的语义
<br>async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</p></li>

<li><p>更广的适用性
<br>co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。所以，async函数的实现，就是把Generator函数和自动执行器包装在一个函数里。</p></li>

<li><p>返回值是Promise
<br>async函数的返回值是 Promise 对象。</p></li>
</ul></li>

<li><p>使用手册说明</p>

<ul>
<li>await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try&hellip;catch中。</li>
<li>await命令只能用在async函数中，如果用在普通函数中，就会报错。</li>
<li>如有多个请求并发执行，请使用Promise.all方法。</li>
</ul></li>
</ul>

<p><a href="http://www.ruanyifeng.com/blog/2015/04/generator.html">参考链接</a></p>
]]></content>
		</item>
		
		<item>
			<title>Hello World</title>
			<link>https://caychance.github.io/posts/hello-world/</link>
			<pubDate>Mon, 26 Nov 2018 16:17:03 +0000</pubDate>
			
			<guid>https://caychance.github.io/posts/hello-world/</guid>
			<description>Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.
Quick Start Create a new post $ hexo new &amp;#34;My New Post&amp;#34; More info: Writing
Run server $ hexo server More info: Server
Generate static files $ hexo generate More info: Generating
Deploy to remote sites $ hexo deploy More info: Deployment</description>
			<content type="html"><![CDATA[

<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>

<h2 id="quick-start">Quick Start</h2>

<h3 id="create-a-new-post">Create a new post</h3>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ hexo new <span class="s2">&#34;My New Post&#34;</span></code></pre></div>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>

<h3 id="run-server">Run server</h3>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ hexo server</code></pre></div>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>

<h3 id="generate-static-files">Generate static files</h3>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ hexo generate</code></pre></div>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>

<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ hexo deploy</code></pre></div>
<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
		</item>
		
	</channel>
</rss>
